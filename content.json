{"pages":[{"title":"all-archives","text":"","link":"/all-archives/index.html"},{"title":"all-categories","text":"","link":"/all-categories/index.html"},{"title":"all-tags","text":"","link":"/all-tags/index.html"},{"title":"Composite Pattern02","text":"설명 Directory 관리 Class Diagram Code Result Reference Java 객체지향 디자인 패턴 ( 정인상, 채흥석 지음 )","link":"/image/2018-04-22-Composite%20Pattern02.html"}],"posts":[{"title":"1406:에디터","text":"https://www.acmicpc.net/problem/1406 풀이 스택 두개 생성. lStack, rStack 초기 입력 문자열 lStack에 모두 push 명령어 대로 L : lStack의 top 문자를 rStack에 push D : rStack의 top 문자를 lStack에 push B : lStack pop P $ : lStack에 $ push 왼쪽 스택 문자 하나하나 pop해서 rStack에 push rStack 하나하나 pop 해서 출력","link":"/2017/09/05/boj-editor/"},{"title":"9012:괄호","text":"https://www.acmicpc.net/problem/9012 풀이 ‘(‘ 이면 스택 push ‘)’ 이면 스택 pop 마지막에 스택 size 가 0 이면 VPS","link":"/2017/09/05/boj-parentheses/"},{"title":"쇠막대기","text":"https://www.acmicpc.net/problem/10799 풀이 ‘(‘ 이면 stack에 push ‘)’ 이면 바로 전 문자 확인. 전 문자가 ‘(‘ 이면 stack에서 pop 하고 stack size 만큼 더해 레이저이기 때문에, stack size만큼 짤림 ‘)’ 이면 1 더하고 stack pop 막대기의 끝이기 때문, 한 개만큼 짤림","link":"/2017/09/05/boj-pole/"},{"title":"Level3_다음 큰 숫자","text":"https://programmers.co.kr/learn/challenge_codes/170 풀이 79, 80, 81, 82, 83 ~ 차례대로 이진수로 바꿨을 때의 1 개수 count 78을 이진수로 바꿨을 때의 1 개수와 같은지 확인 1개수가 같은 순간의 숫자가 정답. 1 개수가 같은, 가장 작은 숫자를 찾는 것이므로","link":"/2017/09/05/leve3-%EB%8B%A4%EC%9D%8C%ED%81%B0%EC%88%AB%EC%9E%90/"},{"title":"Level3_멀리뛰기","text":"https://programmers.co.kr/learn/challenge_codes/153 풀이 한 칸을 오르는 방법 : 1 두 칸을 오르는 방법 : 2 세 칸을 오르는 방법 ​ 처음 한 칸 오르고 나머지 두 칸 오르는 방법 ​ + 처음 두 칸 오르고 나머지 한 칸 오르는 방법 네 칸을 오르는 방법 처음 한 칸 오르고 나머지 세 칸 오르는 방법 ​ + 처음 두 칸 오르고 나머지 두 칸 오르는 방법 f(1) =1 / f(2) =2 / … / f(n+2) = f(n+1) + f(n) 개념 Dynamic Programming 복잡한 문제를 간단한 문제로 나눠 푸는 방법. 문제를 여러 하위 문제로 나눠 푼 다음, 그 결과를 이용하여 결합해 문제 해결 피보나치 수열","link":"/2017/09/06/leve3-%EB%A9%80%EB%A6%AC%EB%9B%B0%EA%B8%B0/"},{"title":"level3_n개의 최소공배수","text":"https://programmers.co.kr/learn/challenge_codes/152 풀이 두 수의 최소 공배수 두 수의 곱 / 두 수의 최대공약수 두 수의 최대 공약수 ![img](http://cfile27.uf.tistory.com/image/ 992E363359B0DF7D1A5547) 10 12 14 의 최소공배수 (10, 12) 의 최소공배수와 14의 최소공배수 개념 유클리드 알고리즘 (from 위키백과) - 호제법이란 말은 두 수가 서로(互) 상대방 수를 나누어(除)서 결국 원하는 수를 얻는 알고리즘. - 2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a&gt;b), - a와 b의 최대공약수는 b와 r의 최대공약수와 같다. - 이 성질에 따라, b를 r로 나눈 나머지 r'를 구하고, - 다시 r을 r'로 나눈 나머지를 구하는 과정을 반복하여 - 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.","link":"/2017/09/07/leve3-n%EA%B0%9C%EC%9D%98%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"},{"title":"Dynamic Programming","text":"정의 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법 원리 문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 최종적인 목적에 도달 각 하위 문제의 해결을 계산한 뒤, 그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 그것을 간단하게 해결 예제 막대기 자르기 ( 막대기를 적절히 잘라서 가장 가격이 높게 만들어야 함) 12길이(i) 0 1 2 3 4 5 6 7 8 9 10가격(Pi) 0 1 5 8 9 10 17 17 20 24 30 길이가 4인 막대기로 자를 때 얻을 수 있는 최대 가격 : 길이 2인 막대기 두 개로 자름. -&gt; 5 + 5 = 10 길이가 6인 막대기 : 자르지 않고 그대로 길이가 n인 막대기의 최대 가격 = Rn = max(Pi + Rn-i) (i는 1부터 n) R1 = max(P1 + R0) =1 R2 = max(P1 + R1, P2 + R0) = 5 R3 = max(P1 + R2, P2 + R1, P3 + R0) = 8 R4 = max(P1 + R3, P2 + R2, P3 + R1) = 10 –&gt; R1, R2, R3… 가 반복적으로 나옴 . 메모제이션 사용. 이전에 계산한 값들 저장. 단점 모든 방법을 일일이 검토하여 그 중 최적해를 찾아내는 주먹구구식 방법 장점 문제가 가능한 모든 방법을 충분히 빠른 속도로 처리할 수 있는 경우, 동적 계획법은 최적의 해법 계산 횟수를 줄임 하위 문제의 수가 기하급수적으로 증가할 때 유용 그리디 알고리즘과 비교ex) A라는 지점에서 B라는 지점까지 가능한 빨리 이동하는 경로를 찾기” 그리디 : 전체적인 상황을 고려하지 않고, 순간순간 교차로가 보일 때마다 가장 빠른 경로를 검색 즉효성이 있음, but 항상 최적의 경로를 찾아주지는 않음 (각 구간마다는 최적경로O, 전체적으로는 최적 경로X) DP : 갈 수 있는 모든 상황과 교통 정체를 전부 감안하여 최적의 경로 찾음 약간의 시간 소요, but 가장 빠른 길이 된다고 장담","link":"/2017/09/08/Dynamic%20Programming/"},{"title":"leve3_야근지수","text":"https://programmers.co.kr/learn/challenge_codes/145 풀이 리스트의 값 중 최대값을 찾음 n이 0이 될때 까지, 그 최대값 -1 최종 제곱의 합을 출력","link":"/2017/09/08/leve3-%EC%95%BC%EA%B7%BC%EC%A7%80%EC%88%98/"},{"title":"level3_시저암호","text":"https://programmers.co.kr/learn/challenge_codes/144 풀이 소문자이면 현재 문자에서 ‘a’ 기준으로 얼만큼 떨어져 있는지 + n 알파뱃 수 만큼 % a 대문자이면 소문자와 같은 방식 공백 pass","link":"/2017/09/09/leve3-%EC%8B%9C%EC%A0%80%EC%95%94%ED%98%B8/"},{"title":"10845:큐","text":"https://www.acmicpc.net/problem/10845 DFS 풀이 head, tail 을 둔다 push head는 초기 추가된 노드를 계속 가르킴 tail이 가르키느 노드는, 새로 추가된 노드를 가르킴 tail은, 새로 추가된 노드를 가르킴 pop head가 가르키는 노드가 가르키는 노드를 head가 가르킴","link":"/2017/09/09/%ED%81%90/"},{"title":"1260:DFS와BFS","text":"https://www.acmicpc.net/problem/1260 풀이 어레이리스트 생성 ArrayList[] a = (ArrayList[]) new ArrayList[n+1]; DFS dfs(x) : x를 방문 한 정점에 연결된 정점들 중에 방문하지 않았으면 방문 BFS 아직 방문 하지 않았고 현 위치에서 갈 수 있는 정점들을 모두 큐에 넣어 큐에 넣을 때 방문했다고 체크 결과","link":"/2017/09/11/DFS%EC%99%80BFS%EB%AC%B8%EC%A0%9C/"},{"title":"모의테스트01_각 자릿수의 합","text":"문제자연수 N이 주어지면, N의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요.예를들어 N = 123이면 1 + 2 + 3 = 6을 return 하면 됩니다. 제한사항 * N의 범위 : 100,000,000 이하의 자연수 &lt;br&gt; &lt;입출력 예&gt; N — answer 123 — 6 987 — 24 입출력 예 설명입출력 예 #1문제의 예시와 같습니다.입출력 예 #29 + 8 + 7 = 24이므로 24를 return 하면 됩니다. 풀이 정수형으로 입력 받음 입력 받음 정수형을 문자열형으로 변환 ( 자릿수 구하기 용이하기 때문 ) chatAt(i) 번째 - ‘ 0 ‘ 을 하면 그 자릿수가 나옴 각각 더하면 결과값 나옴 개념 987이 입력되면 ‘9’ - ‘0’ = 57 - 48 = 9","link":"/2017/09/12/%EB%AA%A8%EC%9D%98%ED%85%8C%EC%8A%A4%ED%8A%B801-%EA%B0%81%EC%9E%90%EB%A6%BF%EC%88%98%EC%9D%98%ED%95%A9/"},{"title":"Greedy Algorithm","text":"정의 어떤 것을 결정해야 하는 순간, 가장 좋다고 생각하는 것을 선택하면서 답 찾는 알고리즘 Dynamic Programming과 비교 DP : 어떤 상황에서 할수 있는 상황 모두 살펴보고 거기서 가장 좋은것 선택 Greedy : 할수 있는 선택 중에 제일 좋다고 생각되는 것 하나 선택해서 정답 찾아감 단점 그 때 그 때는 최적일 수 있지만, 최종적으로는 최적이 아니 수도 1234567891011ex) 12원을 1, 4, 5원으로 거슬러 줄 때, 5원 2개, 1원 2개 --&gt; 총 4개가 필요but, 정답은 4원 3개!!!DP로 풀어야해.D[n] = n원을 거슬러 주는 동전의 최소 개수min(D[n-1], D[n-4], D[n-5]) + 1 그럼 언제 쓰나 지금 이 순간 가장 좋은 경우 선택하는 것이 최적일 때. 왜 그게 최적인지 증명해야함 그래서 가장 어려워 그래서 시험이나 대회에 나오면 가장 나중에 풀어 예제https://www.acmicpc.net/problem/11399 줄 서 있는 사람 N, 각 사람의 인출 시간 Pi. 각 사람이 인출하는데 필요한 시간의 합의 최소값은? 12345678910111213ex) P1=3, P2=1, P3=4, P4=3, P5=21번 : 3분 소요2번 : 3 +1 = 4분 소요 3번 : 3 + 1 + 4 = 8분 소요 4번 : 3 + 1 + 4 + 3 = 11분 소요 5번 : 3 + 1 + 4 + 3 + 2 = 13 분 소요 따라서, 3 + 4 + 8 + 11 + 13 = 39분 소요 기다리는 시간 짧은 사람부터 인출하는 것이 좋음 … 이걸 증명해야함. p1 &lt;= p2&lt;= ……&lt;=pn 이라고 가정 S = p1 + (p1+p2) + (p1+p2+p3) + …. + (p1+p2+p3+…+pn) = n*p1 + (n-1)*p2 + … + pn 중간에 i&lt;j 인 pi&lt;pj 순서를 바꾸면 S는 더 커지거나 같아져야함. 즉, S &lt;= S ----&gt; S-S &lt;=0 계산결과, S-S`&lt;=0 을 성립함. 따라서 오름차순이 정답","link":"/2017/09/17/Greedy%20Algorithm/"},{"title":"1463:1로 만들기","text":"https://www.acmicpc.net/problem/1463 풀이D[N] = N을 1로 만드는데 필요한 연산의 최솟값 N​ -&gt; N-3 -&gt; ….. &gt; 1 : 1 + D[N/3] ====1번 ​ -&gt; N-2 -&gt; ….. &gt; 1 : 1 + D[N/2] ====2번 ​ -&gt; N-1 -&gt; ….. &gt; 1 : 1 + D[N/1] ====3번 D[N] = min(1번, 2번, 3번)","link":"/2017/09/18/1%EB%A1%9C%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"11726:2xn타일링","text":"https://www.acmicpc.net/problem/11726 풀이 d(n) = d(n-2) + n(n-1) 재귀함수 “왜 시간 초과?”","link":"/2017/09/19/2xn%ED%83%80%EC%9D%BC%EB%A7%81/"},{"title":"11727:2xn타일링2","text":"https://www.acmicpc.net/problem/11727 풀이 d(n) = d(n-1) + 2*d(n-2) 재귀","link":"/2017/09/20/2xn%ED%83%80%EC%9D%BC%EB%A7%812/"},{"title":"9095:1,2,3더하기","text":"https://www.acmicpc.net/problem/9095 풀이재귀로 푸니 또 다시 런타임 에러. 그래서 재귀로 풀지 않음 핵심 : 가장 마지막에 1을 더하거나, 2를 더하거나, 3을 더하건 d[n] = d[n-1] + d[n-2] + d[n-3]","link":"/2017/09/21/123%EB%8D%94%ED%95%98%EA%B8%B0/"},{"title":"11052:붕어빵 판매하기","text":"https://www.acmicpc.net/problem/11052 풀이d[n] = n개 팔아서 얻을 수 있는 최대 수익 따라서max( p[i] + d[n-i] )i는 1~n","link":"/2017/09/22/%EB%B6%95%EC%96%B4%EB%B9%B5%ED%8C%90%EB%A7%A4%ED%95%98%EA%B8%B0/"},{"title":"10844:쉬운계단수","text":"https://www.acmicpc.net/problem/10844 틀린 풀이직접 길이가 1인 계단수 길이가 2인 계단수…를 하나하나 구해보니 길이가 n인 계단 수 = 길이가 n-1인 계단수 * 2 -1 이라는 규칙이 나왔다.하지만 계속 채점 결과는 틀렸다고 나옴.. 맞는 풀이이차원 배열로 품 * D[i][j] : 길이 i, 마지막 숫자가 j인 계단 수의 개수 * D[N][L] : N자리 계단수 마지막수는 L인 계단수의 개수 * D[N][L] = D[N-1][L-1] + D[N-1][L+1] (L : 1~8) * D[N][0] = D[N][1] * D[N][9] = D[N-1][8]","link":"/2017/09/23/%EC%89%AC%EC%9A%B4%EA%B3%84%EB%8B%A8%EC%88%98/"},{"title":"11057:오르막수","text":"https://www.acmicpc.net/problem/11057 풀이 이차원 배열로 생각 식 세우기 … 다음과 같이 시도했지만 정답 도출 실패.. ==&gt; 답지 보고 다시 풀 예정 12int d[n][l] : 자리수가 n 자리인 수의 마지막 수가 l인 오르막 수의 개수d[n][l] = d[n-1][l] + (10-l) ( l은 0~9 )","link":"/2017/09/25/%EC%98%A4%EB%A5%B4%EB%A7%89%EC%88%98/"},{"title":"2193:이친수","text":"https://www.acmicpc.net/problem/2193 풀이 1) d[n][l] 자리가 n &amp; 끝자리가 l 인 이친수의 개수 d[n][0] d[n-1][0] + d[n-1][1] d[n][1] d[n-1][0] ans d[n][0]+d[n][1] =&gt; 근데 왜 답은 틀렸다고 나올까..? 풀이 2) d[n] n 자리 이친수의 개수 d[n-1] + d[n-2] =&gt; 이 방법도 틀리게 나옴","link":"/2017/09/26/%EC%9D%B4%EC%B9%9C%EC%88%98/"},{"title":"9465:스티커","text":"https://www.acmicpc.net/problem/9465 풀이 s : n열의 상태 [0] [1] [2] X O X X X O d[n][s] 2 x n 에서 얻을 수 있는 최대 점수. n열에서 뜯은 스티커는 s a[i][j] i열 j행에 들어있는 스티커의 점수 결과 d[n][0] = max( d[n-1][0] , d[n-1][1] , d[n-1][2] ) d[n][1] = max( d[n-1][0] , d[n-1][2] ) + a[n][1] d[n][2] = max( d[n-1][0] , d[n-1][1] ) + a[n][2] 정답 max( d[n][0], d[n][1], d[n][2] ) ==&gt; 어렵다. 다시 풀어야함","link":"/2017/09/27/%EC%8A%A4%ED%8B%B0%EC%BB%A4/"},{"title":"2156:포도주 시식","text":"https://www.acmicpc.net/problem/2156 풀이 1) 이차원 배열 d[i][j] 1~i 번째 포도주까지 마셨을 때, 마실 수 있는 포도주의 최대 양i번째 포두주 잔은 j 번 연속 마신 포도주 잔임 a[i] (i : 1~n) i 번째 포도주의 양 결과 d[n][0] = max( d[n-1][0] , d[n-1][1], d[n-1][2] ) d[n][1] = d[n-1][0] + a[n] d[n][2] = d[n-1][1] + a[n] 풀이 2) 일차원 배열 d[i] 1~i 번째 포도주까지 마셨을 때, 마실 수 있는 포도주의 최대 양 a[i] (i : 1~n) i 번째 포도주의 양 결과 0번 연속 : d[i] = d[i-1] 1번 연속 : d[i] = d[i-2] + a[i] 2번 연속 : d[i] = d[i-3] + a[i-1] + a[i]","link":"/2017/09/28/%ED%8F%AC%EB%8F%84%EC%A3%BC%EC%8B%9C%EC%8B%9D/"},{"title":"11053:가장 긴 증가하는 부분 수열","text":"https://www.acmicpc.net/problem/11053 틀린 풀이 d[n] 첫번째 ~ n번째 값 중, 가장 큰 수 10 20 10 30 20 50 d[0] = 0 d[1] = 10 d[2] = 20 d[3] = 20 d[4] = 30 d[5] = 30 d[6] = 50 d 배열의 값이 바뀔 때를 count count 값이 답. 맞는 풀이LIS 문제. 유명한 문제. d[i] a[1] … a[i] 가 있을 때, a[i]를 마지막으로 하는 가장 긴 증가하는 부분 수열의 길이. d[i]는 a[i] 가 반드시 포함 ~ a[j] … a[i] ~ a[j]길이 : d[j] —-&gt; d[j] + 1 d[i] max( d[j] ) + 1 a[j] 와 a[i]의 관계 a[j] &lt; a[i] 123456789 i 1 2 3 4 5 6 a[i] 10 20 10 30 20 50 d[i] 1 2 1 3 2 4 d[4]를 예를들어,d[4]는 처음에 1. 왜냐하면 자기 자신하나만 있으면 길이기 1이기 때문에.a[3]을 봤더니, a[4]보다 작아. 증가하는 수열이기때문에 올 수 있어. 그럼, d[3] +1 = 2. 1보다 크기 때문에. d[4]=2a[2]을 봤더니, a[4]보다 작아. 증가하는 수열이기때문에 올 수 있어. 그럼, d[2] +1 = 3. 2보다 크기 때문에 d[4] =3 a[1]을 봤더니, a[4]보다 작아. 증가하는 수열이기때문에 올 수 있어. 그럼, d[1] +1 = 1. 3보다 작기 때문에 그대로","link":"/2017/09/29/%EA%B0%80%EC%9E%A5%EA%B8%B4%EC%A6%9D%EA%B0%80%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%202/"},{"title":"11055:가장 큰 증가 부분 수열","text":"https://www.acmicpc.net/problem/11055 틀린 풀이 d[i] a[1] ~ a[i] 중 a[i]를 포함하며, 수열의 합 i번째를 기준으로 i-1번째 ~ 1번째로 하나 하나 검색 i번째보다 작으면 d[i]에 더함 맞는 풀이 앞 문제와 동일하다 앞 문제의 조건 i &lt; j =&gt; a[i] &lt; a[j] max(d[j]) + 1 =&gt; 여기서 1은 길이 1을 점수로 바꿔주면 됨 햇갈리니까 표를 그리자!!","link":"/2017/09/30/%EA%B0%80%EC%9E%A5%ED%81%B0%EC%A6%9D%EA%B0%80%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4/"},{"title":"11722:가장 긴 감소하는 부분 수열","text":"https://www.acmicpc.net/problem/11722 풀이 가장 긴 증가하는 부분 수열과 동일 다른 점 증가하는 수열이 아닌 감소하는 수열검색할 때의 조건이 자신보다 높은값만 찾으면 됨 a[j] &gt; a[i]","link":"/2017/10/02/%EA%B0%80%EC%9E%A5%EA%B8%B4%EA%B0%90%EC%86%8C%ED%95%98%EB%8A%94%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4/"},{"title":"1430:나머지","text":"https://www.acmicpc.net/problem/1430 풀이 그냥 풀면 됨 이 문제는 풀이가 의미 있는 것이 아니라,문제 자체가 의미 있음.문제 자체가 알고리즘 풀 때 쓰임. 다이나믹 문제 풀다가int , long long 범위를 넘기 때문에 정답을 1%100007 이렇게 구하는 문제가 있음.이것은,전체 정답을 구하고 나머지 출력하는것이 아님.중간에 정수 범위를 넘어가기 때문에중간 중간 나머지 연산 처리 해야함.","link":"/2017/10/03/%EB%82%98%EB%A8%B8%EC%A7%80/"},{"title":"2609:최대공약수와 최소공배수","text":"https://www.acmicpc.net/problem/2609 풀이 유클리드 호제법 이용 r = a%b gcd(a , b) == gcd (b, r) r==0 이면이때 b가 gcd ​","link":"/2017/10/04/%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80%20%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"},{"title":"1934:최소공배수","text":"https://www.acmicpc.net/problem/1934 풀이 최대공약수를 구한다 최소 공배수 = 두 수의 곱 / 최대공약수","link":"/2017/10/05/%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"},{"title":"9613:GCD합","text":"https://www.acmicpc.net/problem/9613 풀이 GCD 구하는 함수를 만든다 모든 쌍을 반복문 통해서 확인 더해서 출력","link":"/2017/10/06/GCD%ED%95%A9/"},{"title":"11005:진법변환2","text":"https://www.acmicpc.net/problem/11005 풀이 몇 번 나누는지 count count 만큼 배열 생성 생성한 배열에 n%b를 차례대로 저장 n 은 n/b를 새로 저장 n이 0보다 클때까지 3번4번을 반복 실행 값들을 저장한 배열의 값을 index 끝부터 0까지 차례대로 출력 그런데, 해당 index의 값이 10보다 큰경우는 char(값+55) 로 출력 123456789101112StringBuilder ans = new StringBuilder(); while (n &gt; 0) { int r = n % b; if (r &lt; 10) { ans.append((char)(r + '0')); } else { ans.append((char)(r - 10 + 'A')); } n /= b; } System.out.println(ans.reverse()); }","link":"/2017/10/08/%EC%A7%84%EB%B2%95%EB%B3%80%ED%99%982/"},{"title":"2745:진법변환","text":"https://www.acmicpc.net/problem/1912 틀린 풀이 수학에서 진법 변확 하는 방식으로 풀면 됨 수는 string 으로 , 진법은 int 로 입력 받음(string으로 받아 각 자리에 접근하고, 자릿수를 쉽게 파악하기 위해) 각 자리 수에 접근하여 int로 입력받은 수의 자릿수 제곱을 곱하여 더함 맞는 풀이","link":"/2017/10/08/%EC%A7%84%EB%B2%95%EB%B3%80%ED%99%98/"},{"title":"2089:이진수","text":"https://www.acmicpc.net/problem/2089 풀이 일반적인 진법 변환이랑 같음 -2로 계속 나누어감 양수냐 음수냐가 중요","link":"/2017/10/11/%EC%9D%B4%EC%A7%84%EC%88%98/"},{"title":"11576:base conversion","text":"https://www.acmicpc.net/problem/11576 틀린 풀이 a 진법 -&gt; 10진법 -&gt; b진법 다음과 같이 풀면 틀렸다고 나옴. 맞는 풀이","link":"/2017/10/12/baseconversion/"},{"title":"11054:가장 긴 바이토닉 부분 수열","text":"https://www.acmicpc.net/problem/11054 풀이 가장 긴 증가하는 부분 수열 문제와 가장 긴 감소하는 부분 수열 문제를 더한 문제 가장 긴 증가하는 부분 수열을 구한다 가장 긴 감소하는 부분 수열을 구한다 d1[i] + d2[i] -1 의 최대값을 구한다 여기서 1을 빼는 이유 =&gt; 증가하다가 감소할 경우에 1이 두번 더해지기 때문에","link":"/2017/10/16/%EA%B0%80%EC%9E%A5%EA%B8%B4%EB%B0%94%EC%9D%B4%ED%86%A0%EB%8B%89%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4/"},{"title":"1912:연속합","text":"https://www.acmicpc.net/problem/1912 풀이 d[n]a[n]을 마지막으로 하는 연속하는 수들의 합 중 가장 큰 수 예를들어,10 -4 3 1 5 6 -35 12 21 -1 d[4] 5 5 + 1 5 + 1 + 3 5 + 1 + 3 -1 5 + 1 + 3 -1 -4 5 + 1 + 3 -1 -4 + 10 중 가장 큰 값 여기서 dp 문제라고 파악해야함 왜냐하면, d[3] 은 1 1 + 3 1 + 3 - 4 1 + 3 - 4 + 10 이기 때문이다. d[3]이 d[4] 구할때 쓰임 따라서d[4] = max ( a[4] , a[4]+d[3] ) 즉,d[n] = max ( a[n], a[n]+d[n-1] )","link":"/2017/10/17/%EC%97%B0%EC%86%8D%ED%95%A9/"},{"title":"2579:계단오르기","text":"https://www.acmicpc.net/problem/2579 풀이 d[i] a[i]를 밟았을 경우, 0~i 번째까지 최대 점수 d[i] max( a[i]+a[i-1]+d[i-3] , a[i]+d[i-2] ) example : 10 20 15 25 10 20 20 X 15 O 25 O : a[i]+a[i-1]+d[i-3] 15 X 25 O : a[i]+d[i-2] 근데, 여기서 사소한 문제 ! n을 입력받고, 배열을 생성할 때0n-1 인덱스로 할 것이냐,1n 인덱스로 할 것이냐에 따라 문제가 생김 0~n-1 인덱스로 다음과 같이 하면 틀렸음. 왜냐하면, d[2]를 구하지 않았기 때문. 6. 따라서 다음과 같이 d[2]를 구해야함 7. 1~n 인덱스로 범위 잡으면, 상관 없음","link":"/2017/10/20/%EA%B3%84%EB%8B%A8%EC%98%A4%EB%A5%B4%EA%B8%B0/"},{"title":"1699:제곱수의 합","text":"https://www.acmicpc.net/problem/1699 틀린 풀이 d[i] = i의 제곱수의 항의 최소 개수 n과 가장 가까운 제곱수를 찾음 d[n-(n과 가장 가까운수의 제곱수)] + 1 +1을 하는 이유 제곱수 자체도 하나 이기 때문에 예를 들어 d[7] = d[ 7 - 2^2 ] + 1 = d[3] + 1 이라고 생각했다 하지만, 위의 예시에서, d[3]이 가장 작은 값이라는 보장이 없다 즉, 가장 가까운 제곱수를 찾는 것이 틀림 맞는 풀이 예를 들어 , d[25] 를 구하려고 할때, d[25-1^2] + 1 d[25-2^2] + 1 d[25-3^2] + 1 d[25-4^2] + 1 min 값이 답","link":"/2017/10/20/%EC%A0%9C%EA%B3%B1%EC%88%98%EC%9D%98%ED%95%A9/"},{"title":"2133:타일채우기","text":"https://www.acmicpc.net/problem/2133 풀이 d[i] 3 * i 타일을 채우는 방법의 수 가장 마지막에 올 수 있는 경우를 찾아야 한다. 1d[i] = 3 * d[i-2] 1d[i] = 2 * d[i-4] 1d[i] = 2 * d[i-6] d[i] 13*d[i-2] + 2*d[i-4] + 2*d[i-6] + ... + 2*d[0] 어차피, 가로 길이가 홀수이면 타일로 채울 수 X 코드 ​","link":"/2017/11/01/%ED%83%80%EC%9D%BC%EC%B1%84%EC%9A%B0%EA%B8%B0/"},{"title":"2011:암호코드","text":"https://www.acmicpc.net/problem/2011 풀이 d[i] 1i번째 까지 해석했을 때, 경우의 수 i번째 문자 한 자리로 해석되는 경우 : 1 ~ 9 두 자리로 해석되는 경우 : 10 ~ 26","link":"/2017/11/02/%EC%95%94%ED%98%B8%EC%BD%94%EB%93%9C/"},{"title":"파도반 수열","text":"https://www.acmicpc.net/problem/9461 틀린 풀이 p[i]를 나열해서 규칙을 찾음 p[i] = p[i-1] + p[i-5] 결과 : 틀렸다고 나옴","link":"/2017/11/03/%ED%8C%8C%EB%8F%84%EB%B0%98%EC%88%98%EC%97%B4/"},{"title":"2225:합분해","text":"https://www.acmicpc.net/problem/2225 틀린 풀이 d[n][k] 1k개 더해서 합이 n이 되는 경우의 수 d[n][k] 1d[0][k-1] + d[1][k-1] + d[2][k-1] + ... + d[n][k-1] 맞는 풀이 ​","link":"/2017/11/04/%ED%95%A9%EB%B6%84%ED%95%B4/"},{"title":"11724:연결요소의 개수","text":"https://www.acmicpc.net/problem/11724 연결요소 다음은 1개의 그래프가 2개의 연결 요소(Connected Component)로 이루어져 있는거임 DFS or BFS 로 풀 수 있음 DFS나 BFS의 목적이 모든 정점을 한번 씩 방문하는 것이기 때문에 DFS 풀이 ​","link":"/2017/11/06/%EC%97%B0%EA%B2%B0%EC%9A%94%EC%86%8C%EC%9D%98%EA%B0%9C%EC%88%98/"},{"title":"1707:이분그래프","text":"https://www.acmicpc.net/problem/1707 개념 그래프를 다음과 같이 A와 B로 나눌 수 있으면 이분그래프 1모든 간선의 한 끝은 A에, 다른 한 끝은 B에 있음. DFS or BFS 로 풀 수 있음. check 배열이 포인트!! 123check[i] == 0 : 아직 방문 Xcheck[i] == 1 : 방문 O, 빨간색check[i] == 2 : 방문 O, 파란색 ​","link":"/2017/11/07/%EC%9D%B4%EB%B6%84%EA%B7%B8%EB%9E%98%ED%94%84/"},{"title":"10451:순열사이클","text":"https://www.acmicpc.net/problem/10451 풀이 이분그래프 풀이와 같음 check배열, 입력 배열 생성 그래프 그림 dfs에 check배열과 입력 배열 넘김 넘길때마다 ans++ (순열 사이클 찾는 방법) dfs에서 재귀로 돌림","link":"/2017/11/08/%EC%88%9C%EC%97%B4%EC%82%AC%EC%9D%B4%ED%81%B4/"},{"title":"term프로젝트","text":"https://www.acmicpc.net/problem/9466 의문 cycle 내의 개수를 셀 때 static 변수를 사용 왜 파라미터로 넘기면 계속해서 0으로 초기화 될까? 경우의 수 처음 방문 두 번째 방문, 같은 cycle 같은 cycle 내에서 이미 두 번을 방문 다른 cycle 내에서 이미 방문","link":"/2017/11/10/term%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"title":"단지번호 붙이기","text":"https://www.acmicpc.net/problem/2667 풀이 연결요수 문제와 비슷 그래프 문제이지만, 인접리스트 or 인접행렬 만들 필요 X 왜냐하면, 어떤 칸과 연결되어 있는 칸 : 상하좌우 네 칸 중에 있기때문에. 따러서, 모든 칸 마다 네 칸을 검사하면 됨 d[i][j] 12i,j 를 방문 X =&gt; d[i][j] = 0i,j 를 방문 O =&gt; d[i][j] = 단지 번호 방문을 아직 안했고, 아파트가 있으면 1dfs탐색으로 상하좌우 조사 ​","link":"/2017/11/11/%EB%8B%A8%EC%A7%80%EB%B2%88%ED%98%B8%EB%B6%99%EC%9D%B4%EA%B8%B0/"},{"title":"섬의 개수","text":"https://www.acmicpc.net/problem/4963 풀이 아파트 단지 문제랑 유사 그래프 문제이지만, 인접리스트 or 인접행렬 만들 필요 X 왜냐하면, 어떤 칸과 연결되어 있는 칸 : 상하좌우 네 칸 중에 있기때문에. 따러서, 모든 칸 마다 네 칸을 검사하면 됨 d[i][j] 12i,j 를 방문 X =&gt; d[i][j] = 0i,j 를 방문 O =&gt; d[i][j] = 1 방문을 아직 안했고, 아파트가 있으면 1dfs탐색으로 상하좌우 조사 ​","link":"/2017/11/13/%EC%84%AC%EC%9D%98%EA%B0%9C%EC%88%98/"},{"title":"ROT13","text":"https://www.acmicpc.net/problem/11655 풀이 쉬운 문제 핵심 : 중간을 기준으로 +13, -13 a-n or A-N +13 m-z or M-Z -13 ​","link":"/2017/11/14/ROT13/"},{"title":"미로탐색","text":"https://www.acmicpc.net/problem/2178 풀이 빠른길은 BFS로 품 모든 가중치가 1이면 최단 거리 알고리즘은 BFS로 품 BFS는 단계별로 진행됨. 즉 거리별로 진행됨. 거리가 1인곳가고, 거리가 2인곳 가고~ 입력값대로 미로 그림 1,1 좌표를 큐에 넣음 큐에서 pop 점 이동 이동한 점 큐에 넣음 거리 계산 3번으로 ​","link":"/2017/11/15/%EB%AF%B8%EB%A1%9C%ED%83%90%EC%83%89/"},{"title":"방번호","text":"https://www.acmicpc.net/problem/1475 풀이 수학문제 0~9를 가지고 있는 배열 생성 입력한 숫자가 없을때마다 배열에 다시 0~9 까지 추가해줌 추가하는 개수가 답 but, 틀렸다고 나옴. 효율적인 코드일까? 왜 틀렸다고 나올까? ​","link":"/2017/11/16/%EB%B0%A9%EB%B2%88%ED%98%B8/"},{"title":"토마토","text":"https://www.acmicpc.net/problem/7576 풀이 BFS문제 미로탐색 문제와 동일 다른 점 : 출발점과 종료점이 정해진것이 X 토마토 상태 입력할 때 1이면 큐에 넣기 “다시 풀어보기” ​","link":"/2017/11/17/%ED%86%A0%EB%A7%88%ED%86%A0/"},{"title":"팩토리얼 0의 개수","text":"https://www.acmicpc.net/problem/1676 풀이 하나하나 풀어보면서 규칙을 파악 10! 은 0이 2개 &lt;- 소인수분해를 해보면 알 수 있음 2와 5의 개수가 몇개인지 세야함 코드는 간단. 아이디어가 핵심","link":"/2017/11/20/%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC0%EC%9D%98%EA%B0%9C%EC%88%98/"},{"title":"다리만들기","text":"https://www.acmicpc.net/problem/1676 풀이 단지번호 붙이기 + 토마토 문제 먼저 ‘단지 번호 붙이기’ 문제처럼 그룹별로 묶는다 각각의 그룹에 대해 다른 섬까지 거리를 구한다 거리의 최소값이 답 매우 매우 어렵다. 그래프 감이 잘 안잡힌다","link":"/2017/11/21/%EB%8B%A4%EB%A6%AC%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"접미사배열","text":"https://www.acmicpc.net/problem/11656 풀이 쉬운 문제 문자열의 index에 순차적 접근해서 substring sorting ​","link":"/2017/11/22/%EC%A0%91%EB%AF%B8%EC%82%AC%EB%B0%B0%EC%97%B4/"},{"title":"문자열 분석","text":"풀이 매우 쉬운 문제 문제에서 요구하는 대로 풀기만 하면 됨 문자, 숫자, 공백 문자형으로 구분","link":"/2017/11/25/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EB%B6%84%EC%84%9D/"},{"title":"조합 0의 개수","text":"https://www.acmicpc.net/problem/1676 풀이 팩토링러 문제와 비슷. 쉬운 문제. 팩토리얼 : 2의 개수가 5의 개수보다 많음 =&gt; 5의 개수만 셈 조합 : 2와 5의 개수를 모두 셈 ​","link":"/2017/11/26/%EC%A1%B0%ED%95%A90%EC%9D%98%EA%B0%9C%EC%88%98/"},{"title":"트리순회","text":"https://www.acmicpc.net/problem/1991 풀이 존위 순회 / 중위 순회 / 후위 순회 트리 그리기 [0] : 왼쪽 자식 [1] : 오른쪽 자식 순회 : 재귀로","link":"/2017/11/28/%ED%8A%B8%EB%A6%AC%EC%88%9C%ED%9A%8C/"},{"title":"트리의 부모 찾기","text":"https://www.acmicpc.net/problem/11725 틀린 풀이 int a[][]= new int[n][3] 왼쪽 자식, 오른쪽 자식, 부모를 저장 할 배열 생성 전위 순회 트리에서 입력한 line의 첫 번째 수가 있는지 탐색 찾았으면 왼쪽 자식이, 오른쪽 자식이 비었는지 확인 못 찾았으면 입력한 line의 두번째 수가 왼쪽 자식 비었는지, 오른쪽 자식 비었는지 확인 이게 과연 효과적인 방법일까 ? 옳은 풀이 “도시가 n개 + 도로가 n-1개 + 두 도시 사이에 경로가 항상 존재 + 방향 X ==&gt; 트리임” 트리의 탐색 : BFS / DFS 로 가능 트리는 사이클이 없는 그래프 따라서, 두 정점 사이 경로는 1개 now -&gt; next로 가려면 간선이 있어야함 next를 아직 방문하지 않았어야함 =&gt; check[next] == false 알게 되는 것 parent[next] = now depth[next] = depth[now] +1","link":"/2017/11/29/%ED%8A%B8%EB%A6%AC%EC%9D%98%20%EB%B6%80%EB%AA%A8%20%EC%B0%BE%EA%B8%B0/"},{"title":"국영수","text":"https://www.acmicpc.net/problem/10825 풀이 매우 쉬운 문제 Person class 생성 입력 값에 따라 Person에 저장 정렬","link":"/2017/11/30/%EA%B5%AD%EC%98%81%EC%88%98/"},{"title":"트리의 지름","text":"https://www.acmicpc.net/problem/1167 풀이 bfs로 탐색 루트에서 모든 정점까리 거리 구함 가장 먼 거리 정점 : A A는 이제 루트 모든 정점까지 거리 구함 가장 먼 거리가 지름","link":"/2017/12/01/%ED%8A%B8%EB%A6%AC%EC%9D%98%20%EC%A7%80%EB%A6%84/"},{"title":"트리의 지름02","text":"https://www.acmicpc.net/problem/1967 풀이 bj_1167 과 동일한 문제 1을 루트로 지정하고 가장 먼 위치에 있는 정점 찾고 그 정점에서 모든 정점들 사이의 거리 찾아서 가장 큰게 답","link":"/2017/12/02/%ED%8A%B8%EB%A6%AC%EC%9D%98%20%EC%A7%80%EB%A6%8402/"},{"title":"내리막길","text":"https://www.acmicpc.net/problem/1520 풀이 상하좌우 조사 현재 위치를 상하좌우 조사한 위치에서 올 수 있는지 확인 재귀 계속 d 배열이 채워지질 않는다..","link":"/2017/12/04/%EB%82%B4%EB%A6%AC%EB%A7%89%EA%B8%B8/"},{"title":"네수","text":"https://www.acmicpc.net/problem/10824 풀이 매우 쉬운 문제 string 으로 붙이면 됨 StringTokenizer hasMoreTokens 출력할 때 int로 하면 런타임에러 그래서 long long 으로 했음 결과","link":"/2017/12/05/%EB%84%A4%EC%88%98/"},{"title":"RGB 거리","text":"https://www.acmicpc.net/problem/1149 풀이 dp d[i][color] i 번째 집을 color 로 칠했을 때, 1 번째~ i 번째 까지 든 최소 비용 d[i+1][0] = i번째 집을 1번으로 칠했을 때 든 최소 비용과, 2번으로 칠했을 때 든 최소비용 중 작은 값 d[i+1][1] = i번째 집을 0번으로 칠했을 때 든 최소 비용과, 2번으로 칠했을 때 든 최소비용 중 작은 값 d[i+1][2] = i번째 집을 0번으로 칠했을 때 든 최소 비용과, 1번으로 칠했을 때 든 최소비용 중 작은 값","link":"/2017/12/06/RGB%EA%B1%B0%EB%A6%AC/"},{"title":"2차원 배열의 합","text":"https://www.acmicpc.net/problem/2167 풀이 dp 그림으로 쉽게 풀림 점화식 ​ s[i][j] = a[i][j] + s[i-1][j] +s[i][j-1] - s[i-1][j-1] ( i,j,x,y 의 구간합 ) s[x][y] -s[ i-1][y] - s[x][j-1] + s[i-1][j-1 ]","link":"/2017/12/07/2%EC%B0%A8%EC%9B%90%20%EB%B0%B0%EC%97%B4%EC%9D%98%20%ED%95%A9/"},{"title":"Generations of Tribbles","text":"https://www.acmicpc.net/problem/9507 풀이 dp 쉬운 문제 d[i] d[i-2] + d[i-3] + d[i-4] + d[i-1]","link":"/2017/12/09/Generations%20of%20Tribbles/"},{"title":"이동하기","text":"https://www.acmicpc.net/problem/11048 풀이 dp 잘못된 접근 : 현재 위치에서, 갈 수 있는 곳만 생각했음 올바른 접근 : 현재 위치를, 올 수 있는 곳을 생각해야함 12341 23 44를 올 수 있는 곳은 1, 2, 3 d[i][j] : i,j 위치에서의 사탕 개수 최대값 Max( ​ [i-1][j-1]에서의 사탕개수 최대값, ​ [i][j-1]에서의 사탕개수 최대값, ​ [i-1][j]에서의 사탕개수 최대값) + i,j에서의 사탕개수","link":"/2017/12/08/%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0/"},{"title":"상자 넣기","text":"https://www.acmicpc.net/problem/1965 풀이 dp 가장 긴 증가하는 수열과 같은 문제 d[i] : i 를 마지막으로 하는 가장 긴 증가하는 수열 d[i] 0 번째 ~ i-1 번째까지 조사. ​ k번째에서 i번째 수보다 작고, 더 긴 증가하는 부분수열이 된다면 ​ d[i] = d[k] + 1","link":"/2017/12/11/%EC%83%81%EC%9E%90%EB%84%A3%EA%B8%B0/"},{"title":"에이한수","text":"https://www.acmicpc.net/problem/1066 풀이 단순 수학 문제 문제에 주어진 대로 따라가면 쉬운 문제 계속 틀렸다고 나옴 다시 풀어봐야 함 ​","link":"/2017/12/13/%EC%97%90%EC%9D%B4%ED%95%9C%EC%88%98/"},{"title":"동전1","text":"https://www.acmicpc.net/problem/2293 풀이 dp 정말 어렵다 어떻게 풀어야할지 모르겠다 ​","link":"/2017/12/14/%EB%8F%99%EC%A0%84%201/"},{"title":"동물원","text":"https://www.acmicpc.net/problem/1309 틀린 풀이 동물 수에 따라 식을 세우려고 함 d[1] : 동물 한 마리 들어갔을 때 경우의 수 ​ d[2] : 동물 두 마리 들어갔을 때 경우의 수 ​ … 이런식으로 하면 d[n-1] 과 d[n] 을 연결시키기가 어려움 옳은 풀이 n-1 번째 줄 까지 우리에 맞게 들어갔다고 보고 n 번째 줄에 어떻게 올 수 있는지 고려해야함 d[n][0] : n 번째 줄에 왼쪽만 사자가 들어감 n-1번째 줄에 오른쪽만 들어가거나, 아예 안들어감 d[n][1] : n 번째 줄에 오른쪽만 사자가 들어감 n-1번째 줄에 왼쪽만 들어가거나, 아예 안들어감 d[n][2] : n 번째 줄에 안들어감 n-1번째 줄에 오른쪽만 들어가거나, 왼쪽만 들어가거나, 아예 안들어감","link":"/2017/12/15/%EB%8F%99%EB%AC%BC%EC%9B%90/"},{"title":"나누기","text":"https://www.acmicpc.net/problem/1075 틀린 풀이 n의 최고자리수를 제외하고 다 0으로 만들기 ex) n이 2031이면 =&gt; 2000으로 f로 나누어 떨어지는지 확인. 나누어 안 떨어지면 +1 끝 두자리 출력 계속 틀렸다고 뜸.. 옳은 풀이 굳이 Math 안써도 됨 100으로 나눈 몫에 100을 곱하면 됨","link":"/2017/12/16/%EB%82%98%EB%88%84%EA%B8%B0/"},{"title":"줄세우기","text":"https://www.acmicpc.net/problem/2631 풀이 LIS를 먼저 구한다 (== 가장 긴 증가하는 부분 수열을 구한다) 정답 : 수열의 길이 - LIS 이유 : LIS를 기준으로 먼저 배치한뒤, 나머지 아이들을 옳기면 되므로","link":"/2017/12/18/%EC%A4%84%EC%84%B8%EC%9A%B0%EA%B8%B0/"},{"title":"유기농배추","text":"https://www.acmicpc.net/problem/1012 풀이dfs 문제..그래프 개념 다시 복습 필요dp 문제만 풀다가 풀려니 어려움","link":"/2017/12/19/%EC%9C%A0%EA%B8%B0%EB%86%8D%EB%B0%B0%EC%B6%94/"},{"title":"보물","text":"https://www.acmicpc.net/problem/1026 풀이 A배열 내림차순 정렬 B배열 오름차순 정렬 각 배열의 i 번째끼리 곱해서 더함 결과","link":"/2017/12/20/%EB%B3%B4%EB%AC%BC/"},{"title":"인접한 비트의 개수","text":"https://www.acmicpc.net/problem/2968 풀이 어렵다 d[i][j][m] 길이가 i인 수열, ​ 인접 비트 개수가 j, ​ 마지막 비트가 m인 ( m : 0 or 1 ) ​ 수열의 경우의 수 마지막 비트가 0 이전 비트가 0 : 경우의 수에 영향 X 이전 비트가 1 : 경우의 수에 영향 X 마지막 비트가 1 이전 비트가 0 : 경우의 수에 영향 X 이전 비트가 1 : 경우의 수에 영향 O","link":"/2017/12/21/%EC%9D%B8%EC%A0%91%ED%95%9C%20%EB%B9%84%ED%8A%B8%EC%9D%98%20%EA%B0%9C%EC%88%98/"},{"title":"수열정렬","text":"https://www.acmicpc.net/problem/1015 풀이 어려웠음 i 번째 값과 j 번쨰 (0번째 ~ i-1번째) 값을 비교하여 큰 값의 index (i or j) 에 해당하는 위치의 배열 값을 ++ 쉽게 생각해서, a배열의 값들이 동일선상에 위치하는데, 비내림차순으로 정렬하기 위해 몇 번씩 뒤로 이동시켜야 하는지 카운트 ex) B[p[0]] = A[0] = 7 &lt;- ​ B[p[1]] = A[1] = 4 &lt;- ​ B[p[2]] = A[2] = 2 &lt;- ​ B[p[3]] = A[3] = 3 &lt;- 기준 ​ B[p[4]] = A[4] = 9 ​ B[p[5]] = A[5] = 10 ​ ​ 3을 기준으로 7, 4, 2 와 비교 3과 7 =&gt; 7이 더 크다 =&gt; 7은 한 번뒤로 가야함 =&gt; B의 index 값 증가 3과 4 =&gt; 4가 더 큼 =&gt; 4는 한 번뒤로 가야함 =&gt; B의 index 값 증가 3과 2 =&gt; 3이 더 큼 =&gt; 3은 한 번뒤로 가야함 =&gt; B의 index 값 증가","link":"/2017/12/22/%EC%88%98%EC%97%B4%EC%A0%95%EB%A0%AC/"},{"title":"유전자","text":"https://www.acmicpc.net/problem/2306 풀이 풀어본 DP 문제 중 제일 어려움 d[i, j] a[i..j] 의 부분 KOI 유전자 들 중 가장 긴 것의 길이 ​ d[i, j] = 2 a[i..j] == “at” a[i..j] == “gc” d[i, j] = d[i+1, j-1] + 2 a[i]==”a” , a[j]=”t” a[i]==”g” , a[j]=”c” d[i, j] = d[i, k] + d[k+1, j] - a[i...k] 의 부분 KOI 유전자 들 중 가장 긴 것의 길이 =&gt; d[i, k] - a[k+1...j] 의 부분 KOI 유전자 들 중 가장 긴 것의 길이 =&gt; d[i, k]","link":"/2017/12/23/%EC%9C%A0%EC%A0%84%EC%9E%90/"},{"title":"선물전달","text":"https://www.acmicpc.net/problem/1947 풀이 완전 순열의 개념을 알아야함 완전 순열 : n명의 사람이 자신의 모자를 벗어두었다가, ​ 다시 쓰는데 모든 사람이 자기의 것이 아닌 모자를 쓰는 경우의 수 d[i] i 명이 선물을 나누는 경우의 수 a1 a2 a4 a4 …. aj … ai aj가 i 선물을, ai가 j 선물을 가지는 경우 나머지 i-2 명이 선물을 나눠 가지면 된다 =&gt; d[i-2] ​ 그리고 aj는 ai를 제외한 명 수중 한 명 이므로 i-1 aj가 i 선물을 가지고, ai가 j 선물으 가지지 않는 경우 aj를 제외한 나머지 i-1명이 선물을 나눠 가지면 된다. =&gt; d[i-1] ​ 그리고 aj는 ai를 제외한 명 수중 한 명 이므로 i-1 그런데, 계속해서 런타임 에러가 발생했음 문제 d[2]를 초기화할 때, 반복문 안에서 조건을 걸어서 하지 않고, ​ 반복문 밖에서 초기화하면 런타임 에러가 뜸. 해결 반복문 안에서 초기화","link":"/2017/12/25/%EC%84%A0%EB%AC%BC%EC%A0%84%EB%8B%AC/"},{"title":"직사각형에서 탈출","text":"https://www.acmicpc.net/problem/1085 풀이 쉬운 수학 문제 (x, y)에서 상 하 좌 우로 얼만큼 떨어져있는지 계산 최소값 출력​","link":"/2017/12/26/%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95%EC%97%90%EC%84%9C%20%ED%83%88%EC%B6%9C/"},{"title":"만취한 상범","text":"https://www.acmicpc.net/problem/6359 풀이 점화식을 세워서 DP로 풀지 않음 i번째 라운드에 i번째 방이 열려있는지 체크 열려있으면 닫고, 닫혀 있으면 열음 점화식을 세워서 어떻게 풀까?? ​","link":"/2017/12/27/%EB%A7%8C%EC%B7%A8%ED%95%9C%20%EC%83%81%EB%B2%94/"},{"title":"도미노","text":"https://www.acmicpc.net/problem/1073 풀이 수학문제 오일러 회로 공부 필요 어렵다 ​","link":"/2017/12/28/%EB%8F%84%EB%AF%B8%EB%85%B8/"},{"title":"동전","text":"https://www.acmicpc.net/problem/9084 풀이 ex) 1원, 5원, 10원이 있다. 만들어야하는 동전은 100원 1원을 이용해서 d[1] : 1원을 만드는 경우의 수 =&gt; 1원, d[0] =&gt; 1 ​ d[2] : 2원을 만드는 경우의 수 =&gt; 1원, d[1] =&gt; 1 ​ d[3] : 3원을 만드는 경우의 수 =&gt; 1원, d[2] =&gt; 1 ​ … ​ d[100] : 100원을 만드는 경우의 수 =&gt; 1원, d[99] =&gt; 1 5원을 이용해서 d[5] : 5원을 만드는 경우의 수 =&gt; (1원, d[4]) + (5원, d[0]) =&gt; 1 + 1 =&gt; 2 ​ d[6] : 6원을 만드는 경우의 수 =&gt; 1원, d[5] =&gt; 1 ​ d[7] : 7원을 만드는 경우의 수 =&gt; 5원, d[2] =&gt; 1 ​ … ​ d[9] : 9원을 만드는 경우의 수 =&gt; (1원,d[8]) + (5원, d[5]) ​ … ​ d[100] 10원을 이용해서 ​ d[10] : 10원을 만드는 경우의 수 =&gt; (1원,d[9]) + (5원, d[5]) + (10원, d[0]) ​ … ​ d[100] 위와 같이 전 단계에 나온 결과값을 재사용할 수 있다. 때문에 DP 문제이다. ​ ​​","link":"/2017/12/29/%EB%8F%99%EC%A0%84/"},{"title":"팰린드롬 분할","text":"https://www.acmicpc.net/problem/1509 풀이 1~roomSize-1 까지 검사 펠린드 룸이 만들어 지는 경우가 있으면 그 뒤 펠린드 룸이 만들어지는 지점에 result[i-1] +1 이미 넣어진 값이 있으면 최소값을 비교해서 대입 ​","link":"/2017/12/30/%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC%20%EB%B6%84%ED%95%A0/"},{"title":"설탕배달","text":"https://www.acmicpc.net/problem/2839 풀이 d[i] ikg을 담을 수 있는 최소 봉지 수 ex) 6kg 0 + 6 =&gt; 6을 3kg짜리 봉지 2개로 담을 수 있음 =&gt; d[6] = 2 ​ 1 + 5 =&gt; d[1]== -1 =&gt; X ​ 2 + 4 =&gt; d[2]== -1 =&gt; X ​ 3 + 3 =&gt; d[6] = d[3] + d[3] = 1 ex) 10kg 0 + 10 =&gt; 10을 5kg짜리 봉지 2개로 담을 수 있음 =&gt; d[10] = 2 ​ 1 + 9 =&gt; d[1]== -1 =&gt; X ​ 2 + 8 =&gt; d[2]== -1 =&gt; X ​ 3 + 7 =&gt; d[7]== -1 =&gt; X ​ 4 + 6 =&gt; d[4]== -1 =&gt; X ​ 5 + 5 =&gt; d[5] == 1 =&gt; d[10] = d[5] + d[5] = 2 위와 같이, 앞 단계에서 사용된 값이 재사용된다. 따라서 DP 더 간결하게 어떻게 짤 수 있을까?","link":"/2018/01/01/%EC%84%A4%ED%83%95%EB%B0%B0%EB%8B%AC/"},{"title":"좋은단어","text":"https://www.acmicpc.net/problem/3986 풀이 stack문제 스텍이 비었으면 push 스텍에 문자가 있으면, top문자 비교 같으면 pop 다르면 push 마지막에 stack이 비었으면 좋은 단어","link":"/2018/01/03/%EC%A2%8B%EC%9D%80%EB%8B%A8%EC%96%B4/"},{"title":"수들의 합","text":"https://www.acmicpc.net/problem/1789 풀이 런타임 에러가 계속 났음 원인 자료형. 문제의 입력으로 자연수 S(1≤S≤4,294,967,295)가 주어진다. int의 범위를 넘기 때문에 런타임 에러가 계속 났음 해결 long형으로 입력 받음 쉬운 문제라도, 문제의 조건을 잘 확인해야함","link":"/2018/01/04/%20%EC%88%98%EB%93%A4%EC%9D%98%ED%95%A9/"},{"title":"파일합치기","text":"https://www.acmicpc.net/problem/11066 풀이 dp[i][j] ​ 수열에서 i번째~j번째 수까지 합치는데 필요한 최소 비용 ​ min(dp[i][k] + dp[k+1][j]) + (i~j 수열의 합) (i &lt;= k &lt; j) 일 때 i _ _ _ k k+1 _ _ _ j","link":"/2018/01/05/%ED%8C%8C%EC%9D%BC%ED%95%A9%EC%B9%98%EA%B8%B0/"},{"title":"개근상","text":"https://www.acmicpc.net/problem/1563 풀이 어렵다 D[i][j][k] 1i일, 지각 j번, 연속 결석 k번 오늘 출석 전날에 출석, 지각, 결석 중에 하나 D[i][j][0] += D[i-1][j][k] (0 ≤ k ≤ 2) 오늘 지각 j 가 1 D[i][1][0] += d[i-1][0][k] 오늘 결석 k &lt; 2 D[i][j][k+1] += D[i-1][j][k] ​","link":"/2018/01/06/%EA%B0%9C%EA%B7%BC%EC%83%81/"},{"title":"조짜기","text":"https://www.acmicpc.net/problem/2229 풀이 d[i] max(j&lt;=i)(dp[j-1]+max(a[j…i])-min(a[j…i])) 뒤에 min을 왜 빼야하는 걸까?","link":"/2018/01/08/%EC%A1%B0%EC%A7%9C%EA%B8%B0/"},{"title":"컵홀더","text":"https://www.acmicpc.net/problem/2810 틀린 풀이 가능한 컵홀더의 개수를 count S L 사이에, LL LL 사이에 틀린 결과 맞는 풀이 커플의 수 만큼 홀더를 사용하지 못하는 사람이 생김 하지만 양 끝에 홀더가 있기 때문에, 커플이 있으면 커플수 - 1 만큼 홀더를 사용하지 못함 맞는 결과","link":"/2018/01/09/%EC%BB%B5%ED%99%80%EB%8D%94/"},{"title":"TV크기","text":"https://www.acmicpc.net/problem/1297 풀이 대각선 = 루트 (가로의 제곱 + 세로의 제곱) 루트 : Math.sqrt (int) double : double to int","link":"/2018/01/10/TV%ED%81%AC%EA%B8%B0/"},{"title":"소음","text":"https://www.acmicpc.net/problem/2935 풀이 처음에 런타임에러 나옴 런타임 에러 이유 수를 단순 입력 후에 단순 출력했음 문제의 조건에 숫자는 최대 100자리 하지만, int 의 범위 : –2,147,483,648 ~ 2,147,483,647 long long 의 범위 : –9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 따라서 단순 입력을 하면 100자리를 모두 담을 수 없음 해결 문자로 입력받고 문자를 출력","link":"/2018/01/11/%EC%86%8C%EC%9D%8C/"},{"title":"택시기하학","text":"https://www.acmicpc.net/problem/3053 풀이 단순 수학 T1(x1,y1), T2(x2,y2) 사이의 거리 D(T1,T2) = |x1-x2| + |y1-y2|","link":"/2018/01/12/%ED%83%9D%EC%8B%9C%20%EA%B8%B0%ED%95%98%ED%95%99/"},{"title":"듣보잡","text":"https://www.acmicpc.net/problem/1764 풀이 퀵정렬로 사전순으로 정렬 m개 이분탐색 중복된 명단을 퀵정렬 후 출력","link":"/2018/01/13/%EB%93%A3%EB%B3%B4%EC%9E%A1/"},{"title":"2007년","text":"https://www.acmicpc.net/problem/1924 풀이 이전 월 까지의 일수 + 현재 월의 날짜 일주일로 나눔 ex) 3월 15일 1월(30) + 2월(28) + 3월(15) = 73 73 % 7 = 3 따라서, 수요일","link":"/2018/01/15/2007%EB%85%84/"},{"title":"줄어들지않아","text":"https://www.acmicpc.net/problem/2688 풀이 처음에 계속 틀렸다고 나옴 원인 : int로 변수를 설정했음 해결 : long으로 바꿈 d[i][j] i자리인 수가 j로 끝날때, 줄어들지 않는 수의 개수 ex d[3][4] : 세 자리인 수가 4로 끝날때, 줄어들지 않는 수의 개수 d[3][0] : _ _ 0 d[3][1] : _ _ 1 d[3][2] : _ _ 2 d[3][3] : _ _ 3 =&gt; d[2][3] + d[2][2] + d[2][1] + d[2][0] d[3][4] : _ _ 4","link":"/2018/01/16/%EC%A4%84%EC%96%B4%EB%93%A4%EC%A7%80%EC%95%8A%EC%95%84/"},{"title":"01타일","text":"https://www.acmicpc.net/problem/1904 틀린 풀이 계속 런타임 에러 dp가 아니라, 수학적으로 풀었음 팩토리얼로 풀었음 맞는 풀이 d[i] 길이가 i 일때, 만들 수 있는 수열의 개수 d[i-2] + d[i-1] 길이가 i인 수에는 길이가 i-1인 수에 00을 붙이거나 1을 붙여서 만들 수 있다. 하지만 00은 길이가 2 이기때문에, 붙일 수 없다. 따라서 i-2번째에 00을 붙이거나 i-1번째에 1을 붙인다 여기서 문제, i-2번쨰에 11을 붙여서 만들 수 있지 않나? 중복의 문제가 발생한다 따라서, i-2번째 수열에, 00을 맨 뒤에 붙이고 i-1번째 수열에, 1을 맨 앞에 붙인다","link":"/2018/01/17/01%ED%83%80%EC%9D%BC/"},{"title":"올림픽","text":"https://www.acmicpc.net/problem/8979 풀이 금메달, 은메달, 동메달 개수를 비교하여 정렬 등수 매기기에서 막혔음","link":"/2018/01/18/%EC%98%AC%EB%A6%BC%ED%94%BD/"},{"title":"벽장문의 이동","text":"https://www.acmicpc.net/problem/2666 틀린 풀이 어렵다 재귀 사용 문이 있는지 없는지 체크 문이 없으면 옮기기 문이 있으면 좌우 확인 -&gt; 다시 문이 있는지 없는지 체크","link":"/2018/01/19/%EB%B2%BD%EC%9E%A5%EB%AC%B8%EC%9D%98%20%EC%9D%B4%EB%8F%99/"},{"title":"슈퍼마리오","text":"https://www.acmicpc.net/problem/2851 풀이 처음에 틀렸다고 나옴 이유 : 반복문의 if-else 구문에서 else문에 걸렸을 때, 바로 출력하고 return 해결 : break 걸고, 반복문 밖에서 정답 출력 100과의 차이는 계속해서 감소하거나 같음 ex) 100과의 차이가 90 70 30 1 1 … 인 경우가 있을 수 있으니 현재 index에서의 차이가 전 index에서의 차이보다 커지면 stop","link":"/2018/01/20/%EC%8A%88%ED%8D%BC%EB%A7%88%EB%A6%AC%EC%98%A4/"},{"title":"타일","text":"https://www.acmicpc.net/problem/1720 중복을 고려하지 않고 d[i] d[i-2] * 2 + d[i-1] 중복을 고려하여 전체 타일 수 = A + 2B A : 중복되지 않는 수 B : 중복되는 수 중복을 제거한 타일 수 = A + B = (A + 2B + A) / 2 A 개수 구하기 i가 홀수인 경우 가운데 2*1을 두고, 남은 좌우 채움 s[i] = d[i/2] i가 짝수인 경우 s[i] = d[i/2-1] * 2 + d[i/2] 가운데, 1*2를 주고, 남은 좌우 채움 d[i/2-1] 가운데, 2*2를 주고, 남은 좌우 채움 d[i/2-1] 반반 나눠서 채움 d[i/2] 결과 런타임 에러가 뜸 해결 : 배열 31로 고정","link":"/2018/01/24/%ED%83%80%EC%9D%BC/"},{"title":"수이어쓰기1","text":"https://www.acmicpc.net/problem/1748 풀이 각 자리마다 쓰이는 개수를 구해서 합한다","link":"/2018/01/26/%EC%88%98%EC%9D%B4%EC%96%B4%EC%93%B0%EA%B8%B0/"},{"title":"책페이지","text":"https://www.acmicpc.net/problem/1019 틀린 풀이 각 페이지마다 접근해서 각 숫자가 몇개씩 있나 체크 ex) 1~12 페이지가 있으면 1, 2, 3, 4,,,,12 차례로 접근 cnt[0] ~ cnt[9] 짜리 배열 ++ 10페이지 : cnt[1]++, cnt[0]++ 이렇게 접근하면 시간 초과 규칙 필요","link":"/2018/02/02/%EC%B1%85%ED%8E%98%EC%9D%B4%EC%A7%80/"},{"title":"단어수학","text":"https://www.acmicpc.net/problem/1339 풀이 백트렉킹 문제 어렵다, 다시 풀어야함","link":"/2018/02/03/%EB%8B%A8%EC%96%B4%EC%88%98%ED%95%99/"},{"title":"민균이의 계략","text":"https://www.acmicpc.net/problem/11568 풀이 ‘’가장 긴 증가하는 부분수열’’ 문제와 동일 처음에 계속 틀렸음 이유 : j를 i-1 ~ 0 번째까지 비교해야하는데 1번째 까지만 비교했음","link":"/2018/02/15/%EB%AF%BC%EA%B7%A0%EC%9D%B4%EC%9D%98%20%EA%B3%84%EB%9E%B5/"},{"title":"축구","text":"https://www.acmicpc.net/problem/1344 풀이 d[i][j][k] i라운드에서, A팀이 j 포인트, B팀이 k포인트 얻었을 때, 18라운드까지 한 확률의 합 경우의 수 i 라운드드에서 A팀 : 1골, B팀 : 0골 A팀 : 0골, B팀 : 1골 A팀 : 1골, B팀 : 1골 A팀 : 0골, B팀 : 0골","link":"/2018/02/16/%EC%B6%95%EA%B5%AC/"},{"title":"라그랑주의 네 제곱수 정리","text":"https://www.acmicpc.net/problem/3933 풀이 d[i] i 수를 제곱수의 합으로 표현 할 수 있는 경우의 수 중복 문제 발생 1 1 d[1] = 1 4 1 + 1 + 1 + 1 4 d[4] = 2 5 1의 제곱 + 4 d[4] = 2 2의 제곱 + 1 d[1] = 1 d[5] = d[4] + d[1] = 3 여기서 중복 문제가 발생 사실, d[5] = 2 중복 해결이 관건","link":"/2018/02/20/%EB%9D%BC%EA%B7%B8%EB%9E%91%EC%A3%BC%EC%9D%98%20%EB%84%A4%20%EC%A0%9C%EA%B3%B1%EC%88%98%20%EC%A0%95%EB%A6%AC/"},{"title":"coins","text":"https://www.acmicpc.net/problem/3067 풀이 9084 번 문제와 동일한 문제 ex) d[i] : i원을 만드는 경우의 수 2원으로 i 만드는 경우의 수 + 3원으로 i 만드는 경우의 수 + 5원으로 i 만드는 경우의 수 목표금액 7원을 만드는 경우 2원으로 만드는 경우 : 위 표와 같다 3원으로 만드는 경우 : 이전 결과에 경우의 수를 더한다. money가 6원 일 때 2원 * 3개 (이전 결과) 3원 * 2개 money가 7원 일 때 2원 * 2개 + 3원 * 1개 X 의 의미 2원으로 1원을 만들 수 없다 3원으로 1원, 2원을 만들 수 없다 5원으로 1원, 2원, 3원, 4원을 만들 수 없다","link":"/2018/02/26/coins/"},{"title":"구슬게임","text":"https://www.acmicpc.net/problem/2600 풀이 감이 잡히질 않음 다시 풀어야함","link":"/2018/02/28/%EA%B5%AC%EC%8A%AC%EA%B2%8C%EC%9E%84/"},{"title":"저작권","text":"https://www.acmicpc.net/problem/2914 풀이 멜로디 = 곡의 개수 * 평균값 하지만, 자료형 타입이 다른 점을 고려해야한다 ex) (int)874.38 == 874","link":"/2018/02/27/%EC%A0%80%EC%9E%91%EA%B6%8C/"},{"title":"프로세서 연결하기","text":"https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV4suNtaXFEDFAUf 풀이 완전탐색 문제 전선의 중복 문제를 어떻게 해결할까..","link":"/2018/03/05/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%20%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0/"},{"title":"최빈수","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV13zo1KAAACFAYh 풀이 특정 자료에서 가장 여러번 나타나는 값 찾기 i번째에서 i+1 ~ 1000 번째까지 같은 값 있는지 체크","link":"/2018/03/09/%EC%B5%9C%EB%B9%88%EC%88%98%20%EA%B5%AC%ED%95%98%EA%B8%B0/"},{"title":"그래프","text":"그래프 자료구조의 일종 정점(node, vertex) 주로 번호가 써있음 간선(edge) : 정점 사이 연결 그래프 G =(V,E)로 나타냄 그래프를 저장하는 방법 인접 행렬 정점 개수를 v라고 할때, v 제곱 크기의 인차원 배열 이용 a[i][j]=1 i에서 j 로 가는 간선이 있으면 a[i][j]=0 i에서 j 로 가는 간선이 없으면 a[i][j] = w i에서 j로의 간선 가중치가 w 이면 없는 간선도 저장하기 때문에 자주 사용하지 않는 방법 쉬운 문제 풀 때 주로 사용 인접 리스트 링크드 리스트를 이용해서 구현 a[i] = i와 연결된 정점이 링크드리스트 형태로 저장 a[1] : 2, 5 1과 연결된 정점이 2, 5 링크드 리스트는 구현하는데 시간이 오래걸림 그래서, vector / arraylist로 함 가중치가 있으면 정점과 가중치를 같이 저장 a[1] : (2,2), (5,7) 그래프의 탐색 목적 : 모든 정점을 한 번씩 방문 깊이 우선 탐색 (DFS) 최대한 깊숙히 많이 감 스택 사용 스택을 이용해서 갈수 있는 만큼 많이 가고 갈 수 없으면 이전 정점으로 돌아감 (스택에서 pop해서) check라는 배열이 필요함 0 : 아직 방문 X 1 : 방문 O 갈 수 있는 정점이 여러개면 번호가 작은 것부터 pop 계속하다가 스택이 비면 탐색 종료 구현 1234567891011121314151617void dfs(int x){ //방문 했다고 체크 check[x] = true; //a[x] : x와 연결된 정점들이 저장되어 있음 for(int i=0; i&lt;a[x].size; i++){ //x와 연결된 정점 int y = a[x][i]; //방문하지 않았으면 방문 if(check[y] == false){ dfs(y); } }} ​ 너비 우선 탐색 (BFS) 최대한 넓게 가는 것 큐 사용 모든 가중치가 1이면 최단 거리 찾는 알고리즘 큐를 이용해서 아직 방문하지 않았고, 지금 위치에서 갈 수 있는 것을 모두 큐에 넣는 방식 큐에 넣을 때 방문했다고 체크 check라는 배열이 필요함 0 : 아직 방문 X 1 : 방문 O 구현 12345678910111213queue&lt;int&gt; q;check[1] = true; q.push(1);while(!q.empty()){ int x = q.front(); q.pop(); printf(&quot;%d &quot; , x); for(int i=0; i&lt;a[x].size; i++){ int y = a[x][i]; if(check[y] == false){ check[y] = true; q.push(y); } }} ​","link":"/2018/03/10/%EA%B7%B8%EB%9E%98%ED%94%84/"},{"title":"최대상금","text":"풀이https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15Khn6AN0CFAYD&amp;categoryId=AV15Khn6AN0CFAYD&amp;categoryType=CODE 모든 경우의 수 완전 탐색을 하려고 하였다. 겹치는 부분이 있기때문에, 방문체크 배열을 만들었다. 바꿀 기회가 남아 있으면 다시 재귀 함수를 호출하여 탐색을 한다. 계속 오답. 많은 시간을 투자했지만 풀지 못하였다. 다시 풀어봐야함. 해결 결국 구글링을 하였다. 해결의 핵심은 같은 횟수에, 같은 숫자를 탐색하는지 체크하는 배열을 두는 것이다. 같은 횟수에, 해당 숫자를 탐색하지 않았으면, 탐색을 시작하고 탐색을 이미 했으면, 계속해서 반복문을 돌린다","link":"/2018/03/12/%EC%B5%9C%EB%8C%80%EC%83%81%EA%B8%88/"},{"title":"경로찾기","text":"https://www.acmicpc.net/problem/11403 다시 푼 문제이다. DFS를 이해하고 있으면 쉬운 문제이다. 풀이 각각의 정점에서 차례대로 DFS를 실행한다. 연결된 정점이 있고 아직 방문하지 않았으면, 방문 체크 후에 연결된 정점에서 다시 DFS를 실행한다. 경로를 출력한다. 예시 위의 경우를 생각해보자. 0을 시작으로 DFS를 실행한다. 0과 연결된 정점은 1이다. 1은 아직 방문하지 않았으니 방문 체크를 한다. 1을 시작으로 DFS를 실행한다. 1과 연결된 정점은 2이다. 2는 아직 방문하지 않았으니 방문 체크를 한다. 2를 시작으로 DFS를 실행한다. 2와 연결된 정점은 0이다. 0은 아직 방문하지 않았으니 방문 체크를 한다. 0과 연결된 정점은 1이다. 1은 이미 방문을 하였으니 방문하지 않는다. DFS는 종료되고, 방문체크 된 곳이 0에서 이동 가능 한 정점이다. 1을 시작으로 DFS를 실행한다. 이하 위와 같다. 2를 시작으로 DFS를 실행한다. 이하 위와 같다.","link":"/2018/04/02/%EA%B2%BD%EB%A1%9C%EC%B0%BE%EA%B8%B0/"},{"title":"영역 구하기","text":"풀이https://www.acmicpc.net/problem/2583 배열에 직사각형 그리는 게 핵심 x와 y 를 바꿔서 그려야함 이미 칠해져 있거나 , 방문을 이미 했으면 탐색 X","link":"/2018/04/03/%EC%98%81%EC%97%AD%20%EA%B5%AC%ED%95%98%EA%B8%B0/"},{"title":"로또","text":"풀이https://www.acmicpc.net/problem/6603 DFS 를 수행하며, 해당 정점을 스택에 담는다. 스택의 크기가 6이면 출력한다 출력 후 탐색을 종료하고, 이전 번호로 돌아가서 다시 DFS 수행","link":"/2018/04/08/%EB%A1%9C%EB%98%90/"},{"title":"적록색약","text":"풀이https://www.acmicpc.net/problem/10026 이차원 배열의 각 index에 순차적으로 접근 현재 위치를 기준으로 상하좌우 조사 현재 위치와 같은 색깔 &amp;&amp; 아직 방문 하지 않았으면 이동 2번 다시 수행","link":"/2018/04/09/%EC%A0%81%EB%A1%9D%EC%83%89%EC%95%BD/"},{"title":"양치기 꿍","text":"풀이https://www.acmicpc.net/problem/3187 이차원 배열의 각 index에 순차적으로 접근 양, 늑대 count 현재 위치를 기준으로 상하좌우 조사 울타리가 X &amp;&amp; 방문 X 이동 2번 다시 수행","link":"/2018/04/13/%EC%96%91%EC%B9%98%EA%B8%B0%20%EA%BF%8D/"},{"title":"소수경로","text":"풀이https://www.acmicpc.net/problem/1963 최소 횟수를 구한다 따라서, BFS 현재 숫자에서 각 자리 수마다 하나씩 바꿈 소수이면 큐에 넣음 한 너비씩 진행 최종 찾고자 나오면 바로 출력해도 됨 한 너비에서 진행되고 있기 떄문에","link":"/2018/04/14/%EC%86%8C%EC%88%98%EA%B2%BD%EB%A1%9C/"},{"title":"상근이의 여행","text":"풀이https://www.acmicpc.net/problem/9372 가장 적은 종류 따라서, BFS 한 너비를 끝 마치고 다음 너비로 이동 이를 위해, 현 위치에서 갈 수 있는 곳들을 큐에 add","link":"/2018/04/15/%EC%83%81%EA%B7%BC%EC%9D%B4%EC%9D%98%20%EC%97%AC%ED%96%89/"},{"title":"바이러스","text":"풀이https://www.acmicpc.net/problem/2606 1번 컴퓨터와 연결된 컴퓨터를 차례대로 최대한 깊게 방문 DFS 컴퓨터 방문할 때마다 ans++","link":"/2018/04/16/%EB%B0%94%EC%9D%B4%EB%9F%AC%EC%8A%A4/"},{"title":"로봇청소기","text":"https://www.acmicpc.net/problem/4991 다시 푼 문제이다. 어떻게 풀어야하는지 전혀 감이 잡히지 않았다. 해설을 보고 이해를 하였다. 풀이 map 입력을 받으며, 더러운 칸이면 칸의 위치를 백터에 저장한다. 시작 위치에서 더러운 칸을 이동하는 최소값을 next_permutation()을 이용하여 구한다. 예시 다음과 같이 더러운 칸이 세 곳 이라고 하자. Start Point Dirty Point 01 Dirty Point 02 Dirty Point 03 방문하는 순서는 다음과 같은 경우들이 있다. 이 때, next_permutation() 을 이용한다. S -&gt; 01 -&gt; 02 -&gt; 03 S -&gt; 01 -&gt; 03 -&gt; 02 S -&gt; 02 -&gt; 01 -&gt; 03 S -&gt; 02 -&gt; 03 -&gt; 01 S -&gt; 03 -&gt; 01 -&gt; 02 S -&gt; 03 -&gt; 02 -&gt; 01 그렇다면 이동 경로 거리는 어떻게 구할까? 위 예시 중, 가장 위의 경우를 보자. S -&gt; 01 최단 거리 : S를 시작점으로 하는 BFS 에서 구할 수 있다. 01 -&gt; 02 최단 거리 : 01을 시작점으로 하는 BFS 에서 구할 수 있다. 02 -&gt; 03 최단 거리 : 02를 시작점으로 하는 BFS 에서 구할 수 있다.","link":"/2018/04/27/%EB%A1%9C%EB%B4%87%EC%B2%AD%EC%86%8C%EA%B8%B0/"},{"title":"연구소","text":"풀이https://www.acmicpc.net/problem/14502 반복 벽 3개 설치 =&gt; DFS 첫 번째 벽 어디 세울지 찾음 ( 첫번째 dfs 메소드 ) for문 다 돌면, main을 돌아가 두 번째 벽 어디 세울지 찾음 ( 두 번째 dfs 메소드 ) for문 다 돌면, ( 첫번째 dfs 메소드 )로 돌아가 세 번째 벽 어디 세울지 찾음 ( 세 번째 dfs 메소드 ) 세우고, 바이러스 퍼뜨림 세번째 벽 세웠던거 초기화하고 ( 두 번째 dfs 메소드 ) 로 돌아감 바이러스 퍼짐 =&gt; BFS 0의 개수 세기 0의 개수의 최댓값 구하기","link":"/2018/04/29/%EC%97%B0%EA%B5%AC%EC%86%8C/"},{"title":"케빈 베이컨의 6단계 법칙","text":"풀이https://www.acmicpc.net/problem/1389 유저의 수 만큼 BFS start(root) 에서 다음 유저까지 가는데 얼마나 가야하는지 depth 구하는것과 동일 queue에 넣을 때, 부모가 누구인지도 같이 저장하면 됨","link":"/2018/05/01/%EC%BC%80%EB%B9%88%20%EB%B2%A0%EC%9D%B4%EC%BB%A8%EC%9D%98%206%EB%8B%A8%EA%B3%84%20%EB%B2%95%EC%B9%99%20/"},{"title":"프린터 큐","text":"https://www.acmicpc.net/problem/1966 풀이 queue에서 하나씩 dequeue하면서 우선순위가 더 큰 문서가 있는지 확인 이를 위해, temp queue를 생성 ex original : 1 2 3 4 temp : 2 3 4 1 우선순위 더 큰 문서가 있음 original : 2 3 4 1 temp : 3 4 1 2 우선순위 더 큰 문서가 있음 original : 4 1 2 3 temp : 1 2 3 4 temp : 2 3 4 1 temp : 3 4 1 2 우선순위 더 큰 문서가 없음 original 에서 head remove original : 1 2 3 ….","link":"/2018/05/04/%ED%94%84%EB%A6%B0%ED%84%B0%20%ED%81%90/"},{"title":"물통","text":"풀이https://www.acmicpc.net/problem/2251 경우의 수 A -&gt; B A -&gt; C B -&gt; A B -&gt; C C -&gt; A C -&gt; B 가능한 모든 경우를 Queue에 넣어가면서 체크 EX (0 0 10) (8 0 2), (0 9 1) (0 8 2), (0, 0, 10) : 이미 체크했으므로 큐에 넣지 않음, (8, 2, 0) (8 1 1), (0 0 10) : 이미 체크했으므로 큐에 넣지 않음, (1 9 0) ….","link":"/2018/05/06/%EB%AC%BC%ED%86%B5/"},{"title":"돌다리","text":"풀이https://www.acmicpc.net/problem/12761 트리의 깊이가 얼마인지 구하면 됨 현재위치에서 갈 수 있는 곳을 Queue에 넣을 때, 위치와 트리의 depth를 함께 저장한다. 위치 8가지 경우의 수 트리의 depth 현재위치의 깊이+1","link":"/2018/05/08/%EB%8F%8C%EB%8B%A4%EB%A6%AC/"},{"title":"팀배분","text":"풀이https://www.acmicpc.net/problem/1953 깊이에 따라 팀을 나눔 깊이 0, 2, 4, 6, 8 …. : 백팀 깊이 1, 3, 5, 7, 8 …. : 청팀 학생을 아직 방문하지 않았으면 학생을 root로 BFS 깊이 정보를 나타내기 위해 Student class 생성해서, 학생 번호와 깊이 저장","link":"/2018/05/10/%ED%8C%80%EB%B0%B0%EB%B6%84/"},{"title":"숨바꼭질","text":"풀이https://www.acmicpc.net/problem/1697 현재 위치에서 이동 가능한 곳 체크 X - 1 X + 1 X * 2 체크 조건 이동 가능한 곳이 범위 안에 있나? 아직 방문하지 않은 곳인가? Queue에서 이동 가능한 곳을 뽑아냄 동생의 위치이면 그래프의 Depth를 출력 그래프의 Depth를 표현하기 위해 Class는 위치와 depth로 구성","link":"/2018/05/13/%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/"},{"title":"안전영역","text":"https://www.acmicpc.net/problem/2468 풀이비의 높이(지역 높이 최소~최대) 로 다음을 반복 물에 잠긴 영역 체크 BFS로 안정 영역 개수 체크 오답 원인최소 답을 0으로 설정하였기 때문에 계속 틀렸었다. 해결최소 답은 1이다. 왜냐하면, 아무 것도 잠기지 않는다면 하나의 영역이기 때문이다.","link":"/2018/05/15/%EC%95%88%EC%A0%84%EC%98%81%EC%97%AD/"},{"title":"나이트의 이동","text":"풀이 전형적인 BFS (1번) 큐에서 deque를 한다 도착지점인지 확인한다. 도착 지점이면 끝 도착 지점이 아니라면 계속 deque한 지점에서 이동 가능한 곳을 모두 큐에 넣는다 다시 1번부터 반복한다","link":"/2018/05/27/%EB%82%98%EC%9D%B4%ED%8A%B8%EC%9D%98%20%EC%9D%B4%EB%8F%99/"},{"title":"촌수 계산","text":"풀이 결국 최단 거리 문제. 따라서 BFS 테스트 케이스 대로 그래프를 그리면 다음과 같다 7에서 3까지의 최단 거리를 구하면 된다. 이는 곧 7에서 3까지의 depth를 구하는 것이다.","link":"/2018/05/28/%EC%B4%8C%EC%88%98%20%EA%B3%84%EC%82%B0/"},{"title":"스타트링크","text":"문제 요약 F층으로 이루어진 건물 스타트 링크는 G층 현재 위치 S층 U 위로 U층을 감 D 아래로 D층을 감 U층 위, 또는 D층 아래에 해당하는 층이 없을 때는, 엘리베이터는 움직이지 않는다 S층에서 G층 가려면 버튼을 적어도 몇번 눌러야해???? 갈수 없다면 “use the stairs” 출력 풀이 전형적인 BFS 큐에서 deque를 한다 …. A 도착지점인지 확인한다. 도착 지점이면 끝 도착 지점이 아니라면 계속 deque한 지점에서 이동 가능한 곳을 모두 큐에 넣는다 이동 가능 한 곳 U층을 더 했을 때, 꼭대기 층 이하이어야함 D층을 뺐을 때, 1층 이상이어야함 다시 A부터 반복한다","link":"/2018/06/01/%EC%8A%A4%ED%83%80%ED%8A%B8%EB%A7%81%ED%81%AC/"},{"title":"탈출","text":"문제 요약 문자 비버 . 물 * 돌 X 비버굴 D 고슴도치 굴 S 매 분 1분 마다 고슴도치 동서남북으로 이동 돌을 통과할 수 없다 물 동서남북으로 이동 비어있는 칸으로 확장 비버의 소굴로 확장할수 없다 돌을 통과할 수 없다 풀이 이렇게 풀면 되지 않을까? 물의 확산 :DFS 고슴도치의 이동 :BFS 아니다 ! BFS 만으로 풀 수 있다 물을 먼저 Enqueue 고슴도치의 위치를 Enqueue 하나의 큐에서 진행 Code","link":"/2018/06/04/%ED%83%88%EC%B6%9C/"},{"title":"마지막 생존자","text":"https://koitp.org/problem/SDS_TEST_SURVIVOR/read/ 풀이이차원 배열을 순차탐색하여, 해당 index와 주변 8개의 값을 체크한다. 쉬운 문제인데, 오랜만에 알고리즘 문제를 푸니 오래걸렸다.","link":"/2018/07/18/%EB%A7%88%EC%A7%80%EB%A7%89%20%EC%83%9D%EC%A1%B4%EC%9E%90/"},{"title":"쉬어가는 페이지","text":"https://koitp.org/problem/SDS_TEST_PAGE/read/ 풀이s에 j 를 더한 값이 쉬어 가는 page 인지 체크. 쉬운 문제인데, 오랜만에 알고리즘 문제를 푸니 오래걸렸다.","link":"/2018/07/18/%EC%89%AC%EC%96%B4%EA%B0%80%EB%8A%94%20%ED%8E%98%EC%9D%B4%EC%A7%80/"},{"title":"순환 공간","text":"https://koitp.org/problem/SDS_TEST_SPACE/read/ 오답BFS 로 풀었을 때는 메모리 초과가 뜬다. 해결시뮬레이션으로 풀면 해결된다. 1번 돌아가지 않고 직접 가는 경우이다. 시작점과 도착점 사이의 절대값을 구한다. 2번 돌아가는 경우이다. 행과 열의 대소 비교를 통해 구한다.","link":"/2018/07/19/%EC%88%9C%ED%99%98%20%EA%B3%B5%EA%B0%84/"},{"title":"치킨 배달","text":"https://www.acmicpc.net/problem/4991 삼성 알고리즘 시험 보러 가서 못 푼 문제이다. 다시 푸는데 오랜 걸렸다. ( 2018.08.01 ) : 조합 + BFS 다시 푸는데 30분도 안걸렸다. ( 2018.10.01 ) : DFS 첫 번째 풀이 치킨집 K개 중에 M개를 고르는 경우의 수를 구한다. (조합) 선택되지 않은 치킨집은 빈 칸으로 만든다. 각 집을 출발점으로 가장 가까운 치킨집까지의 거리를 구한다 (BFS) 첫 번째 풀이 예시 다음과 같이 치킨집이 3개가 있다고 하자. 0번 치킨집 1번 치킨집 2번 치킨집 최대 2개의 치킨집을 선택하는 경우의 수는 다음과 같다. 0번, 1번 — A 0번, 2번 — B 1번, 2번 — C A를 생각해보자. 2번이 선택되지 않았기 때문에, 2번 치킨집을 폐업 시킨다. 각 집의 위치에서 BFS를 실행한다. 이는 각 집에서 가장 가까운 치킨 집과의 거리를 구하기 위함이다. B, C도 위와 같은 작업을 반복한다. 두 번째 풀이 치킨을 선택하여 List에 저장한다. (DFS) 각 집에서 선택된 치킨집 까지의 거리를 계산한다. 치킨집이 A, B, C, D 네 개 있고, 최대 3개 선택을 한다고 했을 때, DFS는 다음과 같이 진행된다.","link":"/2018/08/01/%EC%B9%98%ED%82%A8%EB%B0%B0%EB%8B%AC/"},{"title":"드래곤 커브","text":"https://www.acmicpc.net/problem/15685 삼성 코딩 테스트 보러 가서 풀지 못한 문제이다. 시뮬레이션 문제이다. 풀이우선 규칙을 찾아야한다. 시작점이 (4,2), 첫 시작방향이 북쪽(1), 차원이 3차원을 그림으로 그려 확인해보자. 이를 숫자를 이용해 테이블로 나타내면 다음과 같다. 위의 테이블에서 알 수 있듯이, n차원의 요소들은 n-1차원의 요소들을 그대로 가지고, +1씩 더한 요소들을 추가적으로 가진다. 여기서 중요한 것은, 남쪽 방향(3)은 다음 차례에서 동쪽 방향(0)으로 추가된다 따라서 다음과 같은 플로우로 문제를 푼다. 드레곤 커브의 개수 만큼 어레이리스트를 생성한다. 바로 전 리스트 요소 복사하고 새로운 요소를 추가함으로써, i번째 어레이리스트를 setting 한다. i번째 어레이리스트를 map에 그린다. 2번과 3번의 작업을 모두 마치고, 직사각형의 개수를 count 한다.","link":"/2018/08/30/%EB%93%9C%EB%9E%98%EA%B3%A4%EC%BB%A4%EB%B8%8C/"},{"title":"스타트와링크","text":"https://www.acmicpc.net/problem/14889 삼성 코딩 테스트 기출 문제이다. 시뮬레이션 + 조합 으로 해결하였다. 풀이플로우는 다음과 같다. 팀을 배분한다. 배분한 팀 각각의 능력치의 합을 구한다. 두 팀 간의 능력치 차이를 구한다. 우선, 팀을 배분하는 방법부터 보자. 총 6명이 있다고 하자 : 1번, 2번, 3번, 4번, 5번, 6번 6명이므로 3명 / 3명으로 팀을 나누어야한다. 1번은 5명 중 2명과 팀을 이룬다. 즉, 5C2 (1, 2, 3) (1, 2, 4) (1, 2, 5) (1, 2, 6) (1, 3, 4) (1, 3, 5) (1, 3, 6) (1, 4, 5) (1, 4, 6) (1, 5, 6) 위와 같이 1번이 팀을 이루면, 나머지 사람들이 자동적으로 팀을 이루게 된다. 이제, 배분한 팀 각각의 능력치의 합을 구한다. (1, 2, 3) 을 예로 들자. 1번이 2번, 3번과 팀을 이루었으니 (4, 5, 6)이 한 팀을 이룬다. (1, 2, 3) 팀의 능력치의 합 S12 + S13 + S21 + S23 + S31 + S32 (4, 5, 6) 팀의 능력치의 합 S45 + S46 + S54 + 56 + S64 + S65 다음 배열을 이용해 계산한다. 마지막으로, 두 팀 간의 능력치 차이를 구한다. 위에서 배분한 팀 각각의 능력치의 합을 구하였으므로, 쉽게 차를 구할 수 있다.","link":"/2018/08/31/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%99%80%EB%A7%81%ED%81%AC/"},{"title":"경사로","text":"https://www.acmicpc.net/problem/14890 삼성 코딩 테스트 기출 문제이다. 시뮬레이션 문제이다. 풀이 행을 모두 체크한다. i행의 j열은 세 가지 경우로 나뉜다. j+1열과 같은 높이 j+1열을 체크한다. j+1열 높이보다 1작음 왼쪽 방향으로 경사로를 세울 수 있는지 체크한다. 다음 그림과 같이 1번 지점은 j+1열 높이보다 1 작기 때문에 2번 방향으로 체크한다. j+1열 높이보다 1높음 오른쪽 방향으로 경사로를 세울 수 있는지 체크한다. 다음 그림과 같이 1번 지점은 j+1열 높이보다 1 높기 때문에 2번 방향으로 체크한다. 열을 모두 체크한다. 행을 체크하는 경우와 동일하다. 코드로 옮기는 것이 쉽지 않아 해설을 보고 해결했다.","link":"/2018/09/01/%EA%B2%BD%EC%82%AC%EB%A1%9C/"},{"title":"톱니바퀴","text":"https://www.acmicpc.net/problem/14891 삼성 코딩 테스트 기출 문제이다. 시뮬레이션 문제이다. 시간이 많이 걸렸지만, 쉬운문제였다. 풀이다음 톱니바퀴 상태를 예로 들자. 이를 테이블로 나타내면 다음과 같다. 위의 테이블에서 같읕 색깔의 네모로 체크 된 것이 맞닿는 부분이다. 3번 톱니바퀴를 돌린다고 하면, 3번 톱니바퀴 기준, 왼쪽 톱니바퀴들을 모두 확인한다. 2번 톱니바퀴와 닿는 부분이 같은 극이기 때문에 회전하지 못한다. 더 이상 왼쪽 톱니바퀴들을 확인하지 않는다. 3번 톱니바퀴 기준, 오른쪽 톱니바퀴들을 모두 확인한다. 4번 톱니바퀴와 닿는 부분이 다른 극이기 때문에 회전할 수 있다. 각 톱니바퀴들을 모두 회전시킨다.(shift)","link":"/2018/09/04/%ED%86%B1%EB%8B%88%EB%B0%94%ED%80%B4/"},{"title":"연산자 끼워넣기","text":"https://www.acmicpc.net/problem/14888 삼성 코딩 테스트 기출 문제이다. 시간 초과가 났다. 오답 풀이다음의 예를 보자. 숫자 : 1 2 3 4 5 6 연산자 : 2 1 1 1 따라서 연산자는 다음과 같다. +, +, -, *, / 경우의 수는 같은 것을 포함하는 순열이다. 5! / 2! 각각의 경우에 숫자를 이용해 계산을 하고, 계산 값들 중에 최소값, 최대값을 찾는다. 정답 풀이시뮬렌이션 문제라고 생각했다. 해설을 보고 완전 탐색 문제란 것을 알았다. 따라서 BFS or DFS 로 풀 수 있다. 익숙한 BFS로 해결하였다. 다음의 예시에서 나올 수 있는 모든 경우의 수를 그림으로 그려보자. 숫자 : 1, 2, 3, 4 연산자 : +, +, * 문제에서 주어진대로, 숫자는 순서를 그대로 유지한다. 1 다음에 오는 숫자는 2다. 1과 2를 계산할 수 있는 연산자는 + 와 * 이다. 이 두 경우를 큐에 넣는다. 1+2 와 3 을 계산 할 수 있는 연산자는 +와 * 이다. 이 두 경우를 큐에 넣는다. 이와 같은 방식으로 모든 경우의 수를 큐에 넣는다. 모든 연산자를 사용 했을 때(트리의 마지막 depth)가 최종 결과값 이므로, 이들 중에 최대값 및 최소값을 구한다.","link":"/2018/09/05/%EC%97%B0%EC%82%B0%EC%9E%90%20%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0/"},{"title":"퇴사","text":"https://www.acmicpc.net/problem/14501 삼성 코딩 테스트 기출 문제이다. BFS로 풀었다. 계속 틀렸다고 나온다. 그래서 DFS로 다시 풀었다. DP 로도 풀 수 있다고 한다. 예시다음의 예시로 설명하겠다. BFS 오답 풀이 위의 그림과 같이, 시작 날짜를 다르게 하여 BFS를 모두 실행한다. 더 이상 자식 노드가 없을 때가 마지막이므로, 이 때 이익 합을 계산한다. BFS 오답 코드 DFS 정답 코드","link":"/2018/09/08/%ED%87%B4%EC%82%AC/"},{"title":"View","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV134DPqAA8CFAYh&amp;categoryId=AV134DPqAA8CFAYh&amp;categoryType=CODE SW Expert Academy [D2] 쉬운 문제이다. 풀이i번째 빌딩에서 조망권이 확보 되는 세대는 다음과 같은 조건을 충족시킨다. i번째 빌딩 높이 &gt; i-1번째, i-2번째, i+1번째, i+2번째 빌딩 높이 세대 수 = i번째 빌딩 높이 - max( i-1번째, i-2번째, i+1번째, i+2번째 빌딩 높이)","link":"/2018/09/09/View/"},{"title":"백만장자프로젝트","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5LrsUaDxcDFAXc&amp;categoryId=AV5LrsUaDxcDFAXc&amp;categoryType=CODE SW Expert Academy [D2] 쉬운 문제였지만, 시간 초과가 나서 다시 풀었다. 오답 풀이i 날에 샀다면, x(&gt;i) 날에 팔아 이득을 챙기면 된다. 여기서 포인트는 max(이득(x)) 를 찾아야 한다는 것이다. 다음의 식을 얻을 수 있다. sum += max(이득(x)) - 이득(i) 내가 풀이한 코드는, 루프를 두 개 돌리는 것이다. 이렇게 하면, 시간 초과가 발생한다. O(N^2) 정답 풀이 O(N)으로 풀 수 있다. 마지막 날부터 시작해서 1일까지 순차 탐색을 해서, 각 날짜의 최대값을 구하는 것이다. 그리고 이익의 합을 계산한다.","link":"/2018/09/10/%EB%B0%B1%EB%A7%8C%20%EC%9E%A5%EC%9E%90%20%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%20/"},{"title":"콩 많이 심기","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do SW Expert Academy [D4] 정답 풀이 모든 판에 콩을 심었다고 가정하고 시작한다. 콩이 심은 판 사이의 거리가 2이면 콩을 지운다. 위의 그림처럼, 빨간색 원이 기준이 된다. 기준을 중심으로 길이가 2인 판에 콩이 있으면 콩을 없앤다. 파란색 네모 부분이 길이가 2인 지점이다. 그리고 기준을 다음 칸으로 옮겨서 같은 작업을 반복한다. 정답 코드","link":"/2018/09/11/%EC%BD%A9%20%EB%A7%8E%EC%9D%B4%20%EC%8B%AC%EA%B8%B0/"},{"title":"감시","text":"https://www.acmicpc.net/problem/15683 어려웠다. BFS로 시도하였지만, 실패하였다. 해설을 보고 DFS로 풀었다. 풀이 이전 감시 상태를 가져와 복사한다. (깊은 복사) 감시 가능 지역을 표시한다. 다음 cctv를 탐색한다. 탐색 순서를 설명하기 위해 다음 표를 보자. 위의 표에서 감시 카메라는 A, B, C 세 개가 있다. A와 B 는 상하 / 좌우 를 감시할 수 있고, C는 상하좌우를 감시할 수 있다. 탐색 순서는 다음 그림과 같이 나타낼 수 있다. DFS이다. 최대한 깊이 탐색을 한다. 노랑색의 1~4 번 순서대로 탐색이 진행된다. 개념배열을 매개변수로 전달했을 때, call by reference이다.","link":"/2018/09/12/%EA%B0%90%EC%8B%9C/"},{"title":"로봇청소기","text":"https://www.acmicpc.net/problem/14503 삼성 기출문제이다. 매우 어려운 문제였다. 문제 이해 자체가 어렵다. BFS로 해결할 수 있다. 풀이 현재 위치를 청소한다. 현재위치에서 바라보는 방향의 왼쪽 방향을 확인한다. ( 이 작업을 4번 진행한다. 그렇다면, 현재위치의 동서남북 모든 방향을 확인 할 수 있다.) 청소를 해야할 구역이고, 아직 방문하지 않았으면 방문한다. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진한다. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다. 다음 그림에서와 같이 처음 시작은 (7,4) 에서 시작하고, 방향은 북쪽(0)을 바라보고 있다고 하자. 최종 움직임은 다음과 같이 그려질 것이다. 다음 그림의 파란색 지점에서 어떻게 움직이는지 확인해보자. 파란색 지점은 (8,4) 에서 동쪽(1)을 바라보고 있다. 우선 파란색 지점의 방향에서 왼쪽방향(동쪽의 서쪽 방향) 인 북쪽(0)을 확인한다. 이미 방문하였으므로, 이제 북쪽의 왼쪽방향인 서쪽방향을 확인한다. 이미 방문하였으므로, 이제 서쪽의 왼쪽방향인 남쪽방향을 확인한다. 아직 방문하지 않았고, 청소를 해야하는 구역이므로 방문한다. 따라서 다음과 같이 이동을 하게 된다.","link":"/2018/09/13/%EB%A1%9C%EB%B4%87%EC%B2%AD%EC%86%8C%EA%B8%B0/"},{"title":"주사위 굴리기","text":"https://www.acmicpc.net/problem/14499 삼성 기출문제이다. 쉬운 문제이다. 문제 이해만 잘 하면 된다. 풀이문제의 핵심은 주사위를 ‘옮기는 것’ 아니라, ‘굴리는 것’이다. 다음 그림과 같이 처음 상태에서 동, 서, 북, 남으로 굴림에 따라서 방향에 대한 값이 바뀐다. 회전하고 문제에서 주어진 대로 풀면 된다.","link":"/2018/09/19/%EC%A3%BC%EC%82%AC%EC%9C%84%20%EA%B5%B4%EB%A6%AC%EA%B8%B0/"},{"title":"테트로미노","text":"https://www.acmicpc.net/problem/14500 삼성 기출문제이다. 매우 어려운 문제였다. 처음에, 도형의 모든 경우의 수를 하나 하나 놓아봐서 최대값을 구해야하는지 생각했다. 하지만, DFS로 해결할 수 있다. 풀이다음 그림과 같이 DFS를 이용하여 최대한 깊이 탐색한다. ㅗ 모양을 제외한 모양은 DFS로 탐색이 가능하다. 4개의 탐색(깊이 3) 까지 마쳤을 때, 최대값을 계산한다. ㅗ 모양은 현재 위치를 기준으로 동, 서, 남, 북을 조사하여 4개 중에 최소 값을 빼서 최대값을 계산할 수 있다. 다음 그림처럼 A를 기준으로 B, C, D, E 네 방향을 탐색한다. 만약에, E가 B, C, D, E 네 개 중에 최소값이라면, 다음 그림처럼 E를 제외하고 합을 구한다.","link":"/2018/09/18/%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8/"},{"title":"사다리 조작","text":"https://www.acmicpc.net/problem/14499 삼성 기출문제이다. DFS 문제이다. 어려웠다. 해설을 보고 이해를 했지만, 직집 해결해보기 위해 며칠 동안 붙잡고 있던 문제이다. 풀이 사다리를 어떻게 코드로 표현해야 하는지 파악한다. 사디리는 어디에 둘 수 있는지 파악한다. 탐색을 어떻게 진행할지 생각한다. 사다리를 코드로 표현하는 방법은 다음 그림과 같이 이차원 배열을 이용한다. 사다리를 1과 2로 표현한다. 사다리를 둘 수 있는 곳의 조건은 다음과 같다. i행의 j번째의 값과 j+1번째의 값이 0 : 연속되지 않고, 사다리를 둘 수 있는 빈 칸 이라는 의미 j+1&lt;=n : 동일한 행에 사다리를 둘 수 있다는 의미 탐색은 DFS로 진행한다. 사다리는 최대 3개 까지 둘 수 있다. 사다리를 최대 0개 둘 수 있는 경우, 최대 1개 둘수 있는 경우, 최대 2개 둘수 있는 경우, 최대 3개 둘수 있는 경우로 나눈다. 각 경우에서 DFS를 시작한다. 설명을 위해 빈 칸을 A, B, C.. 로 표현하였다.","link":"/2018/09/19/%EC%82%AC%EB%8B%A4%EB%A6%AC%20%EC%A1%B0%EC%9E%91/"},{"title":"2048","text":"https://www.acmicpc.net/problem/12100 삼성 기출문제이다. DFS 문제이다. 블록을 이동하는 것이 어려운 문제였다. 풀이블록을 5번 이동 시키는 것은 다음 그림과 같이 DFS로 구현한다. 문제의 핵심은 블록을 이동하는 것이다. 블록 이동을 구현하기 위해 Queue를 사용한다. moveBlocks 메소드가 이를 구현한 코드이다.","link":"/2018/09/24/2048/"},{"title":"뱀","text":"https://www.acmicpc.net/problem/3190 삼성 기출문제이다. 쉬운 문제였다. 풀이핵심은 뱀의 이동 흔적을 남기는 것이다. 이를 위해, Queue를 사용하였다. 뱀이 머리만 이동할 경우 이동할 위치를 Enqueue 뱀이 완전히 한 칸 이동할 경우 뱀의 시작점(Queue에 가장 먼저 Enqueue된 요소)을 Dequeue","link":"/2018/09/24/%EB%B1%80/"},{"title":"시험감독","text":"https://www.acmicpc.net/problem/13458 삼성 기출문제이다. 매우 쉬운 문제였다. 풀이문제에서 주어진 대로 풀면 된다. 처음에 틀렸다. ans 변수를 int로 선언하였을 때는 틀렸다고 나온다. long 형으로 선언하였더니 맞았다. 코드","link":"/2018/09/24/%EC%8B%9C%ED%97%98%EA%B0%90%EB%8F%85/"},{"title":"구슬탈출2","text":"https://www.acmicpc.net/problem/13460 삼성 기출문제이다. 해설을 보고 이해하였다. 풀이 완전탐색이고 최소 횟수를 구하는 것이므로, BFS를 사용한다. 삼성 기출 문제 ‘2048’ 에서 블록 이동이 문제 해결의 관건이듯이, 이 문제 역시 공을 이동하는 것이 문제 해결의 관건이다. 구슬 이동 방법 : 상대 공을 무시하고 각자 공을 이동시킴 B가 구멍에 빠지는 경우 : 큐에 넣지 않고 넘긴다 B와 R이 겹치는 경우 : B와 R의 초기 상태를 확인해서 이동한다. 예를 들어, 동쪽으로 이동하는 경우, 초기에 B가 R의 왼쪽에 있었다고 하자. 그렇다면, B를 R의 왼쪽으로 한 칸 이동시켜야한다.","link":"/2018/09/26/%EA%B5%AC%EC%8A%AC%ED%83%88%EC%B6%9C2/"},{"title":"실패율","text":"https://www.welcomekakao.com/learn/courses/30/lessons/42889?language=java 2019 카카오 신입 공채 1차 코딩 테스트 풀이 stages 배열을 순회하며 각 스테이지마다 남아 있는 인원수를 체크한다. 각 스테이지마다 실패율을 계산하여 스테이지 번호와 실패율을 리스트에 저장한다. 리스트를 실패율을 기준으로 내림차순 정렬한다. 예를 들어, 스테이지 개수는 5개, 사용자가 각 스테이지에 현재 도전중인 스테이지 번호는 [2, 1, 2, 6, 2, 4, 3, 3] 각 스테이지의 실패율은 다음 그림과 같이 구한다. 개념Java 에서 정렬하기 위해서 java.util.Collections 클래스의 메소드인 sort()를 사용한다. 객체를 원소로 가진 리스트를 정렬하고자 할 때는, 객체가 Comparable interface를 구현해야 한다. 본 문제에서는 Fail class를 원소로 가지는 arrayList를, Fail class의 rate를 기준으로 내림차순 정렬하고 있다. 이를 위해, Fail class에 compareTo 메소드를 오버라이딩하고 있다.","link":"/2018/09/30/%EC%8B%A4%ED%8C%A8%EC%9C%A8/"},{"title":"오픈채팅방","text":"https://www.welcomekakao.com/learn/courses/30/lessons/42888?language=java 2019 카카오 신입 공채 1차 코딩 테스트 풀이 HashMap으로 이름 변경 이력을 저장한다. ( key : id / value : name ) records 배열을 순회하며 리턴할 배열을 생성한다.","link":"/2018/09/30/%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9/"},{"title":"Introduction","text":"출처 : 이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323) 운영체제란 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하느 소픝웨어 계층 협의의 운영체제(커널) 운영체제의 핵심 부분, 메모리에 상주하는부분 광의의 운영체제 커널 뿐만 아니라 각족 주변 시스템 유틸리티를 포함한 개념 운영체제의 목표 컴퓨터 시스템을 편리하게 사용하도록 환경 제공 운영체제는 동시 사용자/프로그램들이 각각 독자적으로 컴퓨터에서 수행되는 것 같은 환상 제공 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행 컴퓨터 시슴템의 자원을 효율적으로 관리 (*) 프로세서, 기억장치, 입출력 장치 등의 효율적관리 사용자간의 형평성 있는 자원 분배 주언진 자원으로 최대한의 성능을 내도록 사용자 및 운영체제 자신의 보호 프로세스, 파일, 메시지 등을 관리 운영체제의 분류 동시작업 가능 여부 단일 작업(single tasking) MS-DON 프롬프르 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음 다중 작업(multi tasking) 동시에 두개 이상의 작업 처리 UNIX/MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음 사용자의 수 단일 사용자 MS-DOS, MS Windows 다중 사용자 UNIX, NT server 처리 방식 일괄처리(batch processing) 작업 요청의 일정량 모아서 한꺼번에 처리 작업이 완전 종료될 때까지 기다려야함 초기 Punch Card 처리 시스템 시분할(time sharing) 여러 작업을 수행할때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용 interactive한 방식 짧은 응답시간을 가짐 실시간(Realtime OS) 정해진 시간안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS 원자로/공장제어, 미사일제어, 반도체 장비, 로보트제어 Hard realtime system / Soft realtime system 몇 가지 용어 Multitasking 여러 프로그램을 동시에 수행한다는 뜻 Multiprogramming 메모리에 여러 프로그램이 올라가 있음을 강조 Time sharing CPU의 시간을 분할하여 나누어쓴다는 의미 Multiprocessor 하나의 컴퓨터에 CPU가 여러개 붙어 있음을 의미 운영 체제의 예 UNIX 계열 대형 컴퓨터를 위한 OS 코드의 대부분을 C언어로 작성 소스 코드 공개 높은 이식성 하나의 컴퓨터에서 돌아가는 UNIX를 전혀 다른 컴퓨터에 이식하기 쉬움 최소한의 커널 구조 핵심적인 것만 커널에 넣음 다양한 버전 System V, FreeBSD, SunOS, Solaris Linux Windows 계열 DOS MS사에서 개인용 PC를 위해 개발 메모리 관리 능력의 한계 MS Windows 다중 작업용 GUI 기반 OS 풍부한 지원 소프트웨어 운영체제의 구조","link":"/2018/10/01/Introduction/"},{"title":"System Structure, Program Execution","text":"컴퓨터 시스템 구조 mode bit 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요 0 운영체제가 CPU를 가지고 있음 모든 인스트럭션 수행 가능 1 사용자 프로그램이 CPU를 가지고 있음 한정된 인스턱션만 수행 가능 timer 특정 프로그램이 CPU 독점 막기위해 이게 필요 정해진 시간 흐른 뒤 운영체제에게 제어권 넘어가도록 interrupt 발생시킴 매 클럭마다 1씨 감소 타이머 값이 0 이 되면 언터럽트 발생 time sharing 구현 위해 널리 이용 device controller IO 장치 전담하는 작은 CPU 제어 정보를 위해 control register, status register를 가짐 local buffer를 가짐 (일종의 data register) IO는 실제 deivce 와 local buffer 사이에서 일어남 IO가 끝나면 인터럽트로 CPU에 그 사실을 알림 device driver : OS 코드 중 각 장치별 처리 루틴 (소프트웨어) divce controller : 각 장치를 통제하는 작은 CPU (하드웨어) DMA controller 직접 메모리에 접근할 수 있는 컨트롤러 IO 장치가 인터럽트 너무 많이 거니까 CPU가 너무 많이 방해 받아서 DMA controller가 필요 CPU의 중재 없이 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송 I/O 운영체제를 통해서 함 사용자 프로그램은 I/O를 어덯게? system call을 함 (운영체제의 함수를 호출) 인터럽트를 직접 걸어서(trap) mode bit이 0으로 바껴 동기식 입출력과 비동기식 입출력 두 경우 모두 io 완료는 인터럽트로알려줌 syncronous I/O I/O 요청 후 입출력 작업이 완료 된 후에야 제어가 사용자 프로그램에게 넘어감 구현 방법 1 io가 긑날떄 까지 cpu낭비 매시점 하나의 io만 일어남 구현 방법2 io가 완료될때까지 해당 프로그램에게서 cpu를 빼앗음 io 처리를 기다리는 줄에 그 프로그램을 줄 세움 다른 프로그램에게 cpu를 줌 asyncronous I/O I/O가 시작된후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에게 즉시 넘어감 Interrupt 인터럽트 당한 시점의 레티스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘김 인터럽트 : 하드웨어가 발생 시킨 인터럽트 trap : 소프트웨어 인터럽트 Eception : 프로그램이 오류를 범함 System call : 프로그램이 커널 함수를 호출하는 경우 인터럽트 백터 해당 인터럽트의 처리 루틴 주소를 가지고 있음 인터럽트 처리 루틴 (인터럽트 핸들러) 해당 인터럽트를 처리하는 커널 함수 System call 사용자 프로글매이 운영체제의 서비스를 받기 위해 커널 함수를 호출 하는 것 사용자 프로그램이 의도적으로 인터럽트 라인 세팅하면, CPU는 하던일을 멈추고 CPU의 제어권이 사용자 프로그램에서 운영체제에게 넘어감 프로그램의 실행 vitual memory 프로그램 실행 시키면 각 프로그램의 주소 공간이 만들어짐 pysical memory 커널은 항상 상주 당장 필요한 것만 올려둠 swap area 메모리의 연장 공간으로 사용 address tranlation virtial memory의 주소가 물리주소로 바뀜 커널 주소 공간의 내용 code data 하드웨어를 관리하기 위한 자료구조를 가지고 잇음 각 프로그램들을 관리하기 위한 자료구조를 가지고 잇음 stack 함수를 호출하거나 할때 스택을 사용 사용자 프로그램이 사용하는 함수 함수 사용자 정의 함수 자신의 프로그램에서 정의한 함수 라이브러리 함수 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수 자신의 프로그램 실행 파일에 포함되어 있음 커널 함수 운영체제 프로그램의 함수 커널 함수의 호출 == 시스템 콜 프로그램의 실행 시스템 콜을 하면 커널 모드가 되고, 시스템 콜 끝나면 다시 A가 cpu 제어권을 가짐 프로그램이 실행되기 위한 메모리 구조프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간은 코드, 데이터, 스텍, 힙 영역입니다. 코드실행할 프로그램의 코드가 저장되는 영역입니다. 여기서 코드란, 컴파일된 기계어 코드입니다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다. 데이터프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다. 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다. 스택함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다. 힙힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다. reference이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323)","link":"/2018/10/01/System%20Structure,%20Program%20Execution/"},{"title":"Process","text":"Process란 ?실행중인 프로그램입니다. 메모리에 적재되어 CPU 할당을 받을 수 있습니다. Context란 ?CPU 수행상태를 나타내는 하드웨어 문맥입니다. 프로세스의 상태 (Process State) 란 ?프로세스는 상태가 변경되며 수행됩니다. RunningCPU를 잡고 instruction을 수행중인 상태입니다. Ready메모리 등 다른 조건을 모두 만족하고 CPU를 기다리는 상태 입니다. Blocked (wait, sleep)CPU를 주어도 당장 instruction을 수행할 수 없는 상태입니다. 프로세스 자신이 요청한 event(io같은거) 가 만족되지않아 이를 기다리는 상태입니다. 자신이 요청한 event 만족되면 ready 상태가 됩니다. New프로세스가 생성중인 상태입니다. Terminatedexecution이 끝난 상태입니다. Suspended (stopped)프로세스가 통째로 메모리에서 쫓겨난 상태입니다. 디스크에 swap out 됩니다. 외부에서 resume해 주어야 active가 됩니다. PCB란 ?운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보입니다. 프로세스는 CPU 를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU 를 반환해야 하는데, 이때 작업의 진행 상황을 모두 PCB 에 저장하게 됩니다. OS가 관리상 사용하는 부분 CPU 수행 관련 하드웨어 값 메모리 관련 파일 관련 문맥 교환이 뭔가요?CPU를 한 프로세스에서 다른 프로세스로 넘겨누는 과정입니다. system call이나 interrupt 발생시 항상 문맥교환이 일어납니까?system call이나 interrupt 발생시 context switch가 반드시 일어나는 것은 아닙니다. 프로세스 A가 CPU를 잡고 있다가, interrupt 가 걸리거나, system call을 하게되어 user mode에서 kernel mode에 갔다가, 다시 사용자 프로세스 A가 CPU를 잡게 되면 문맥교환이 일어나지 않습니다. 프로세스 스케쥴링 큐의 모습은 ? 스케쥴러란 ? Long-term scheduler (job scheduler)메모리를 어떤 프로세스에게 줄지 결정합니다. 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정합니다. Short-term scheduler (cpu scheduler)어떤 프로세스에게 cpu를 줄지 결정합니다. 어떤 프로세스를 다음번에 running시킬지 결정합니다. Medum-term scheduler (swapper)메모리에 많은 프로그램이 올라가있으면 일부를 골라서 쫓아냅니다. 프로세스에게서 메모리를 뺏는 문제입니다. Thread 란 ?프로세스의 내부의 CPU 수행단위입니다. 스레드는 스레드 ID, PC, register set, 그리고 stack으로 구성됩니다. 같은 프로세스에 속한 다른 스레드와 code seciton, data section, 그리고 OS resource를 공유합니다. 왜 스레드마다 스택을 독립적으로 가지고 있나요?스레드는 독립적인 실행 흐름이기 때문입니다. 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간인 스택을 독립적으로 가지고 있어야 합니다. 왜 스레드마다 PC 레지스터를 독립적으로 가지고 있나요?스레드가 CPU를 할당받았다가 스케쥴러에 의해 CPU를 빼앗기면, 어느 부분까지 수행되었는지 기억할 필요가 있기 때문에 PC 레지스터를 독립적으로 가지고 있어야 합니다. 멀티스레딩이 무엇인가요?하나의 프로세스를 다수의 실행 단위로 구분하여, 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여, 수행 능력을 향상 시키는 것입니다. 멀티스레딩의 장점은 무엇인가요?Responsiveness와 Resource Sharing 이 뛰어나며, 스레드 간 통신 방법이 간단합니다. Responsiveness가 좋습니다.한 스레드가 blocked 되어도, 다른 스레드는 continue 가능합니다 Resource Sharing 이 가능합니다.n개의 스레드는 프로세스의 코드 영역, 데이터 영역 그리고 자원을 공유합니다. 프로세스 간 통신 방법에 비해 스레드 간 통신 방법이 간단합니다.별도의 자원을 이용하지 않고 전역 변수의 공간, 또는 동적으로 할당된 공간인 Heap 영역을 이용해 데이터를 주고 받을 수 있습니다. 멀티스레딩의 단점은 무엇인가요?동기화 작업이 필요합니다. 서로 다른 스레드가 data 영역과 heap 영역을 공유하기 때문입니다. reference이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323)","link":"/2018/10/03/Process/"},{"title":"Process Management","text":"출처 : 이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323) 프로세스 생성 부모 프로세스가 자식 프로세스 생성 프로세스의 트리(계층 구조) 생성 프로세스는 자원을 필요로 함 운영체제로부터 받는다 부모와 공유한다 주소 공간 자식은 부모의 공간을 복사 자식은 그 공간에 새로운 프로그램을 올림 유닉스의 예 : 복제 생성하고 덮어씌움 fork() 시스템 콜이 새로운 프로세스를 복제 생성 부모를 그대로 복사 주소 공간 할당 exec() fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림 (덮어 씌움) 프로세스 종료 exit exit 시스템 콜을 통해 프로세스가 마지막 명령을 수행한후 운영체제에게 이를 알려줌 자식이 부모에게 output data를 보냄(via wait system call) 프로세의 각종 자원들이 운영체제에게 반납됨 abort 부모 프로세스가 자식의 수행을 종료시킴 자식이 할당 자원의 한계치를 넘어섬 자식에게 할당된 테스크가 더 이사 필요하지 않음 부모가 종료하는 경우 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않음 단계적인 종료 fork() system call왼쪽은 부모, 오른쪽은 자식. 자식은 fork() 이후의 라인부터 실행 exec() system call새로운 프로그램을 덮어씌움. 부모가 자식을 만든다음에, 자식은 오른쪽의 date라는 프로그램으로 완전히 덮어씌었음 wait() system call프로세스 A가 wait() system call을 하면, 커널은 child가 종료될 때까지 프로세스 A를 slepp 시킴(block 상태) child process가 종료되면 커널은 프로세스 A를 깨움(ready 상태) exit() system call프로세스의 종료 자발적 종료 마지막 statement 수행 후에 exit() 시스템 콜 통해 프로그램에 명싱적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌 비자발적 종료 부모가 자식을 죽임 자식이 한계치 넘어서는 자원 자원 요청 자식에게 할당된 테스크가 더이상 필요하지 않음 키모드로 kill, break 친 경우 부모가 종료하는 경우 부모가 종료하기 전에 자식들이 먼저 종료됨 프로세스 간 협력 독릭접 프로세스 프로세는 각자의 주소 공간을 가지고 수행되므로 원친적으로 하나의 프로세스가 다른 프로세스의 수행에 영향을 미치지 못함 협력 프로세스 하나의 프로세스가 다른 프로세싀의 수행에 여향을 미칠 수 있음 프로세스 간 협력 메커니즘(IPC : Interprocess Communication) 메세지를 전달하는 방법 (message passing) 커널을 통해 메세지 전달 주소 공간을 공유하는 방법 (shraed memory) 서로 다른 프로세 간에도 일부 주소 공간을 공유하게하는 메커니즘 IPC Message Passing Direcit Communicaiton 통신하려는 프로세스의 이름을 명시적으료 표시 Indirecit Communicaiton mailbot or port 를 통해 메시지를 간접 전달","link":"/2018/10/04/Process%20Managemnet/"},{"title":"벽돌깨기","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRQm6qfL0DFAUo&amp;categoryId=AWXRQm6qfL0DFAUo&amp;categoryType=CODE&amp;&amp;&amp; 어려운 문제는 아니다. 방향은 잡았는데, 코드로 구현하는데 오래 걸렸다. 풀이 구슬 선택 : DFS 벽돌 깨기 : 재귀 DFS는 다음 그림과 같이 진행한다. 구슬을 쏠 수 있는 칼럼은 0, 1, 2, 3 으로 4개가 있다고 하면, 재귀는 다음 그림과 같이 구현한다. 3을 기준으로 벽돌을 깬다고 하면, 3 기준 동서남북을 체크한다. 3의 동쪽을 깨는 중에, 9가 나오기 때문에, 9 위치에서 다시 재귀 함수를 호출 한다.","link":"/2018/10/04/%EB%B2%BD%EB%8F%8C%EA%B9%A8%EA%B8%B0/"},{"title":"보물상자 비밀번호","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRUN9KfZ8DFAUo&amp;categoryId=AWXRUN9KfZ8DFAUo&amp;categoryType=CODE 쉬운 문제이다. 이 문제에서는 정렬과 진법 변환을 배울 수 있다. 풀이 회전 시키고 각 변 확인하며 리스트에 저장 개념 정렬 오름차순 정렬 : Collections.sort(list) 내림차순 정렬 : Collections.sort(list) –&gt; Collections.reverse(list) 진법 변환 string 을 radix 진법으로 변환 : Integer.parseInt(String s, int radix) 코드","link":"/2018/10/04/%EB%B3%B4%EB%AC%BC%EC%83%81%EC%9E%90%20%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8/"},{"title":"CPU Scheduling","text":"CPU and I/O Bursts in program execution 이란 ? CPU-burst time 의 분포는 ? 프로세를 분류하면 ? I/O-bound processCPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job 입니다. CPU-bound process계산 위주의 job 입니다. CPU 스케쥴링이 왜 필요한가요? IO 대기, Memory stall과 같은 CPU idle time 을 최소화하여 CPU 자원의 활용을 극대화하기 위해 필요합니다. 여러 종료의 job(process)이 섞여 있기 때문에 CPU 스케쥴링이 필요하다. CPU 스케쥴링을 위해 Ready Queue 구현은 어떻게 하나요?스케쥴링 알고리즘에 따라 FIFO, Queue, tree, Linked List 등을 사용할 수 있습니다. CPU Scheduler &amp; Dispatcher 이란 ? CPU Scheduler운영체제 안에서 CPU 스케쥴링 하는 코드입니다. Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고릅니다. DispatcherCPU의 제어권을 CPU scheduler 에해 선택된 프로세스에게 넘깁니다. 이 과정을 context switch 라고 합니다. CPU 스케쥴링이 필요한 경우는 ? running -&gt; blocked (I/O 요청하는 systemcall) running -&gt; ready (할당 시간 만료로 time interrupt) blocked -&gt; ready (I/O 완료 후 interrupt) terminate 1,4 는 nonpreemtive (강제로 빼앗지 않고 자진 반납) 입니다. Scheduling Criteria (성능 척도) system 입장 CPU utilization keep the CPU as busy as possible Throughput number of processes that complete their execution per time unit program 입장 Turnaround time amount of time to execute a particular process Waiting time amount of time a process has been waiting in the ready Response time amount of time it takes from when a request was submitted unitl the first response is produced, not output (for time-sharing environment) 최초의 CPU 얻기까지 기다린 시간 CPU 스케쥴링 알고리즘은 어떤게 있나요?First Come First Served, Shorted Job First, Priority Scheduling, Round Robin이 있습니다. FCFS (First-Come First-Served) 이란 ?먼저 온 순서대로 처리하는 알고리즘입니다. 비선점형입니다. 도착 순서 p1, p2, p3 burst time 24 / 3 / 3 wating time 0 / 24/ 27 Convoy effet short process behind long process SJF (Shorted-Job-First) 이란 ?CPU burst time이 가장 짧은 프로세스를 제일 먼저 스케쥴링합니다. 비선점형과 선점형이 있습니다. 비선점형의 경우, 일단 CPU를 잡으면 이번 CPU burst가 완료될 때까지 CPU를 선점 당하지 않습니다. 선졈형의 경우, 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU를 빼앗깁니다. 이 방법을 SRTF (Shorted-Remaing-Time-First) 라고도 부릅니다. SJF는 어떤 문제가 있나요?starvation 문제가 있습니다. CPU 사용 시간이 긴 프로세스는 거의 영원히 CPU 를 할당받을 수 없습니다. SJF에서 다음 CPU burst time을 어떻게 알 수 있나요?과거의 CPU burst time을 이용해서 추정 (exponential averaging) 합니다. Proirity Scheduling 이란 ?우선순위가 제일 높은 process에게 CPU를 먼저 주는 알고리즘입니다. 선점형 스케줄링은, 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점합니다. 비선점형 스케줄링 방식은, 더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣습니다. #####Prirority Sceduling의 문제는 뭔가요? starvation 문제가 있습니다. 낮은 우선순위의 프로세스는 CPU 를 할당받을 수 없습니다. Prirority Sceduling의 starvation 문제를 어떻게 해결해야할까요?aging을 사용합니다. 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주면 됩니다. Round Robin 이란 ?각 프로세스는 동일한 크기의 할당 시간 (time quantum) 을 가집니다. 할당 시간이 지나면 프로세스는 선점 당하고 ready queue의 제일 뒤에 가서 다시 줄을 서는 알고리즘입니다. Response time이 빠릅니다. time quantum large 하면 FCFS 와 같고, time quantum small 하면 context switch overhead가 커집니다. Multilevel Queue 란 ? Ready queue를 여러 개로 분할합니다. foreground (interactive) background (batch - no human interaction) 각 큐는 독립적인 스케쥴링 알고리즘을 가집니다. foreground - RB background - FCFS 어느 큐에 CPU를 줄지 결정하고, 그 큐 안에서 누구에게 CPU를 줄지 결정해야합니다. 큐에 대한 스케쥴링이 필요합니다. fixed priority scheduling serve all from foreground then from background Possibility of starvation time slice 각 큐에 CPU time을 적절한 비율로 할당합니다. ex) 80 % to foreground in RB , 20% to background in FCFS Multilevel Feedback Queue 란 ? 프로세스가 다른 큐로 이동 가능합니다. againg을 이와 같은 방식으로 구현 가능합니다. Multilevel Feedback Queue Scheduler를 정의하는 파라미터들 Queue의 수 각 큐의 스케쥴링 알고리즘 Process를 상위 큐로 보내는 기준 Process를 하 큐로 내쫓는 기준 프로세스가 CPU 서비스를 받으려 할 때 들어갈 큐를 결정하는 기준 할당 시간 끝나면 아래로 강등됩니다. CPU 사용 시간이 짧은 프로세스에게 우선 순위를 많이 줍니다. Multiple-Processor Scheduling 이란 ?CPU가 여러개인 경우 Homogeneous process인 경우 Queue에 한 줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있음 반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더 복잡해짐 Load sharing 일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요 별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법 Sysmmetric Multiprocessing (SMP) 각 프로세서가 각자 알아서 스케쥴링 결정 Asysmmetric Multiprocessing 하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름 Real-Time Scheduling 이란 ? Hard real-time systems 정해진 시간 안에 반드시 끝내도록 스케쥴링해야 함 Soft real-time systems 일반 프로세스에 비해 높은 priority를 갖도록 해야 함 Thread Scheduling 이란 ? Local Scheduling User level thread의 경우 사용자 수준의 thread library에 의해 어떤 thread를 스케쥴할지 결정 Global Scheduling Kenel level thread의 경우 일반 프로세스와 마찬 가지로 커널의 단기 스케쥴러가 어떤 thread를 스케쥴할지 결정 Algorithm Evaluation Queueing models server가 CPU, 확률 분포로 주어지는 arrivate rate와 service rate 등을 통해 각종 performance index 값을 계산 Implemetatation(구현) &amp; Measurement(성능 측정) 실제 시스템에 알고리즘을 구현하여 실제 작업에 대해서 성능을 측정 비교 Simulation (모의 실험) 알고리즘을 모의 프로그램으로 작성후 trace(input data) 를 입력으로 하여 결과 비교 reference이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323)","link":"/2018/10/06/CPU%20Scheduling/"},{"title":"Process Sysncronization","text":"데이터의 접근데이터를 읽어와서 연산하고 다시 저장합니다. Race ConditionS-box를 공유하는 E-box가 여럿 있는 경우 Race Condition의 가능성이 있습니다.ex) 커널 모드 수행 중 인터럽트로 커널모드 다른 루틴 수행시 race condition (1/3) kernel 수행 중 인터럽트 발생 커널모드 running 중 inetrrupt 발생하여 인터럽트 처리 루틴이 수행 양쪽 다 커널 코드이므로 kernel address space 공유 race condition (2/3)해결책 : 커널 모드에서 수행 중일 때는 CPU를 preempt 하지 않음. 커널 모드에서 사용자 모드로 돌아 갈때 preempt. race condition (3/3) CPU가 여러개인 경우 해결 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 lock / unlock을 하는 방법 한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법 Process Syncronization 문제 공유 데이터의 동시 접근은 데이터의 불일치 문제 발생시킬 수 있음 일관성 유지를 위해서 협력 프로세스간의 실행순서를 정해주는 매커니즘 필요 Race condition 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라다라짐 이를 막기 위해 concurrent processsms 동기화 되어야한다. The Critical-Section ProblemCritical-Section은 공유 데이터를 접근하는 코드입니다. n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 ciritical sectoin이 존재 하나의 프로세스가 ciritical section에 있을 때 다른 모든 프로세스는 ciritical section에 들어갈 수 없어야한다. 프로그램적 해결법의 충족 조건 Mutual Exclution 프로세스가 pi가 critical section 부분을 수행중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안된다. Progress 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다. Bounded Wating 프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다. 알고리즘 1P0 int turn ; initially turn=0; (turn이 0 : 0번 프로세스 차례) P0이 빈번히 들어가고 싶으면? 알고리즘 2boolean flag[2]; initially flag[모두] =false; // no one is in CS Pi ready to enter its critical section if flag[i] == true 들어가기전에 둘다 깃발을 들으면 아무도 못들어가. 알고리즘3 (Peterson’s Algorithm) Busy Wating (spin lock) 내가 CPU를 잡고 while문에 있는데, 그때 다른 애가 CPU를 잡으면 ? Sysnchnization Hardware 하드웨어적으로 Test &amp; modify를 atuomic하게 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결 값을 읽어내고 바꾸는 과정을 한번에 Lock이 뭔가요?동시에 공유 자원에 접근하는 것을 막기 위해 Critical Section 에 진입하는 프로세스는 Lock 을 획득하고 Critical Section을 빠져나올 때, Lock을 방출함으로써 동시에 접근이 되지 않도록 합니다. 세마포어가 뭔가요?크리티컬 섹션 문제를 해결하고 멀티 프로세싱 환경에서 프로세스 동기화를 이루기 위해 사용되는 Interger 변수입니다. Counting 세마포어와 Binary 세마포어가 있습니다. Counting 세마포어는 가용한 개수를 가진 자원 에 대한 접근 제어용으로 사용되며, 그 가용한 자원의 개수로 초기화 됩니다. 자원을 사용하면 세마포어가 감소, 방출하면 세마포어가 증가합니다. Binaray 세마포어는 0 과 1 사이의 값만 가능합니다. P 연산과 V 연산이 뭔가요P 연산은 공유자원을 획득하는 연산(Wait Function)이고, V 연산은 공유자원을 반납하는 연산(Signal Function)입니다. 프로세스 동기화를 이루기 위해, 크리티컬 섹션은 P 연산과 V 연산으로 둘러싸여 있습니다. 뮤텍스와 세마포어는 어떤 차이인가요?구현 둘의 목적이 다릅니다. 뮤텍스는 locking mechanism 이고 세마포어는 signaling mechanism 입니다.뮤텍스 : 오직 하나의 테스크만이 뮤텍스를 획득할 수 있습니다.세마포어 : “I am done, you can carry on” kind of signal . Critical Section of n Processes Block / Wakeup Impemetation block 커널은 block을 호출한 프로세스를 suspend 시킴 이 프로세스의 PCB를 semaphore에 대한 wait queue에 넣음 wakeup(P) block 된 프로세스 P를 wakeup 시킴 이 프로세스의 PCB를 ready queue로 옮김 Implementation busy-wati vs block/wakeupCS 길이가 긴 경우 Block/Wakeup이 적당합니다. CS 길이가 매우 짧은 경우 Block/Wakeup 오버헤드가 busy-wait 오버헤드보다 더 커질 수 있습니다. 일반적으로 block/wakeup 방식이 더 좋습니다. Deadlock and Starvation Deadlock 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상 P0와 P1은 S와 Q 모두가 필요하다. P0가 S를 차지했을 때, P1이 CPU를 가져가버리면, Deadlock 발생 Starvation indefinite blocking. 프로세스가 suspend된 이유에 해당하는 세마포어 큐에서 빠져나갈수 없는 현상 Bounded-Buffer ProblemProducer-Consumer Problem 주황색은 Producer가 생성한다. 생산자 둘이 한 위치에 생성하면? 하나를 소비자 둘이 동시에 소비 하려고 하면? 비버있는 버퍼가 없는데 또 생산자가 만들려고 하면? Syncrhonization variables mutual exclution need binary semaphore (shared data의 mutual exlusion을 위해) lock 걸고 풀고 resource count need integer semaphore (남은 full/empty buffer의 수 표시) 자원 개수 semaphore full =0, empty =n, mutex =1; Produer 빈 버퍼가 있으면 버퍼 획득하고, 버퍼에 락 걸고, 버퍼에 데이터 넣고, 버퍼에 락 풀고, full++ Consumer 내용이 들어잇는 버퍼 있으면, 버퍼에 락 걸고, 버퍼에서 데이터 빼고, 버퍼 락 풀고, empty ++ Readers-Writes Problem한 process가 DB에 write 중일 때 다른 process가 접근하면 안됨 / read는 동시에 여럿이 해도 됨 Shared data DB 자체 int readcount=0; //현재 DB에 접근 중인 Reader의 수 Sysncronization variablees semaphore mutex =1 ( 공유변수 readcount를 접근하는 코드의 mutual exlution 보장), db=1; Dining-Philosophers Problem배가 고파지면 자기의 왼쪽과 오른쪽에 놓아져 있는 젓가락을 잡음 문제 모두다 왼쪽 젓가락을 잡아버리면? Deadlock 해결 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 젓가락을 두개 모두 집을 수 있을 때에만 젓가락을 잡을 수 있도록 (아래의 경우) 비대칭. 짝수 철학자는 왼쪽 젓가락부터 집도록 enum {thinking, hungry, eating} state[5]; semaphore self[5]=0; // 동시에 젓가락 두개 모두 잡을 수 있는 권한 semaphore mutex=1; Monitor Semaphore의 문제점 코딩이 힘들다 정확성의 입증이 어려움 자발적 협력이 필요 한번의 실수가 모든 시스템에 영향 동시 수행중인 프로세스 사이에서 abstract data type의 안전한 공유를 보장하기위한 high-level syncronization construct 모니터 내에서는 한번에 하나의 하나의 프로세스만이 활동 가능 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요 없음 프로세스가 모니터 안에서 기다릴수 있도록 하기 위해 condition variable 사용. condition x, y condition variable 은 wait와 signal 연산에 의해서만 접근 가능 x.wait(); x.wait()을 invoke한 프로세스는 다른 프로세스가 x.signal()을 invoke 하기 전까지 suspend x.siganl(); x.signal()은 정확하게 하나의 suspend된 프로세스를 resume한다. Suspend된 프로세스가 없으면 아무 일도 일어나지 않는다. reference이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323)","link":"/2018/10/06/Process%20Synchronization/"},{"title":"줄기세포배양","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRJ8EKe48DFAUo&amp;categoryId=AWXRJ8EKe48DFAUo&amp;categoryType=CODE 풀이 전체 map size를 450 * 450 으로 하고 초기 위치를 i+175, j+175로 하였다. ( 왜?? ) 생명력을 저장하고, 활성 상태를 체크하기 위해 map(450)(450)(0) 에는 생명력을, map(450)(450)(1) 에는 생명력*2를 저장한다. map(450)(450)(1) &lt; map(450)(450)(0) 이 되면 활성상태가 되므로, 확장시킨다. 생명력 수치가 높은 줄기 세포를 먼저 확장 시키기 위해, 생명력에 따른 Queue를 저장하는 배열을 생성한다. arr[1] : 생명력이 1인 줄기 세포의 좌표를 저장하는 Queue arr[2] : 생명력이 2인 줄기 세포의 좌표를 저장하는 Queue … arr[10] : 생명력이 10인 줄기 세포의 좌표를 저장하는 Queue 생명력이 10인 큐 ~ 생명력이 1인 큐를 순차적으로 확인한다. 큐에 저장되어 있는 줄기세포를 하나씩 remove하여 활성화되어있는지 체크하여 확장한다.","link":"/2018/10/07/%EC%A4%84%EA%B8%B0%EC%84%B8%ED%8F%AC%EB%B0%B0%EC%96%91/"},{"title":"특이한 자석","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeV9sKkcoDFAVH 풀이 현재 톱니 바퀴 기준으로 왼쪽과 오른쪽 확인 각 톱니바퀴 회전 결과 값 계산 1번부터 다시","link":"/2018/10/07/%ED%8A%B9%EC%9D%B4%ED%95%9C%20%EC%9E%90%EC%84%9D/"},{"title":"Deadlock","text":"출처 : 이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323) Deadlock 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태 자원 하드웨어, 소프트웨어 등을 포함하느 개념 ex) I/O device, CPU cycle, memory space, semaphore 등 예시 시스템 2개의 tape drive가 있다 프로세스 P1과 P2 각각이 하나의 tape drive 를 보유한 채 다른 하나를 기다리고 있음 Deadlock 발생의 4가지 조건 Mutual Exlusioin 매 순간 하나의 프로세스만이 자원을 사용할 수 있음 No Preemption 프로세스는 자원을 스스로 내어놓을 뿐 강제로 뺏기지 않음 Hold and wiat 자원을 가진 프로세스가 다른 자원을 기달리때 보유 자원을 놓지 않고 계속 가지고 있음 Circular wait 자워을 기다리는 프로세스 간에 사이클이 형성되어야 함 P0은 P1이 가진 자원을 기다림 P1은 P2가 가진 자원을 기다림 .. 자원 할당 그래프 자원에서 프로세스쪽으로 나가는 화살표 이 프로세스가 이 자원을 가지고 있다. 프로세스에서 자원쪽으로 나가는 화살표 이 프로세스가 이 자원을 요청 자원 안에 동그라미 자원 개수 그래프 안에 cycle이 없으면 deadlock이 아니다 cycle이 있으면 자원당 인스턴스가 하나밖에 없으면, 데드락 자원의 인스턴스가 여러개면, 데드락수도 있고 아닐수도 있고 왼쪽은 데드락, 오른쪽은 데드락이 아님 Deadlock Prevention자원 할당시 Deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것 Mutual Exclusion 공유해서는 안되는 자원의 경우 반드시 성립해야함 Hold and wait 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청 No preemption 빼앗아 올수 있게 하면 됨 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다. Circular Wait 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로 자원 할당 Deadlock Avoidance자원 요청에 대한 부가적인 정보를 이용해서 데드락의 가능성이 없는 경우에만 자원 할당. 데드락으로부터 항상 safe한 상태를 유지. 자원 요청에 대한 부가정보를 이용해서 자원 할당이 데드락으로부터 safe한지를 동적으로 조사해서 안전한 경우에만 할당. 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언 Single instance per resouce types Resource Allocation Graph algorithm Multiple instance per resouce types Banker’s Algorithm Resource Allocation Graph algorithm자원 당 인스턴스 하나 데드락의 위험성이 있으면 애초부터 자원을 내주지 않음. 점선 화살표 : 이 프로세스가 평생 적어도 한번 이 자원을 사용할 것이다. Banker’s Algorithm자원 당 인스턴스 여러개 5개의 프로세스 : P0 P1 P2 P3 P4 A자원 인스턴스 10개 B자원 인스턴스 5개 C자원 인스턴스 7개 Allocation 0번 프로세스는 현재 A 0개 / B 1개 / C 0개 할당되어 있음 Available 현재 가용 자원 아무도 사용하지 않고 남아 있는 자원 Max 이 프로세스가 시작될 때, 이 프로세스가 평생 최대로 사용할 자원 개수를 선언했음 Need 추가로 요청 할 수 있는 양 이 알고리즘은 프로세스가 자원을 요청했을 때, 이 요청을 받아들일것인지 결정하는 것임 프로세스가 최대(Need)로 요청할 것을 가정한다. 그리고 이게 가용 자원으로 가능한지 체크. 가용자원으로 가능하지 않으면 요청을 거절. P0는 7 4 3 으로 요청할것이다. 이게 3 3 2 로 커버 가능? NO. 요청 거절. Deadlock Detection and recoveryDeadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발생시 recover Single instance per resouce types Resource Allocation Graph algorithm cycle이 곧 데드락 Multiple instance per resouce types Banker’s Algorithm과 유사한 방법 활용 Recovery Process Termination abort all deadlocked processes(한꺼번에) 데드락에 연루된 프로세스드을 하나씩 죽여봄. 여전히 데드락이면 또 하나의 다른 프로세스 죽여봄. Resource Preemption 데드락에 연루된 프로세스로부터 자원을 뺏음 safe state로 roolback하여 prcess를 restart Deadlock IgnoranceDeadlock을 시스템이 책임지지 않음 UNIX를 포함한 대부분의 OS가 채택 데드락이 일어나지 않는다고 생각하고 아무런 조치 취하지 않음","link":"/2018/10/09/Deadlock/"},{"title":"Memory Management","text":"Logical vs Physical Address Logical address (=virtual address) 프로세스마다 독립적으로 가지는 주소 공간 각 프로세스마다 0번지 부터 시작 CPU가 보는 주소는 logical address임 physical address 메모리에 실제 올라가는 위치 주소바인딩 : 주소를 결정하는 것 Symbolic address -&gt;Logical Address -&gt; Physical address Address Binding 컴파일 타임 바인딩이나 로드 타임 바인딩 모두 실행될때 물리주소가 결정되지만, 런타임 바인딩은 실행 이후에도 물리 주소가 바뀔 수 있다. 소스코드 : A위치에 있는 값과 B위치에 값을 더해서 A에 저장해라. C위치로 점프해라 Compile time binding 물리적 메모리 주소가 컴파일 시 알려짐 시작 위치 변경시 재컴파일 컴파일러는 절대코드(absolute code) 생성 Load time binding Loader의 책임 하에 물리적 주소 부여 컴파일러가 재배치가능코드를 생성하는 경우 가능 Execution time binding(run time binding) 수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음 CPU가 주소를 참조할 때마다 binding을 점검 하드웨어적인 자원이 필요 (base and limit registers, MMU) Memory-Management Unit (MMU)logical address를 physical address로 매핑해 주는 hardware device MMU scheme 사용자 프로세스가 CPU에서 수행되며 생성해내는 모든 주소값에 대해 base regiseter(relocation register)의 값을 더한다. user program logical address만을 다룬다 실제 physical address를 볼수 없으며 알 필요가 없다. Dynamic Relocation CPU가 프로세스 p1의 346번지를 요청한 상태. 프로세스1은 물리주소 14000번지에 올라가있음. 논리주소에 시작위치(relocation register)를 더해서 14346 구함. 한가지 더 체크하는 것은? 프로세스 p1의 크기를 limit register가 가지고 있어. CPU가 남의 프로그램의 메모리를 보려고 하는 시도를 막을 수 있음. limit register : CPU가 요청하는 논리주소가 프로그램 크기보다 큰 논리 주소를 요청한 것은 아닌지 먼저 체크 Dynamic Loading프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load 하는 것 memory utilization 향상 가끔씩 사용되는 많은 양의 코드의 경우 유용 (ex) 오류 처리 루틴 운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능 (OS는 라이브러리를 통해 지원 가능) Loading : 메모리로 올리는 것 Overlays메모리에 프로세스 부분 중 실제 필요한 정보많을 올림 프로세스의 크기가 메모리보다 클 때 유용 운영체제의 지원없이 사용자에 의해 구현 작은 공간의 메모리를 사용하던 초창기 시스템에서 수작으로 프로그래머가 구현 Manual Overlay 프로그램이 매우 복잡 Swapping프로세스를 일시적으로 메모리에서 backing store로 쫓아내는것 backing store (swap area) 디스크 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간 Swap in / Swap out 일반적으로 중기 스케쥴러에 의해 swap out 시킬 프로세스 선정 CPU 우선순위가 낮은 프로세스를 swapped out 시킴 Compile time 혹은 Load time binding 에서는 원래 메모리 위치로 swap in 해야함 Execution time binding 에서는 추후 빈 메모리 영역 아무 곳에서나 올릴 수 있음 swap time은 대부분 transfer time (swap 되는 양에 비례하는 시간) 임 Dynamic LinkingLinking : 여러 군데 존재하던 컴파일된 파일들을 묶어서 실행 파일 만드는 것 static linking 라이브러리가 프로그램의 실행 파일 코드에 포함됨 실행 파일의 크기가 커짐 동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비 (ex. printf 함수의 라이브러리 코드) dynamic linking 라이브러리가 실행시 연결됨 라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 줌 (라이브러리 위치 찾을 수 있는) 라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴 운영체제의 도움이 필요 Allocation of Physical Memory 메모리는 일반적으로 두 영역으로 나뉘어 사용 OS 상주 영역 interrupt vector와 함께 낮은 주소 영역 사용 사용자 프로세스 영역 높은 주소 영역 사용자 프로세스 영역의 할당 방법 Contiguous allocation 각각의 프로세스가 메모리의 연속적인 공간에 적재되록 하는 것 고정분할방식 / 가변분할방식 Noncontiguous allocation 하나의 프로세스가 메모리 영역에 분산되어 올라 갈수 있음 Paging / Segmentaion / Paged Segmentation Contiguous Allocation 고정 분할 방식 물리적 메모리를 몇 개의 영구적 분할(partition) 로 나눔 분할의 크기가 모두 동일한 방힉과 서로 다른 방식이 존재 분할당 하나의 프로그램 적재 융통성 없음 동시에 메모리에 load되는 프로그램의 수가 고정됨 최대 수행 가능 프로그램 크기 제한 internal fragmentation, external fragmentation 발생 가변 분할 방식 프로그램이 실핼될때마다 차곡차곡 메모리에 올려 프로그램의 크기를 고려해서 할당 분할의 크기, 개수가 동적으로 변함 기술적 관리 기법 필요 external fragmenation 발생 Hole 가용 메모리 공간 가변분할 방식에서 생김 다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음 프로세스가 도착하면 수용 가능한 hole을 할당 운영체제는 다음의 정보를 유지 할당공간(프로그램이 사용하고 있는) 가용공간(hole) Dynamic Storage-Allocation Problem 가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제 First-fit Size가 n이상인 것 중 최초로 찾아지는 Hole에 할당 Best-fit Size가 n이상인 가장 작은 hole을 찾아서 할당 hole들의 리스트가 크기 순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야함 많은 수의 아주 작은 hole들이 생성됨 Worst-fit 가장 큰 hole에 할당 역시 모든 리스트를 탐색해야함 상대적으로 아주 큰 hole들이 생성됨 Compaction external fragmentation 문제를 해결하는 방법 사용 중인 메모리 영역을 한구데로 몰고 hole들을 다 한곳으로 몰아 큰 block을 만드는 것 매우 큰 비용이 드는 방법 프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행될 수 있음 Paging Process의 virtual memory를 동일한 사이즈의 page 단위로 나눔 virtual memory의 내용이 page 단위로 noncontiguous하게 저장됨 일부는 backing storage에 일부는 physical memory에 저장 Basic method physical memory를 동일한 크기의 frame으로 나눔 logical memory를 동일 크기의 page로 나눔 (frame과 같은 크기) 모든 가용 frame들을 관리 page table을 사용하여 logical address를 physical address로 변환 external fragmentation 발생 안함 internal fragmentation 발생가능 page table 페이지들이 물리적인 메모리 어디에 올라가 있나 logical memory의 page 개수 만큼 entry 가 존재 logical address p : page 번호 d: 그 페이지 내에서 얼만큼 떨어져 있나 Implementation of Page Table Page table은 main memory 에 상주 Page table base register (PTBR) 가 page table을 가리킴 Page table length register (PTLR) 가 테이블 크기를 보관 모든 메모리 접근 연산에는 2번의 memory access 필요 page table 접근 1번 실제 data/instruction 접근 1번 속도 향상을 위해 associative register / translation look-aside buffter(TLB) 라 불리는 고속의 lookup hardware cache 사용 Paging Hardware with TLB 주소 변환을 위한 케쉬 메모리. 빈번히 참조되는 엔트리 몇개 만을 가지고 있음. 전체 항목을 검색해야봐야함. 여기 어디에도 없으면 page table을 봄 TLB에서 전체 항목을 다 검색해야하기 때문에, parallel search로 빠르게 함. 병력적으로 한번에 쫙 검색함. Two-Level Page Table page table이 2단계. 속도는 더 걸림. page table을 위한 공간은 줄어듦. 주소공간에서 실제로 사용되지 않는 페이지에 대해서는 안쪽 테이블이 안만들어져. p1 10bit outer page table의 index p2 10bit outer page table의 page에서의 변위(displacement) Multilevel Paging and PerformanceAddress space가 더 커지면 다단게 페이지 테이블이 필요. 각 단계의 페이지 테이블이 메모리에 존재하므로 logical address의 physical address 변환에 더 많은 메모리 접근 필요. TLB를 통해 메모리 접근 시간을 줄일 수 있음. Valid / Invalid Bit in a Page Table protection bit page에 대한 접근 권한 (read /write / read-only) valid 해당 주소의 frame에 그 프로세스를 구성하는 유요한 내용이 있음 invalid 프로세스가 그 주소 부분을 사용하지 않는 경우 해당 페이지가 메모리에 올라와 있지 않고 swap area에 있는 경우 Inverted Page Table Page table이 매우 큰 이유 모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry 존재 대응하는 page가 메모리에 있든 아니든 간에 page table에는 entry로 존재 inverted page table Page frame 하나당 page table에 하나의 entry를 둔것 각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시 (process-id, process의 logical address) page frame 개수만큼 entry 존재. entry 전부 검색해서 pid랑 p 찾아야함. associative registe 찾아서 병렬 검색을 함 단점 테이블 전체를 탐색 조치 associative register 사용 (expensive) Shared Page 공유할 수 있는 코드는 같은 프레임으로 매핑 시켜서 메모리에 한 카피만 올려 Shared code Re-entrant Code (= Pure code) read-only 로 하여 프로세스 간에 하나의 code만 메모리에 올림 (eg, text editords, compilers, window systems) Shared code는 모든 프로세스의 logical address space에서 동일한 위치에 있어야함 위 그림에서, ed1, 2, 3 순으로 되어야 함 Private code and data 각 프로세스들은 독자적으로 메모리에 올림 private data는 logical addreess space 의 아무 곳에 와도 무방 Segmentation 프로그램은 의미 단위인 여러 개의 segment로 구성 작게는 프로그램을 구성하는 함수 하나하나를 세그먼트로 정의 크게는 프로그램 전체를 하나의 세그먼트로 정의 가능 일반적으로 code, data, stack 부분이 하나씩 세그먼트로 정의됨 Segment는 의미 단위 이기 떄문에 공유와 보안에 있어서 paging 보다 효과적 Segment의 길이가 동일하지 않으므로 가변 분할 방식에서와 동일한 문제점들이 발생 Logical address는 다음의 두가지로 구성 &lt;segment-number, offset&gt; Segment table each table entry has base : starting physical address of the segment limit : length of the segment Segment-table base reigster (STLR) 물리적 메모리에서의 segment table의 위치 Segment-table length reigster (STLR) 프로그램이 사용하는 segment의 수 체크 세그먼트 번호가 STLR 보다 작은지 체크해야함 세그먼트의 길이보다 세그먼트안에서 떨어진 offset 값이 더 크지는 않은가 Segmentation Example 다섯 개의 segment. 각각의 세그먼트에 대해서 주소 변환을 위한 테이블이 있음 Sharing of Segments 0번 세그먼트는 같은 역할을 하는 세그먼트. 이 두 개의 세그먼트는 같은 물리주소에 올라감. 1번 세그먼트는 다른 물리주소에 올라감. Segmentation with Paging 세그먼트 하나가 여러개의 페이지로 구성 먼저 세그먼트에 대해 주소 변환 logical address : 세그먼트 번호와 세그먼트 안에서 얼마나 떨어있는지 STBR에 세그먼트 시작 위치가들어있고, 거기서부터 위에서부터 s번째 엔트리에 가면 page table의 시작 위치가 나옴 세그먼트의 길이보다 세그먼트 안에서 떨어진 offset이 크다면 잘못된 요청 d는 page 번호와 page 안에서 얼마나 떨어져 있는지 (p, d`) page table의 시작 위치로부터 page 번호 만큼 떨어진 엔트리에 가면 이 페이지에 대한 주소 변환 결과 (물리적인 메모리의 몇번째 프레임인지) 나와 pure segmentation 과 차이점 segment-table entry가 segment의 base address를 가지고있는 것이 아니라, segment를 구서하는 page table의 base address를 가지고 있음 주소 변환을 위한 OS의 역할어떤 프로세스가 CPU를 가지고 메모리 접근을 하는데, 주소 변환을 할 때 마다 운영체제가 중간에 개입하면 CPU가 이 프로세스로부터 운영체제에게 넘어가야돼. 주소 변환 다 했으니까 다시 CPU가 이 프로세스에게 넘어온다? 말이 안돼. 주소 변환은 무조건 하드웨어적으로 일어남. IO 장치에 접근하려면 OS가 끼어들어야돼. reference이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323)","link":"/2018/10/09/Memory%20Management/"},{"title":"탈주범 검거","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpLlKAQ4DFAUq 소요시간 1시간. BFS 문제이다. 쉬운 문제이다. Queue에 넣어야 하는 경우의 수의 조건에서 시간이 오래 걸렸다. 더럽게 코드를 작성했다. 더 나은 방법은 없을까? 풀이 map에 터널 상태를 저장한다. 현재 위치에서 이동 가능한 위치를 큐에 넣는다. (이동 가능한 위치는 터널 상태를 보고 파악한다) 큐에서 pop한 위치에서 2번을 반복한다. depth가 문제에서 주어진 시간이 되었을 때, 큐에 넣었던 위치 개수를 출력한다.","link":"/2018/10/09/%ED%83%90%EC%A3%BC%EB%B2%94%20%EA%B2%80%EA%B1%B0/"},{"title":"활주로 건설","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeW7FakkUDFAVH 경우의 수를 나눈 후 조건에 맞게 짜려고 하였다. 해설을 보고 DFS로 풀면 쉽게 풀 수 있다는 것을 알았다. 풀이 모든 행과 열을 차례대로 체크한다. 현재 위치와 다음 위치를 비교한다. 같은 높이인 경우 : 다음 위치 부터 체크 오르막인 경우 : 현재 위치 기준해서 왼쪽으로 경사로 둘 수 있는지 체크 내리막인 경우 : 현재 위치 기준해서 오른쪽으로 경사로 둘 수 있는지 체크 그 이외의 경우 : 이번 행이나 열은 실패 코드","link":"/2018/10/09/%ED%99%9C%EC%A3%BC%EB%A1%9C%20%EA%B1%B4%EC%84%A4/"},{"title":"Virtual Memory","text":"출처 : 이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323) Demand Paging 실제로 필요할 때 page를 메모리에 올리는 것 I/O양의 감소 Memory 사용량 감소 빠른 응답 시간 더 많은 사용자 수용 Valid / Invalid bit의 사용 Valid 사용되지 않는 주소 영역인 경우 페이지가 물리적 메모리에 없는 경우 처음에는 모든 page entry 가 invalid로 초기화 address translation 시에 invalid bit이 set되어 있으면 “page fault” 요청한 페이지가 메모리에 없는 경우 운영체제가 CPU를 가지고 fault난 페이지를 메모리에 올림 Page Fault요청한 페이지가 메모리에 없는 경우입니다. page fault가 나면 운영체제는 fault난 페이지를 메모리에 올립니다. invalid page를 접근하면 MMU가 trap을 발생시키고 (page fault trap) Kernel mode로 들어가서 page fault handler 가 invoke 됨 다음과 같은 순서로 page fault 를 처리 invalid reference? (eg. bad address, protection violation) =&gt; abort process 잘못된 요청인지 아닌지 체크하는 것 get an empty page frame (replace : 없으면 뺏어온다) 해당 페이지를 disk 에서 memory로 읽어온다 disk I/O가 끝나기까지 이 프로세스는 CPU를 preempt 당함 (block) Dist read가 끝나면 page tables entry 기록, valid/invalid bit = “valid” ready queue에 process를 insert -&gt; dispatch later 이 프로세스가 CPU를 잡고 다시 running 아까 중단되었던 instruction 재개 Page Replacementpage fault 가 났을 때, 원하는 페이지를 backing area에서 가져오게 됩니다. 만약, 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 일어나야합니다. Page replacement 어떤 frame을 빼앗아 올지 결정 곧바로 사용되지 않을 page를 쫗아내는 것이 좋음 동일한 페이지가 여러번 메모리에서 쫓겨났다가 다시 들어올 수 있음 Replacement Algoritm page fault rate을 최소화 하는 것이 목표 알고리즘을 평가 : 주어진 page reference string에 대해 page fault를 얼마나 내는지 조사 Optimal Algorithm 미래에 참조되는 페이지들을 미리 다 안다고 가정 : Offiline algorithm 가장 먼 미래에 참조되는 페이지를 replace 네모칸 : 메모리 빨간색 : 페이지 폴트 난 경우 연보라 : 페이지 폴트 나지 않고 이미 메모리에 올라가 있는 경우 5번이 처음으로 참조 되는 경우 1번이 바로 다음으로 참조되기 때문에, 메모리에서 쫓겨나지 않아 4번이 가장 먼 미래에 참조되기 때문에, 4번이 쫓겨나 FIFO Algorithm 메모리에 먼저 들어온 것을 먼저 내쫓음 FIFO Anomaly : 메모리 크기 들어나면 성능이 안좋아져 LRU(Least Recently Used) Algorithm 가장 오래전에 참조된 것을 지움 5번이 처음으로 참조 되는 경우를 보면, 2번이 가장 최근에 참조 그 다음에 1번, 4번 가장 오래 전에 참조된 것이 3번 LFU (Least Frequently Used) Algorithm참조 횟수가 가장 적은 페이지를 지움 최저 참조 횟수인 page가 여럿 있는 경우 여러 page 중 임의로 선정 선능 향상을 위해 가장 오래 전에 참조된 page를 지우게 구현할 수도 있다 LRU / LFU 비교 LRU 1번이 가장 오래 전에 참조되긴 했지만, 과거에 많은 참조가 있었다는 것을 무시 LFU 비록 4번이 참조횟수가 한 번이지만 이제 막 참조가 시작되는 걸 쫓아냄 LRU / LFU 구현 LRU 어떤 페이지가 참조될 때마다 그 페이지를 제일 아래 쪽에 매달고 쫓아낼 때는 제일 위에 있는걸 쫓아내 LFU 참조 횟수 1이 늘어나면 비교를 해서 어디까지 내려갈 수 있는지 체크 (min-heap으로 구현) Caching 캐슁 기법 한정된 빠른 공강(cache)에 요청된 데이터를 저장해 두었다가 후속 요청히 캐쉬로부터 직접 서비스 paging sytem 외에도 cache memory, buffer caching, Web caching등 다양한 분야에 사용 시간 제약 교체 알고리즘에서 삭제할 항목을 결정하는 일에 지나치게 많은 시간이 걸리는 경우 실제 시스템에서 사용할 수 없음 Buffer caching 이나 Web caching인 경우 O(1) 에서 O(logn) 정도까지 허용 Pagin System 인 경우 page fault 인 경우에만 OS가 관여 페이지가 이미 메모리에 존재하는 경우 참조 시각등의 정보를 OS가 알 수 없음 O(1)인 LRU의 list 조작 조차 불가능 Paging System에서 LRU, LFU 가능한가? page fault가 발생하면, trap 발생하여 CPU 제어권이 OS에게 넘어가 OS가 LRU 알고리즘을 사용한다면, OS가 가장 오래 전에 참조된 페이지를 알 수 있는가? NO OS가 LFU 알고리즘을 사용한다면, OS가 가장 참조 횟수가 적은 페이지를 알 수 있는가? NO 프로세스가 요청한 페이지가 이미 메모리에 올라와있으면 운영체제에게 CPU가 넘어가지 않고 하드웨어적으로 주소 변환해서 CPU가 바로 읽어들여 그러면 이 페이지의 접근 시간을 운영체제는 몰라 Clock Algorithm LRU의 근사 알고리즘 여러 명칭 Second chance algorithm NUR ( Not Used Recently) NRU ( Not Recently Used) Reference bit을 사용해서 교체 대상 페이지 선정 (circular list) Reference bit가 0 인 것을 찾을 때 까지 포인터를 하나씩 앞으로 이동 포인터 이동하는 중에 reference bit 1은 모두 0으로 바꿈 reference bit 이 0인 것을 찾으면 그 페이지를 교체 한 바퀴 되돌아와서도 (second chance) 0이면 그때에는 replace 당함 자주 사용되는 페이지라면 second chance가 올 때 1 개선 reference bit과 modified bit (dirty bit)을 함께 사용 reference bit ==1 : 최근에 참조된 페이지 modified bit == 1 : 최근에 변경된 페이지 ( I/O를 동반하는 페이지 ) 사각형 페이지 프레임 물리적인 메모리에 들어있는 페이지 reference bit가 1이면 최근에 참조되 페이지이기 때문에 0으로 바꾸고 다음으로 넘어가 어떤 페이지를 쫓아내야하는데, modified bit가 1이면 그 페이지는 메모리에 올라온 이후로 적어도 한 번은 CPU에서 write를 한것. 내용을 수정한 것. 이 페이지를 메모리로부터 쫓겨낼 때는 backing store에 수정된 내용을 반영하고 쫓아내. Page Frame의 Allocation각 프로세스에 얼만큼의 page frame을 할당할 것인가. Equal allocation 모든 프로세스에 똑같은 개수 할당 Proportional allocation 프로세스 크기에 비례하여 할당 Priority allocation 프로세스의 priority 에 따라 다르게 할당 Global vs Local Replacement Globlal replacement 다른 프로그램의 페이지도 쫓아낼 수 있음 replace 시 다른 프로세스에 할당된 frame을 빼앗아 올 수 있다 프로세스별 할당량을 조절하는 또 다른 방법 FIFO, LRU, LFU 등의 알고리즘을 globla replacement 사용시에 해당 working set / PFF 알고리즘 사용 Local replacement 자신에게 할당된 frame 내에서만 replacement FIFO, LRU, LFU 등의 알고리즘을 프로세스 별로 운영시 Thrashing 프로세스의 원활한 수행에 필요한 최소한의 page frame 수를 할당 받지 못한 경우 발생 pafe fault rate이 매우 높아짐 CPU utilization이 매우 낮아짐 OS는 MPF (Multiprogramming degree)를 높여야 한다고 판단 또 다른 프로세스가 시스템에 추가됨 (higher MPD) 프로세스 당 할당된 프레임의 수가 더욱 감소 프로세스는 페이지의 swap in / swap out 으로 매우 바쁨 대부분의 시간에 CPU는 한가함 low throughput x 축 지금 메모리에 올라와있는 프로그램의 개수 프로그램 하나만 올라가 있으면 CPU utilizaiton이 낮아 =&gt; IO를 하러 가면, CPU는 놀아 계속해서 메모리에 올라와있는 프로그램의 개수 올리면 thrashing 발생 CPU가 인스트럭션 수행하려고 하면 그 페이지게 메모리에 없어서 IO를 해 또 다른 프로그램에게 CPU가 넘어가 또 요청한 페이지가 메모리에 없어서 IO를 해 Working-Set model Locality of reference 프로세스는 특정 시간 동안 일정 장소만을 집중적으로 참조 집중적으로 참조되는 해당 page들의 집합을 locality set이라 함 working set model locality에 기반하여 프로세스가 일정 시간 동안 원활하게 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 page들의 집합을 working set 이라 정의함 working set 모델에서는 process의 working set 전체가 메모리에 올라와 있어야 수행되고 그렇지 않을 경우 모든 frame을 반납한 후 swap out(suspend) thrashing을 방지 multiprogramming degree를 결정 Working-Set Algorithm Working set의 결정 Wokring set window를 통해 알아냄 과거 델타 시간(window) 동안 참조된 페이지들을 working set이라 간주해서 쫓아내지 않고 메모리에 유지 참조된 후 델타 시간 동안 해당 Page를 메모리에 유지한 후 버림 PFF (Page-Fault Frequency) Scheme 현재 시점에 page fault 얼마나 났는지 직접 봐. 프로그램이 pafe fault 얼마나 내는지 봐. 이 프로그램이 pafe fault 많이 내고 있으면, 이 프로그램의 working set이 메모리에 보장되고 있지 않구나. 페이지를 더줘. pafe fault rate의 상한값과 하한값을 둔다 pafe fault rate이 상한값을 넘으면 프레임을 더 할당 하한값 이하이면 프레임 수를 줄임 빈 프레임이 없으면 일부 프로세스를 swap out Page Size의 결정 Page size를 감소시키면 페이지 수 증가 페이지 테이블 크기 중가 internal fragmentation 감소 Disk transfer 의 효율성 감소 필요한 정보만 메모리에 올라와 메모리 이용이 효율적 locality 활용 측면에서는 좋지 않음 trend Larger page size","link":"/2018/10/11/Virtual%20Memory/"},{"title":"디저트 카페","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5VwAr6APYDFAWu DFS 문제이다. 오래 걸렸다. 아직 DFS 실력이 부족하다. DFS 메소드에 방문 체크 배열을 넘기고, 복사해서 사용하면 시간 초과가 발생한다. 풀이 각 방문 지점에서 할 것 방문 체크 현 위치 기준으로 대각선 네 방향 체크 원점으로 돌아왔을 때 사각형인지 확인하는 방법 길이가 4이상 방향 전환 횟수가 4 or 3 방향 전환 횟수가 4 인 경우 방향 전환 횟수가 3 인 경우","link":"/2018/10/11/%EB%94%94%EC%A0%80%ED%8A%B8%20%EC%B9%B4%ED%8E%98/"},{"title":"File System","text":"출처 : 이화여자대학교 반효경 (http://www.kocw.net/home/search/kemView.do?kemId=1046323) File and File System File 이름을 통해 접근 (cf. 메모리는 주소를 통해 접근) A named collection of related information 일반적으로 비화발성의 보조기억장치에 저장 운영체제는 다양한 저장 장치를 file이라는 동일한 논리적 단위로 볼 수 있게 해줌 연산 create / read / write / reposition (lseek) / delete / open / close File attritbute ( or 파일의 metadata) 파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보들 파일 이름, 유형, 저장된 위치, 파일 사이즈 접근 권한 (읽기, 쓰기, 실행), 시간 (생성, 변경, 사용), 소유자 등 File System 운영체제에서 파일을 관리하는 부분 파일 및 파일의 메타데이터, 디렉토리 정보 등을 관리 파일의 저장 방법 결정 파일 보호 등 Directory and Logical Disk Directory 파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일 그 디렉토리에 속한 파일 이름 및 파일 attribute 들 연산 search for a file, create a file, delete a file list a direcotry, rename a file, traverse the file system Partition (==Logical Disk) 하나의 물리적 디스크 안에 여러 파티션을 두는게 일바적 물리적 디스크를 파티션으로 구성한 뒤 각각의 파티션에 file system을 깔거나 swapping 등 다른 용도로 사용 가능 open() open시스템 콜을 하면 운영체제에게 CPU 제어권이 넘어가 운영체제는 root를 먼저 open하여 root의 content를 찾아 a라는 파일의 메타데이터를 찾아서 이걸 메모리에 올려 a의 메타데이터로부터 a의 내용을 찾아 a안의 b의 metadata를 메모리에 올려 각 프로세스마다 그 프로세스가 오픈한 파일들에 대한 메타데이터 포인터를 가지고 있는 일종의 배열이 있어 b의 metadata를 가리키고 있는 index 가 file discriptor (fd) 를 사용자 프로세스에게 리턴 read(fd..) fd를 가진 파일에서 읽어와 A의 PCB에 가서 해당 fd에 대응하는 파일의 metadata로부터 b의 내용에 접근 b 내용을 읽어서 운영체제가 자신의 메모리 공간 일부에 읽어놓음. copy해서 사용자 프로그램에게 전달 다른 프로그램이나 이 프로그램이 동일한 파일의 동일한 위치를 read 요청하면 디스크까지 가는것이 아니라 운영체제가 읽어놓은거 바로 전달 이게 바로 Buffer caching File Protection각 파일에 대해 누구에게 어떤 유형의 접근(read/write/execution) 을 허락할 것인가? Access Control 방법 Access Control Matrix 공간 낭비 발생해서 Access Control List : 파일별로 누구에게 어떤 접근 권한이 있는지 ( Linked list ) Capability : 사용자 별로 자신이 접근 권한을 가진 파일 및 해당 권한 (Linked List) Grouping 전체 user를 owner / group / public 의 세 그룹으로 구분 각 파일에 대해서 세 그룹의 접근 권한(rwx)을 3 비트씩으로 표시 9개의 비트만으로 표현 가능 password 파일 마다 패스워드 두는 방법 ( 디렉토리 파일에 두는 방법도 가능) 모든 접근 권한에 대해 하나의 패스워드 : all or nothing 접근 권한별 패스워드 : 암기문제, 관리문제 File System의 Mounting 루트 파일 시스템의 특정 디렉토리 이름에 또 다른 파티션에 있는 파일 시스템을 마운팅 하면, 마운트 된 디렉토리에 접근하면 또 다른 파일 시스템의 루트 디렉토리에 접근하게 됨 Access Methods시스템이 제공하는 파일 정보의 접근 방식 순차 접근 카세트 테이프를 사용하는 방식처럼 접근 읽거나 쓰면 offset은 자동적으로 접근 a b c 순서대로 저장되어 있는데 b 보고 싶으면 a를 먼저 접근해야함 직접 접근 파일을 구성하는 레코드를 임의의 순서로 접근할 수 있음 a b c 순서대로 저장되어 있는데 b 보고 싶으면 바로 볼 수 있음 Allocation of File Data in Disk contiguous allocation Linked Allocation Indexed Allocation Contiguous Allocation 블럭의 크기가 2면, 0 1 이렇게 들어감. direcotory 에 5개의 파일 메타데이터를 가지고 있음 0번 위치부터 길이 2면, 0 1 이렇게 저장됨 단점 외부 조각이 생길 수 있어 파일 크키가 커질 수 있다는 거에 제약 (=file grow가 어려움) 파일 커질 것을 대비해서 미리 어느 정도 공간 할당하면 내부조각 발생 (공간의 낭비) 장점 Fast I/O 한번의 seek/rotation 으로 많은 bite transfer Direct access(=random access) 가능 mail의 경우, 앞에서부터 5번째 보고 싶다. 그럼 19에다가 5 더하면 돼 Linked Allocation jeep이란 파일의 시작은 9번이고, 두번째 블럭은 9번에 적혀 있어. 시작위치만 directory가 가지고 있어. 장점 외부조각 발생하지 않아 단점 직접 접근이 안돼 4번째 위치 보려면 1, 2, 3 번째 봐야해 한 sector가 고장나 pointer가 유실되면 많은 부분을 잃음 pointer를 위한 공간이 block의 일부가 되어 공간 효율성이 떨어짐 변형 File allocation table (FAT) 파일 시스템 Indexed Allocation 장점 외부 조각 발생하지 않아 direct access 가능 단점 small file의 경우 공간 낭비 too large file의 경우 하나의 block으로 index저장하기에 부족 해결 linked scheme multil-level index UNIX 파일 시스템의 구조 Boot block 어떤 파일 시스템이든 가장 먼저 나와 부팅에 필요한 정보 Super block 파일 시스템에 관한 총체적인 정보 담고 있음 어디가 빈 블럭이고 어디가 사용되고 있는지 어디부터 Inode list이고 data block 이고 .. Inode list 파일 하나당 Inode 하나 할당 Inode는 그 파일의 메타데이터를 가지고 있어 파일의 이름은 디렉토리가 직접 가지고 있어 indirect : 따라가면 index를 거쳐서 파일의 위치 정보 찾아 Data block 파일의 실제 내용 보관 FAT file system FAT 위치 정보만 FAT가 가지고 있어 FAT의 217 번지에 217번지의 다음 블럭 번지가 저장되어 있어 직접 접근 가능(메모리에 올라와 있는 FAT만 참고하여 바로 위치 알아낼 수 있어) Free-Space Management중간 중간 비어 있는 블럭은 어떻게 관리? bit 부가적인 공간을 필요 연속적인 n개의 free block을 찾는데 효과적 연속적으로 0인 공간을 찾는데 쉬워 Linked Free-Space List on Disk 모든 free block들을 링크로 연결 (free list) 연속적인 가용 공간을 찾는 것은 쉽지 않다 공간의 낭비가 없다 Grouping 비어 있는 위치가 index 역할 linked list 방법의 변형 첫번째 free block 이 n개의 포인터를 가짐 Counting (first free block, # of contiguous free blocks) 을 유지 Directory Implementation Linear list &lt;file name, file의 metadata)의 list 구현이 간단 디렉토리 내에 파일이 있는지 찾기위해서는 linear search 필요 Hash table linear list + hashing file name을 이 파일의 linear list의 위치로 바꿔줌 search time을 없앰 collision 발생 가능 file 의 metadata 보관 위치 디렉토리 내에 직접 보관 디렉토리에는 포인터를 두고 다른 곳에 보관 inode, FAT 등 Long file name의 지원 &lt;file name, file의 메타데이터&gt; 의 리스트에서 각 entry는 일반적으로 고정 크기 file name이 고정 크기의 entry길이보다 길어지는 경우 entry의 마지막 부분에 이름의 뒷 부분이 위치한 곳의 포인터를 두는 방법 이름의 나머지 부분은 동일한 directory file의 일부에 존재 VFS and NFS Virtual File System (VFS) 서로 다른 다양한 file system에 대해 동일한 시스템콜 인터페이스를 통해 접근할 수 있게 해주는 OS의 layer Network File System 분산 시스템에서는 네트워크를 통해 파일이 공유될 수 있음 분산 환경에서의 대표적인 파일 공유 방법 Page cache and Buffer cacheOS는 사용자 프로그램의 요청을 받아서 디스크에서 읽어온 내용을 그냥 전달하고 끝내는 것이 아니라, 자신의 버퍼 케쉬 영역에 읽어 놓고, 그 내용을 카피해서 사용자 프로그램에게 넘겨줘 Page cache Virtual memory의 pagin system에서 사용하는 pafe frame을 caching의 관점에서 설명하는 용어 Memory-Mapped I/O를 쓰는 경우 file의 I/O에서도 page cache 사용 Memory-Mapped I/O file의 일부를 virtual memory에 mapping 매핑 시킨 영역에 대한 메모리 접근 연산은 파일의 입출력을 수행하게 함 Buffer cache 파일 시스템을 통한 I/O 연산은 메모리의 특정 영역인 buffer cache사용 file 사용의 locality 활용 한번 읽어온 block에 대한 후속 요청시 buffer cache에서 즉시 전달 모든 프로세스가 공용으로 사용 Replacement algiritm 필요(LRU, LFU 등) Unified Buffer Cache 최근의 OS에서는 기존의 buffer cahce가 page cache에 통합 왼쪽 read/write system call 하면 항상 OS에게 요청해서 받아옴 memory mapped IO를 쓰면, 일단 페이지 케쉬에 올라온 내용을 사용자 프로세스가 직접 메모리 접근해서 IO (이미 메모리에 올라온 내용은 커널의 도움을 받지 않음)","link":"/2018/10/12/File%20System/"},{"title":"무선 충전","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRDL1aeugDFAUo 오래 걸렸다. 다른 풀이 방법은 없을까? 풀이 지도에 BC 정보들을 표시 ① bc index를 표시함 ② 중복되는 지점은 + 로 연결해서 표시 ( 지도의 type : String ) A, B 움직이며 충전 ① 이동한 위치를 + 를 기준하여 자름 ( 1+3 : 1번 bc , 3번 bc 겹치는 지점 ) ② BC 선택권이 겹치지 않는 경우, A 선택권 중 가장 power 센것과 B 선택권 중 가장 power 센것 더함 ③ BC 선택권이 겹치는 경우, 모든 경우 비교 ( A : 1 2 3 , B : 2 3 =&gt; 3*2 번의 비교 )","link":"/2018/10/12/%EB%AC%B4%EC%84%A0%20%EC%B6%A9%EC%A0%84/"},{"title":"미생물 격리","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV597vbqAH0DFAVl 시뮬레이션 문제. 쉬운 문제이다. 어떻게 더 깔끔하게 코드를 짤까? 풀이 초기 입력시, 미생물 정보를 배열에 저장한다. m 시간 동안, 저장한 미생물을 이동시키고 다음 경우를 고려한다. 약품 칠해져 있는 곳으로 이동한 경우 이동을 했는데 겹치는 경우","link":"/2018/10/16/%EB%AF%B8%EC%83%9D%EB%AC%BC%20%EA%B2%A9%EB%A6%AC/"},{"title":"홈 방범 서비스","text":"&lt;https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5V61LqAf8DFAWu 쉬운 문제이다. 시뮬레이션 문제로 처음에 풀었다. BFS로도 풀수 있다. 풀이 01 k 일 때, 전체 집 개수를 대상으로 이익이 0 이상인지 체크한다. 이익이 0 이상이면, 마름모를 이동 시켜서 집 개수를 count 한다. 마름모 이동이란, 예들 들어 k가 2일 때, 마름모의 중심에서 거리가 1이하인 지점을 체크하는 것이다. 서비스 제공 받는 집 수의 최대 값 구하기. 풀이 02 i, j 지점에서 BFS를 시작한다. ( 모든 지점에서 BFS ) i, j 지점에서 지도의 영역을 넓힐 수 없을 때 까지 k를 증가시킨다. 이익이 0 이상이면 집 개수의 최대 값을 구한다.","link":"/2018/10/19/%ED%99%88%20%EB%B0%A9%EB%B2%94%20%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"title":"2018 하반기 삼성 코테 리뷰","text":"응시일 : 2018.10.21 15:00-18:00 장소 : 영통 인재 개발원 시험 상황계획은 1번 문제 90분, 2번 문제 90분 정도 잡았다. 1번 문제를 먼저 풀고 2번 문제로 넘어가려고 하였다. 1번 문제가 시뮬레이션, 2번 문제가 탐색 문제였다. 1먼 문제를 읽고, 90분 내에 충분히 풀 수 있다고 생각하였다. 하지만 90분이 다 되어가는데도 풀리지 않았다. 90분 즈음에 2번 문제를 읽었다. 충분히 풀 수 있을 것 같았지만, 조금만 더 하면 1번 문제를 풀 수 있을 것이라고 생각했다. 1번 문제를 포기 못하고, 1번 문제를 계속 풀었고 시간이 점점 흐르고 2번 문제를 아예 포기 했다. 문제점 문제 이해를 완벽히 하지 않았는데 코딩을 시작해서, 코딩하다가 계속 문제를 다시 읽었다. 윈도우 PC와 이클립스가 익숙치 않아 코딩은 하는데 굉장히 불편했다. 90분 동안 1번 문제를 풀지 못했으면, 2번으로 넘어가야 했는데 계속 붙잡고 있었다. 고칠점 문제를 확실히 이해하고 코딩을 하자. 문제를 이해하고, 어떻게 풀지 구상할 수만 있으면 코딩은 금방 한다. 시험 보기 전에 윈도우PC, 이클리스에 익숙해지도록 연습하자. 자신있는 탐색 문제부터 풀자. 멕시멈 90분 동안 풀지 못하면 다음 문제로 넘어가자. 문제 설명 나무 각 지역(i, j)의 나무의 나이, 양분, 투입 양분이 있다. 봄, 여름, 가을, 겨울에 따라 조건이 있다. 봄에는 ~ 여름에는 ~ : 이 부분이 확실히 이해가 가지 않았다. 가을에는 ~ 겨울에는 ~ 개복치","link":"/2018/10/23/2018%20%ED%95%98%EB%B0%98%EA%B8%B0%20%EC%82%BC%EC%84%B1%20%EC%BD%94%ED%85%8C%20%EB%A6%AC%EB%B7%B0/"},{"title":"개복치","text":"https://www.acmicpc.net/problem/16236 2018 하반기 대졸 신입 삼성 코딩 테스트 기출문제이다. 시험장에서 문제를 읽고 쉬울 것이라고 예상만 하고, 1번 문제를 푸느라 풀지는 못했다. 따로 풀어보니, 시간이 오래 걸렸지만 간단한 문제이다. 코드를 너무 복잡하게 짜서, 더 간단하고 깔끔한 풀이를 찾아봐야겠다. 풀이BFS + Simulation 먹을 수 있는 물고기 후보 찾기 : BFS 후보가 한 마리면 그 물고기 위치로 이동해서 먹기 후보가 두 마리 이상이면 다음 조건들을 차례대로. 두 가지 이상 나오면, 다음 조건 확인 : Simulation 가장 가까운 가장 i가 작은 가장 j가 작은 코드https://github.com/KoJunHee/algorithm/blob/master/src/bj_16236/Main.java","link":"/2018/10/24/%EA%B0%9C%EB%B3%B5%EC%B9%98/"},{"title":"방번호","text":"https://www.acmicpc.net/problem/1475 풀이처음에 숫자 세트를 하나 갖고 있다고 시작한다. 숫자 부족할 때마다 숫자 세트를 늘려나간다. 코드https://github.com/KoJunHee/algorithm/blob/master/src/bj_1475/Main.java","link":"/2018/10/25/%EB%B0%A9%EB%B2%88%ED%98%B8/"},{"title":"가장 많은 글자","text":"https://www.acmicpc.net/problem/1371 풀이문장 단위로 읽어서 알파벳 개수 count. 여러 문장을 읽어오는 방법 : hasNextLine()으로 다음 문장이 있는지 체크 hasNextLine()scanner의 input에 입력받을 line이 있다면 true를 반환한다. https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html 코드https://github.com/KoJunHee/algorithm/blob/master/src/bj_1371/Main.java","link":"/2018/10/26/%EA%B0%80%EC%9E%A5%20%EB%A7%8E%EC%9D%80%20%EA%B8%80%EC%9E%90/"},{"title":"인구이동","text":"https://www.acmicpc.net/problem/16234 2018년 하반기 대졸 신입 삼성 코딩 테스트 오전 타임 2번 탐색 문제이다. 매우 쉬웠다. 55분 소요되었다. 풀이 국경선 열기 국가 각 지점에서 DFS을 실행하여 각 국가에 지역 번호를 매긴다. 각 지점에서 동서남북으로 연결되어 있고, 인구 차가 l 이상 r 이하이면 같은 지역 번호가 매겨진다. DFS를 실행하고 리턴되었을 때, 지역 번호가 2개 이상 매겨졌으면 연합이 생성된 것이다. 리스트에 지역번호와 함께 연합의 (인구합 / 연합을 이루는 국가수) 를 저장한다. 인구 이동 i,j 의 지역번호가 리스트에 저장되어 있는 지역 번호라면 해당 index의 리스트의 인구를 map에 저장한다. 코드https://github.com/KoJunHee/algorithm/blob/master/src/bj_16234/Main.java","link":"/2018/10/29/%EC%9D%B8%EA%B5%AC%EC%9D%B4%EB%8F%99/"},{"title":"러시아 국기 같은 깃발","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWQl9TIK8qoDFAXj&amp;categoryId=AWQl9TIK8qoDFAXj&amp;categoryType=CODE 쉬웠다. 70분 소요되었다. 탐색문제이다. 풀이 selectionSort01 각 row에 어떤 색으로 칠할지 DFS로 탐색하여 결정한다. i번째 row에 W를 칠했으면, i+1 번째에 W / B / R 색칠 가능 i번째 row에 B를 칠했으면, i+1 번째에 B / R 색칠 가능 i번째 row에 R를 칠했으면, i+1 번째에 R 색칠 가능 DFS로 깊이 들어갈때마다, 색칠할 칸을 카운트한다. 조건 R를 칠하려고 하면, 그 전에 B가 하나라도 나와야함 W만으로 칠해서는 안된다. 코드https://github.com/KoJunHee/algorithm/blob/master/src/swa_4613/Solution.java","link":"/2018/11/05/%EB%9F%AC%EC%8B%9C%EC%95%84%20%EA%B5%AD%EA%B8%B0%20%EA%B0%99%EC%9D%80%20%EA%B9%83%EB%B0%9C/"},{"title":"초보자를 위한 점프대 배치하기","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWGsV8IaAXsDFAVW 오답 풀이https://github.com/KoJunHee/algorithm/blob/master/src/swa_3503/Solution.java 정렬해서 나올 수 있는 모든 경우를 탐색하기 위해 DFS를 하였다. 원형이기 때문에, 시작점을 하나로 DFS 탐색을 시작해도 모든 경우가 커버 가능하다. 예를 들어, 2 4 5 7 9 의 경우에 2를 시작으로 DFS를 탐색한다. 탐색을 하며 높이 차를 계산한다. 시간 초과가 났다. 탐색으로 모든 케이스를 따져보는 것이 아닌 문제라는 것이다. 정답 풀이https://github.com/KoJunHee/algorithm/blob/master/src/swa_3503_02/Solution.java 오름 차순으로 정렬한다. 가장 작은 값을 가운데에 둔다. 맨 앞에, 다음으로 작은 값을 둔다. 맨 뒤에, 다음으로 작은 값을 둔다. 3,4를 반복한다. 이와 같이 하면, 가장 큰 높이 차가 최소가 되도록 정렬된다. 구현을 위해서, 두개의 큐를 사용하였다. 다음 그림을 보자. 주어진 수를 오름 차순 정렬한다. 가장 작은 2를 가운데에 둔다. 그 다음으로 작은 4를 맨 앞에 둔다. 그 다음으로 작은 5를 맨 뒤에 둔다. 3, 4를 반복한다. 최종적으로 7 4 2 5 9 배열이 얻어졌고, 가장 큰 높이 차(4) 가 최소가 되로록 정렬되었다.","link":"/2018/11/06/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20%EC%A0%90%ED%94%84%EB%8C%80%20%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"숫자 고르기","text":"https://www.acmicpc.net/problem/2668 오답 풀이https://github.com/KoJunHee/algorithm/blob/master/src/bj_2668/Main.java 완전 탐색으로 풀었다. 가능한 모든 경우를 조사하였다. 깊이 들어갈 때 마다, 두 집합이 일치하는지, 깊이는 몇인지 체크한다. 시간 초과가 났다. 모든 경우를 완전 탐색으로 찾으며 푸는것이 아니란 것이다. 정답 풀이https://github.com/KoJunHee/algorithm/blob/master/src/bj_2668_02/Main.java 사이클 여부를 조사한다. 다음 이동할 지점이 시작점이면 사이클을 이룬 것이다. 문제에서 주어진 예시를 그림으로 그려보자. 1을 시작으로 dfs를 시작하자. 1 방문 체크를 한다. 다음 위치는 3이다. 3 방문 체크를 한다. 다음 위치는 1이다. 이미 방문한 곳이다. 시작점으로 돌아왔으니 싸이클을 이루었다. 시작점인 1을 리스트에 저장한다. 이번 dfs는 끝났다. 2를 시작으로 dfs를 시작하자. 2 방문 체크를 한다. 다음 위치는 1이다. 1 방문 체크를 한다. 다음 위치는 3이다. 3 방문 체크를 한다. 다음 위치는 1이다. 이미 방문한 곳이다. 이미 방문 한곳이 시작점이 아니기 때문에 사이클을 이루지 않는다. 이번 dfs는 끝났다. 이런 식으로 7을 시작으로 하는 dfs 까지 진행하고 리스트에 저장된 값을 출력한다.","link":"/2018/11/08/%EC%88%AB%EC%9E%90%20%EA%B3%A0%EB%A5%B4%EA%B8%B0/"},{"title":"길찾기","text":"https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14geLqABQCFAYD&amp;categoryId=AV14geLqABQCFAYD&amp;categoryType=CODE 오랜만에 푸는 관계로, 쉬운 문제를 선택하였습니다. 탐색 기본 문제입니다. 풀이https://github.com/KoJunHee/algorithm/blob/master/src/swa_1219/Solution.java 그래프 그리기 주어진 그래프를 두 개의 배열로 표현합니다. 한 지점에서 최대 두 개의 길이 있기 때문입니다. 예를 들어, 1번 지점에서 3번과 4번의 길로 갈 수 있다면 다음과 같이 배열에 저장합니다. arr01[1] =3 , arr02[1] =4 마찬가지로 3번 지점에서 7번 길로만 갈 수 있다면 다음과 같이 배열에 저장합니다. arr01[3] = 7, arr02[3] = 0 경로 유무 찾기 DFS를 사용합니다. 최대한 깊게 들어가다가 99번 위치에 도착하면 탐색을 종료합니다.","link":"/2018/11/21/%EA%B8%B8%EC%B0%BE%EA%B8%B0/"},{"title":"패러다임의 불일치","text":"객체 모델과 관계형 데이터베이스 모델은 지향하는 페러다임이 서로 다르다.페러다임의 불일치 문제를 해결하기 위한 결과물이 ‘JPA’ 이다.객체 모델과 관계형 데이터베이스 모델의 페러다임 차이를 비교해보자. Granularity (밀도) 객체 다양한 크기의 객체 커스텀한 타입 릴레이션 테이블 기본 데이터 타입 (UDT는 비추) Subtype 객체 상속 구조 다형성 릴레이션 테이블 상속 無 (상속 기능을 구현했다 하더라도 표준 기술이 아닙니다.) 다형적인 관계 無 Identity 객체 레퍼런스 동일성 (==) 인스턴스 동일성 (equals() 메소드) 릴레이션 주키 (primary key) Association 객체 객체 레퍼런스로 관계 표현 방향이 존재 다대다 관계 가능 릴레이션 Foreign Key 로 관계 표현 방향이라는 의미가 無 다대다 관계 불가능. (조인 테이블 또는 링크 테이블을 사용해서 두개의 1대다 관계로 풀어야 ) Data Navigation 객체 레퍼런스를 이용해 다른 객체로 이동 가능 콜렉션 순회 가능 릴레이션 SQL 을 직접 다루면 처음 실행하는 SQL 에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.이것은 큰 제약이다. 왜냐하면, 비즈니스 로직에 따라 사용하는 객체 그래프가 다르므로 언제 끊어질지 모를 개체 그래프를 함부로 탐색할 수 없기 때문이다. 데이터베이스에 요청을 적게 할 수록 성능이 좋아, join 을 쓴다. 너무 많이 한 번에 가져오려고 해도 문제이다. https://www.inflearn.com/course/스프링-데이터-jpa 자바 ORM 표준 프로그래밍 &lt;김영한&gt;","link":"/2019/03/13/JPA%20Paradigm/"},{"title":"[자바 ORM 표준 JPA 프로그래밍] 4장_앤티티 매핑","text":"엔티티와 테이블을 정확히 매핑하기 위해 JPA 는 다양한 어노테이션을 지원한다. 객체와 테이블 매핑 : @Entity, @Table 기본 키 매핑 :@Id 필드와 컬럼 매핑 : @Column @EntityJPA 를 사용해서 테이블을 매핑할 클래스는 @Entity 를 필수로 붙여야한다.그리고, @Entity 적용시 기본 생성자는 필수이다. @Table엔티티와 매핑할 테이블을 지정한다. 데이터베이스 스키마 자동 생성JPA 는 클래스의 매핑 정보와 Database Dialect 을 사용해서 데이터베이스 스키마를 생성한다.create / create-drop / update / validate / none 옵션이 있다.다음과 같이 설정하면 기존 테이블은 삭제하고 새로 생성한다. ( DROP + CREATE ) 1spring.jpa.hibernate.ddl-auto=create Primary Key 매핑JPA가 제공하는 데이터베이스 기본 키 생성 전략은 다음과 같다. 직접 할당 : 애플리케이션에서 직접 할당한다. 자동 생성 : 대리 키를 사용한다. 직접 할당em.persist() 로 엔티티를 영속성 컨텍스트에 저장하기 전에, 애플리케이션에서 키를 직접 할당하는 방식이다. 123Board b = new Board();b.setId(&quot;id1&quot;);em.persist(b); 자동 생성 01 : IDENTITY기본 키 생성을 데이터베이스에 위임한다. 그래서, DB 에 값을 저장하고 나서야 기본 키 값을 얻을 수 있다.그런데, 엔티티가 영속성 상태가 되려면 식별자가 반드시 필요하다. IDENTITY 식별자 생성 전략은 이 전제를 어떻게 해결할까 ? em.persist() 를 호출한다. 즉시 INSERT SQL 이 DB 에 전달된다. 그래서, Transactional Write Behind 가 동작하지 않는다. 그런데, INSERT 한 후에 기본 키 값을 다시 조회하기 위해 추가적으로 SELECT 를 할까 ? 아니다.JDBC3 에 추가된 Statement.getGeneratedKeys() 를 사용하여 데이터를 조회하는 동시에 생성된 기본키도 얻을 수 있다. 자동 생성 02 : SEQUENCE데이터베이스 시퀀스를 사용해 기본 키를 할당한다. 데이터베이스 시퀀스란, 유일한 값을 순서대로 생성하는 특별한 DB Object 이다.이 전략은, 시퀀스를 지원하는 PostgreSQL, DB2, H2 데이터베이스에 사용할 수 있다.SEQUENCE 전략은 em.persist() 를 호출할 때 먼저 데이터베이스 시퀀스를 사용해서 식별자를 조회한다. 조회한 식별자를 엔티티에 할당한다. 엔티티를 영속성 컨텍스트에 저장한다. 트랜잭션을 커밋해서 플러쉬가 일어난다. 엔티티를 데이터베이스에 저장한다. 자동 생성 03 : TABLE키 생성 전용 테이블을 하나 만드는 방법이다.시퀀스 대신에 테이블을 사용한다는 것만 제외하면, SEQUENCE 전략과 동일하다. 식별자 선택 전략DB 기본키는 다음 조건을 만족해야한다. null 허용 X 유일 불변 테이블의 기본 키를 선택하는 전략은, 자연키 : 비즈니스에 의미있는키 (ex) 주민번호 대리키 : 비즈니스와 관련 없는 임의 키 (ex) auto_increment 그렇다면, 자연키가 나을까 대리키가 나을까 ? 대리키가 낫다.왜냐하면, 비즈니스 요구사항은 변할 수 있기 때문이다. 요구사항은 계속 변하는데, 테이블은 한 번 정의하면 변경하기 어렵다. 자바 ORM 표준 프로그래밍 &lt;김영한&gt;","link":"/2019/03/20/entity%20mapping/"},{"title":"[자바 ORM 표준 JPA 프로그래밍] 3장_영속성 관리","text":"Entity 를 Entity Manager 를 통해 어떻게 사용하는지 정리하자. Entity Manager Factory, Entity Manager엔티티 메니저 펙토리는 한 개만 만들어서 애플리케이션 전체에서 공유한다.엔티티 메니저 펙토리는 서도 다른 스레드 간에 공유해도 되지만엔티티 메니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다. Persistence Context엔티티를 저장하는 환경이다.엔티티 메니저로 엔티티를 저장하거나 조회하면 엔티티 메니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다. 엔티티의 생명주기네 가지 상태가 있다. 비영속영속성 컨텍스트와 관계 없는 상태 영속영속성 컨텍스트에 저장된 상태 준영속영속성 컨텍스트에 저장되었다가 분리된 상태 삭제삭제된 상태 영속성 컨텍스트의 특징 영속 상태는 식별자 값이 반드시 있어야한다. 보통 Transaction 을 Commit 하는 순간 영속성 컨텍스트에 저장된 엔티티를 데이터베이스에 반영한다. (Flush) 1차 캐쉬 / 동일성 보장 / 쓰기 지연 / 변경 감지 / 지연 로딩 엔티티 조회영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다.쉽게 이야기해 Map 처럼, 키는 @Id 로 매핑한 식별자이고 값은 엔티티 인스턴스이다.1차 캐시에 저장된 엔티티를 조회할 때, 1차 캐시에 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다.만약, 1차 캐시에 없으면 엔티티 메니저는 데이터베이스를 조회해서 엔티티를 생성하고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다. 1entityManger.find(Member.class, &quot;member1&quot;); 영속 엔티티의 동일성 보장영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.따라서, 다음 코드의 결과는 true. 1234Member a = em.find(Member.class, &quot;member1&quot;);Member b = em.find(Member.class, &quot;member1&quot;);System.out.println(a==b); 엔티티 등록엔티티 메니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둔다.그리고 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다.이것을 Transactional Write Behind (쓰기 지연) 라고 한다. 엔티티 수정엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 Dirty Checking (변경 감지) 이라고 한다. 커밋하면 엔티티 메니저 내부에서 flush() 가 호출된다. 엔티티와 스냅샷 (JPA 는 엔티티를 영속성 컨텐스트에 보관할 때, 최초 상태를 복사해서 저장) 을 비교해서 변경된 엔티티를 찾는다. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다. 데이터베이스 트랜잭션을 커밋한다. 또한, UPDATE SQL 을 생성할 때,변경된 부분만 사용해서 동적으로 생성되는 것이 아니라, 엔티티의 모든 필드를 업데이트한다. 엔티티 삭제엔티티 등록과 비슷하게삭제 쿼리를 쓰기 지연 SQL 저장소에 등록하고 트랜잭션을 커밋해서 flush()를 호출하면 데이터베이스에 삭제 쿼리를 전달한다. 12Member a = em.find(Member.class, &quot;member1&quot;);em.remove(a); 플러쉬영속성 컨테르를 플러쉬하는 방법은 세 가지이다. em.flush() 직접 호출 트랜잭션 커밋 시 플러쉬 자동 호출 JPQL 쿼리 실행시 플러쉬 자동 호출 자바 ORM 표준 프로그래밍 &lt;김영한&gt;","link":"/2019/03/20/persistence%20context/"},{"title":"[자바 ORM 표준 JPA 프로그래밍] 8장_프록시와 연관관계 정리","text":"다음 내용들을 정리한다. 프록시 즉시로딩, 지연 로딩 영속성 전이 고아 객체 프록시아래 내용을 보기 전에, 우선 프록시에 대한 개념을 파악해야한다.여기를 참고하자 : https://junhee-ko.github.io/2021/04/17/proxy-pattern/ 이제, 예제를 보자. 1234567891011121314151617181920@Entitypublic class Member { private String username; @ManyToOne private Team team; // ...}@Entitypublic class Team { private String name; // ...}public String printUserBy(String memberId){ Member member = em.find(Member.class, memberId); System.out.println(member.getUsername());} printUserBy 메서드에서, 멤버를 조회할 때 연관된 팀 엔티티까지 DB 에서 같 조회하는게 효율적일까 ?팀 엔티티를 실제 사용하는 시점에 조회하는게 효율적이다. 이것을 지연로딩이라고 한다. 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 EntityManager.getReference() 를 사용하면 된다. 이 메서드는, 실제 엔티티 객체를 생성하지 않고 프록시 객체를 반환한다. 프록시 특징 프록시 객체는 실제 클래스를 상속 받아 만들어지며, 실제 객체에 대한 참조(target) 을 보관한다. 프록시 객체의 메소드를 호출하면, 프록시 객체는 실제 객체의 메소드를 호출한다. 프록시 객체의 초기화12345678910111213141516Member member = em.getReference(Member.class, &quot;id1&quot;);member.getUsername(); // 실제 사용 (1)public class MemberProxy extends Member { Member target = null; public String getUsername() { if(target == null){ // 초기화 (2) // DB 조회 (3) // 실제 엔티티 생성 및 참조 보관 (4) } return target.getUsername(); // (5) }} 프록시 객체의 초기화란, member.getUsername() 처럼 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티를 생성하는 것이다. 다음 과정과 같다. 프록시 객체에 member.getUsername() 호출해서 실제 데이터 조회 프로시 객체는 실제 엔티티가 생성되어 있지 않으면, 영속성 컨텍스트에 실제 엔티티 생성 요청 (== 초기화 요청) 영속성 컨텍스트는 DB 조회해서 실제 엔티티 객체 생성 프록시 객체는 실제 엔티티 객체의 참조를 Member target 참조 변수에 보관 프록시 객체는 실제 엔티티 객체의 getUsername() 을 호출해서 결과 반환 주의할 점은, 영속성 컨텍스트에 이미 찾는 엔티티가 있으면, DB 를 조회할 필요가 없으므로 em.getReference() 를 호출해도 프록시가 아니라 실제 엔티티를 반환 초기화는 영속성 컨텍스트의 도움을 받아야 가능. 그래서, 준영속 상태의 프록시를 초기화하면 문제가 발생 (Hibernate : LazyInitializationException 발생) 즉시 로딩12345678910@Entitypublic class Member { // ... @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; // ...}em.find(Member.class, &quot;member1&quot;) 멤버를 조회하는 순간 팀도 함께 조회한다. 여기서 주의할 점은 회원과 팀 두 테이블을 조회해야하므로 쿼리를 두 번 실행하는 것이 아니라, join query 를 사용한다는 것이다. 지연 로딩123456789101112@Entitypublic class Member { // ... @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; // ...}Member member = em.find(Member.class, &quot;member1&quot;); // 회원만 조회Team team = member.getTeam(); // 여기서 team 은 프록시 객체team.getName(); // team 객체 실제 사용하면서 프록시 객체가 초기화됨 만약, team 엔티티가 영속성 컨텍스트에 이미 로딩되어 있으면, 프록시가 아닌 실제 엔티티를 사용한다. JPA 기본 Fetch 전략 @ManyToOne, @OneToOne : FetchType.EAGER @OneToMany, @ManyToMany : FetchType.LAZY 연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연로딩을 사용한다. 컬렉션을 로딩하는 것은 비용이 많이 들고 자칫하면 너무 많은 데이터를 로드할 수 있기 때문이다.추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다. 그리고, 실제 사용하는 상황을 보고 꼭 필요한 곳에 즉시 로딩을 사용하도록 최적화 하면 된다. 영속성 전이특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 사용하면 된다. JPA 는 CASCADE 옵션으로 영속성 전이 기능을 제공힌디.예를 들어, 부모 엔티티가 여러 자식 엔티티를 가지고 있다. 123456789101112131415@Entitypublic class Parent { @Id @GeneratedValue private Long id; @OneToMany private List&lt;Child&gt; children = new ArrayList&lt;Child&gt;();}@Entitypublic class Child { @Id @GeneratedValue private Long id; @ManyToOne private Parent parent;} 영속성 전이 : 저장부모만 영속화하면 CascadeType.PERSIST 로 설정한 자식 엔티티까지 함께 영속화해서 저장한다. 12345678910111213141516171819202122@Entitypublic class Parent { @Id @GeneratedValue private Long id; @OneToMany(mappedBy = &quot;parent&quot;, cascade = CascadeType.PERSIST) private List&lt;Child&gt; children = new ArrayList&lt;Child&gt;();}private static void saveWithCascade(EntityManager em){ Child child01 = new Child(); Child child02 = new Child(); Parent parent = new Parent(); // 연관 관계 추가 child01.setParent(parent); child02.setParent(parent); parent.getChildren().add(child01); parent.getChildren().add(child02); // 부모를 저장하며, 연관된 자식들도 같이 저장 em.persist(parent); } 영속성 전이 : 삭제CascadeType.REMOVE 설정하고 부모 엔티티만 삭제하면 연관된 자식 엔티티까지 함께 삭제된다.현재 예시로는, DELETE SQL 이 세 번 실행된다. (부모 + 자식01 + 자식02) 12Parent parent = em.find(Parent.class, 1L);em.remove(parent); 영속성 전이 발생 시점CascadeType.PERSIST 와 CascadeType.REMOVE 는 em.persist() 와 em.remove() 를 실행할 때 바로 전이가 발생하는 것이 아니라, 플러쉬를 호출할 때 발생한다. 고아 객체JPA는 부모 엔티티와 연관 관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데, 이를 고아 객체 제거라고 한다. 아래 코드를 보자. 12345678910@Entitypublic class Parent { // ... @OneToMany(mappedBy=&quot;parent&quot;, orphanRemoval = true) private List&lt;Child&gt; children = new ArrayList&lt;Child&gt;(); // ...}Parent parent = em.find(Parent.class, id);parent.getChildren.remove(0); // 자식 엔티티를 컬렉션에서 제거 컬렉션에서 첫 번째 자식을 제거하면, orphanRemoval = true 옵션 설정으로 인해서 데이터베이스의 데이터도 삭제된다.주의할 점은, 고아 객체 제거 기능은 영속성 컨텍스트를 flush 할 때 적용되므로, flush 시점에 DELETE SQL 이 실행된다. 참고로, 모든 자식 엔티티를 제거하려면 다음과 같이 하면된다. 1parent.getChildren.clear(); 영속성 전이 + 고아객체일반적으로 엔티티는 em.persist()로 영속화되고, em.remove()로 제거된다. 이것은 엔티티 스스로 생명주기를 관리한다는 뜻이다.그런데, CascadeType.All + orphanRemove = true 를 동시에 사용하면? 부모 엔티티를 통해서 자식 엔티티의 생명주기를 관리할 수 있다. 자식을 저장하려면, 부모만 등록. 12Parent parent = em.find(Parent.class, id);parent.addChild(child); 자식을 삭제하려면, 부모만 삭제 12Parent parent = em.find(Parent.class, id);parent.getChildren().remove(child); 자바 ORM 표준 프로그래밍 &lt;김영한&gt;","link":"/2019/04/09/jpa-proxy/"},{"title":"[자바 ORM 표준 JPA 프로그래밍] 12장_스프링 데이터 JPA","text":"데이터 접근 계층 (Data Access Layer) 는 CRUD 로 불리는 등록, 수정, 삭제, 조회 코드를 반복해서 개발해야 한다.JPA 를 사용해서 데이터 접근 계층을 개발할 때도 문제가 발생한다. 123456789101112131415161718192021public class MemberRepository{ @PersistenceContext EntityManager em; public void save(Member member) {...} public Member findOne(Long id) {...} public List&lt;Member&gt; findAll() {...} public Member findByUsername(String username) {...}}public class ItemRepository{ @PersistenceContext EntityManager em; public void save(Item item) {...} public Member findOne(Long id) {...} public List&lt;Member&gt; findAll() {...}} 위 코드를 보면, 회원 리포지토리와 상품 리포지토리가 하는 일이 비슷하다.이 문제를 해결하려면 제네릭과 상속을 적절히 사용해서 공통 부분을 처리하는 부모 클래스를 만들면 된다. 이것을 보통 GenericDAO 라고 한다.하지만 이것은, 공통 기능을 구현하는 부모 클래스에 종속되고 구현 클래스 상속이 가지는 단점이 있다. 스프링 데이터 JPA스프링 데이터 JPA 는 스프링 프레임워크에서 JPA 를 편리하게 사용할수 있도록 지원하는 프로젝트이다.이 프로젝트는 데이터 접근 계층을 개발할 때 지루하게 반복되는 CRUD 문제를 세련된 방법으로 해결한다.데이터 접근 계층을 개발할 때 구현 클래스 없이 인터페이스만 작성해도 개발을 완료할 수 있다. 123456public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { Member findByUsername(String username);}public interface ItemRepository extends JpaRepository&lt;Item, Long&gt; {} 회원과 상품 리포지토리 구현체는 애플리케이션 실행 시점에 스프링 데이터 JPA 가 생성해서 주입해준다. 즉, 개발자가 직접 구현체를 개발하지 않아도 된다.일반적인 CRUD 메소드는 JpaRepository 인터페이스가 공통으로 제공하지만,MemberRepository.findByUsername(…) 처럼 직접 작성한 공통으로 처리할 수 없는 메소드는 스프링 데이터 JPA 가 메소드 이름을 분석해서 JPQL 을 실행한다. 스프링 데이터 프로젝트스프링 데이터 JPA 프로젝트는 JPA 에 특화된 기능을 제공한다. JpaRepository 계층 구조JpaRepository interface의 계층 구조를 직접 확인해보자. JpaRepository 는 org.springframework.data.jpa.repository 에 속해있다.JpaRepository 는 다시 PagingAndSortingRepository 를 상속하고 있다. PagingAndSortingRepository interface 의 package 는 org.springframework.data.jpa.repository 가 아니라, org.springframework.data.repository 이다.PagingAndSortingRepository 는 다시 CrudRepository 를 상속한다. CrudRepository interface 의 package 는 org.springframework.data.jpa.repository 가 아니라, org.springframework.data.repository 이다.CrudRepository 는 다시 Repository 를 상속한다. Repository interface 의 package 는 org.springframework.data.jpa.repository 가 아니라, org.springframework.data.repository 이다. 정리하면 다음 계층구조이다. 스프링 데이터 JPA 가 사용하는 구현체스프링 데이터 JPA 가 제공하는 공통 인터페이스는 org.springframework.data.jpa.repository.support.SimpleJpaRepository 클래스가 구현한다. 12345@Repository@Transactional(readOnly = true)public class SimpleJpaRepository&lt;T, ID extends Serializable&gt; implements JpaRepository&lt;T, ID&gt;, JpaSpecificationExecutor&lt;T&gt; { ...} 직접 확인해보자. 의존성을 다음과 같이 추가한다. 12345dependencies { implementation 'org.springframework.boot:spring-boot-starter-data-jpa' testImplementation 'com.h2database:h2' testImplementation 'org.springframework.boot:spring-boot-starter-test'} 그리고 Repository 를 정의한다. 12345import org.springframework.data.jpa.repository.JpaRepository;public interface TestRepository extends JpaRepository&lt;Test, Long&gt; { } TestRepository 룰 출력해보자. 1234567891011@SpringBootTestclass DemoSpringDataJpaApplicationTests { @Autowired private TestRepository testRepository; @Test void test() { System.out.println(testRepository); }} 결과는, SimpleJpaRepository 클래스 명이 출력된다.repository interface 를 정의했을 뿐인데, 구체 클래스가 주입이 되었다. Query Method스프링 데이터 JPA 가 제공하는 쿼리 메소드 기능은 크게 세 가지이다. 메소드 이름으로 쿼리 생성 메소드 이름으로 JPA NamedQuery 호출 @Query 어노테이션을 사용해서 리포지토리 인터페이스에 쿼리 직접 정의 메소드 이름으로 쿼리 생성123public interface MemberRepository extends Repository&lt;Member, Long&gt; { List&lt;Member&gt; findByEmailAndName (String email, String name);} findByEmailAndName(…) 를 실행하면 스프링 데이터 JPA 는 메소드 이름을 분석해서 다음 JPQL 을 생성하고 실행한다. 1select m from Member m where m.email = ?1 and m.name =?2 JPA NamedQuery스프링 데이터 JPA 는 메소드 이름으로 JPA Named 쿼리를 호출하는 기능을 제공합니다. 12345678@Entity@NamedQuery{ name = &quot;Member.findByUsername&quot;, query = &quot;select m from Member m where m.username = :username&quot;}public class Member{ ...} 이렇게 정의한 Named 쿼리를 다음과 같이 호출한다. 123456789101112131415//JPA를 직접 사용해서 Named Query 호출public class MemberRepository{ public List&lt;Member&gt; findByUserName(String username){ ... List&lt;Member&gt; resultList = em.createNaemdQuery(&quot;Member.findByUsername&quot;, Member.class) .setParameter(&quot;username&quot;, &quot;회원1&quot;) .getResultList(); }}// 스프링 데이터 JPA 로 호출public interface MemberRepository extends JpaRepository &lt;Member, Long&gt; { List &lt;Member&gt; findByUserName(@Param(&quot;username&quot;) String username);} 스프링 데이터 JPA 로 호출하는 경우, “도메인 클래스.메소드이름” 으로 Named Query 를 찾아서 실행한다.위 예제는, Member.findByUsername 이라는 Named Query 를 실행한다.만약, Named Query 가 없으면 메소드 이름으로 쿼리 생성 전략을 사용한다. @Query, 리포지토리 메소드에 쿼리 정의실행할 메소드에 직접 정적 쿼리를 작성하므로, 이름 없는 Named Query 라고 할 수 있다. 1234public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { @Query(&quot;select m from Member m where m.username = ?1&quot;) Member findByUserName(String username);} 파라미터 바인딩스프링 데이터 JPA 는 위치 기반 파라미터 바인딩과 이름 기반 파라미터 바인딩을 모두 지원한다.다음은 이름 기반 파라미터 바인딩 예제이다. 1234public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { @Query(&quot;select m from Member m where m.username = :name&quot;) Member findByUserName(@Param(&quot;name&quot;) String username);} 벌크성 수정 쿼리1234567891011121314// JPA 를 사용한 벌크성 수정 쿼리int bulkPriceUp(String stockAmout){ ... String sqlString = &quot;update Product p set p.price = p.price * 1.1 where p.stockAmout &lt; :stockAmout&quot;; int resultCount = em.createQuery(sqlString) .setParameter(&quot;stockAmout&quot;, stockAmout) .executeUpdate();}// 스프링 데이터 JPA 를 사용한 벌크성 수정 쿼리@Modifying@Query(&quot;update Product p set p.price = p.price * 1.1 where p.stockAmout &lt; :stockAmout&quot;)int bulkPriceUp(@Param(&quot;stockAmout&quot;) String stockAmout); 반환 타입결과가 한건 이상이면 컬렉션 인터페이스, 단건이면 반환 타입을 지정한다. 12List&lt;Member&gt; findByName (String name); // 컬렉션Member findByEmail (String email); // 단건 페이징과 정렬쿼리 메소드에 페이징과 정렬 기능을 사용할 수 있도록 두 가지 파라미터를 제공한다. org.springframework.data.domain.sort org.springframework.data.domain.Pageable 파라미터에 Pageable 을 사용하면, 반환타입으로 List 나 org.springframework.data.domain.Page 를 사용할 수 있다.반환 타입으로 Page 를 사용하면 검색된 전체 데이터 건수를 조회하는 count 쿼리를 추가로 호출할 수 있다. Pageable 은 인터페이스이다.실제 사용할 때는 이를 구현한 PageRequest 객체를 사용한다. 1234567891011121314151617// 페이징과 정렬 사용 예제Page&lt;Member&gt; findByName(String name, Pageable pageable);List&lt;Member&gt; findByName(String name, Pageable pageable);List&lt;Member&gt; findByName(String name, Sort sort);// Page 사용 예제 정의 코드public interface MemberRepository extends Repository&lt;Member, Long&gt; { Page&lt;Member&gt; findByNameStartingWith(String name, Pageable pageable);}// Page 사용 예제 실행 코드PageRequest pageRequest = new PageRequest(0, 10, new Sort(Direction.DESC, &quot;name&quot;));Page&lt;Member&gt; result = memberRepository.findByNameStartingWith(&quot;김&quot;, pageRequest);List&lt;Member&gt; members = result.getContent();int totalPage = result.getTotalPages();boolean hasNextPage = result.hasNextPage(); Web 확장스프링 데이터 프로젝트는 스프링 MVC 에서 사용할 수 있는 기능을 제공한다. 도메인 클래스 컨버터 : HTTP 파라미터로 넘어온 엔티티의 아이디로 엔티티 객체를 찾아서 바인딩해준다. 페이징과 정렬 기능 다음과 같이 설졍하면, 도메인 클래스 컨버터와 페이징과 정렬을 위한 HandlerMethodArgumentResolver 가 스프링 빈으로 등록된다. 123456@Configuration@EnableWebMvc@EnableSpringDataWebSupportpublic class WebAppConfig{ ...} 자바 ORM 표준 프로그래밍 &lt;김영한&gt;","link":"/2019/04/21/spring-data-jpa/"},{"title":"[자바 ORM 표준 JPA 프로그래밍] 13장_웹 어플리케이션과 영속성 관리","text":"컨테이너 환경에서 JPA 가 동작하는 내부 동작 방식을 이해하고, 문제점과 해결방안을 정리하자. 스프링 컨테이너의 기본 전략스프링 컨테이너는 트렌젝션 범위의 영속성 컨텐스트 전략을 기본으로 한다.즉, 트렌젝션을 시작할 때 영속성 컨텍스트를 생성하고 끝날 때 영속성 컨텍스트를 종료한다.그리고, 같은 트렌젝션 안에서는 항상 같은 영속성 컨텍스트에 접근힌디. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Controllerclass HelloController{ @Autowired HelloService helloService; public void hello(){ //반환된 member 엔티티는 준영속 상태 Member member = helloService.logic(); }}@Serviceclass HelloService{ // 엔티티 메니저 주입 @PersistenceContext EntityManager em; @Autowired Repository1 repository1; @Autowired Repository2 repository2; //트랜잭션 시작 @Transactional public void logic(){ repository1.hello(); //Member 는 영속상태 Member member = repository2.findMember(); return member; } //트렌젝션 종료}@Repositoryclass Repository1 { @PersistenceContext EntityManager em; public void hello(){ em.xxx(); //영속성 컨텍스트 접근 }}@Repositoryclass Repository2 { @PersistenceContext EntityManager em; public Member findMember() { return em.find(Member.class, &quot;id1&quot;); //영속성 컨텍스트 접근 }} 준영속 상태와 지연 로딩조회한 엔티티가 서비스와 리포지토리 계층에서는 영속성 컨텍스트에 관리되면서 영속 상태를 유지하지만,컨트롤러나 뷰 같은 프리젠테이션 계층에서는 준영속 상태가 된다.따라서, 변경감지와 지연로딩이 동작하지 않는다. 12345678910111213141516@Entitypublic class Order{ @Id @GeneratedValue private Long id; @ManyToOne(fetch = FetchType.LAZY) // 지연로딩 private Member member; // 주문 회원}class OrderController { public String view(Long orderId){ Order order = orderService.findOne(orderId); Member member = order.getMember(); member.getName(); // 지연로딩 시 예외 발생 }} 변경감지 기능이 프리젠테이션 계층에서 동작하지 않는 것은 문제가 되지 않는다.변경 감지 기능이 프리젠테이션 계층에서도 동작하면 애플리케이션 계층이 가지는 책임이 모호해지고, 데이터를 어디서 어떻게 변경했는지 프리젠테이션 계층까지 다 찾아야 하므로 유지보수하기 어렵다.비즈니스 로직은 서비스 계층에서 끝내야한다. 준영속 상태의 지연 로딩을 해결하는 방법은 두 가지이다. 뷰가 필요한 엔티티를 미리 로딩 OSIV 뷰가 필요한 엔티티를 미리 로딩하는 방법은 어디서 미리 로딩 하느냐에 따라 세가지가 있습니다. 글로벌 페치 전략 수정 JPQL Fetch Join 강제 초기화 글로벌 페치 전략 수정1234567891011121314151617@Entitypublic class Order{ @Id @GeneratedValue private Long id; @ManyToOne(fetch = FetchType.EAGER) // 즉시 로딩 전략 private Member member; // 주문 회원}//Presentation Logicclass OrderController { public String view(Long orderId){ Order order = orderService.findOne(orderId); Member member = order.getMember(); member.getName(); // 이미 로딩된 엔티티 }} 글로벌 페치 전략에 즉시 로딩 사용시 단점은 두가지가 있습니다. 사용하지 않는 엔티티를 로딩order 를 조회하면서 사용하지 않는 member 도 함께 조회한다. N+1 문제 1234567Order order = em.find(Order.class, 1L);//실행된 SQLselect o.*, m.*from Order oleft outer join Member m on o.MEMBER_ID = m.MEMBER_IDwhere o.id = 1 여기까지 보면 글로벌 즉시 로딩 전략이 좋아보이지만, 문제는 JPQL 을 사용할 때 발생한다. 123456789List &lt;Order&gt; orders = em.createQuery(&quot;select o from Order o&quot;, Order.class).getResultList();//실행된 SQLselect * from Order //JPQL 로 실행된 SQLselect * from Member where id = ? //EAGER 로 실행된 SQLselect * from Member where id = ? //EAGER 로 실행된 SQLselect * from Member where id = ? //EAGER 로 실행된 SQLselect * from Member where id = ? //EAGER 로 실행된 SQL... JPA 가 JPQL 을 분석해서 SQL 을 생성할 때, 글로벌 패치 전략을 참고하지 않고 오직 JPQL 자체만 사용한다.따라서, 즉시로딩이든 지연 로딩이등 구분하지 않고 JPQL 쿼리 자체에 충실한 SQL 을 만든다.이런 N+1 문제는 JPQL Fetch Join 으로 해결할 수 있다. JPQL Fetch Join1234567891011121314// Fetch Join 사용 전JPQL : select o from Order oSQL : select * from Order// Fetch Join 사용 후JPQL : select o from Order o join fetch o.member SQL : select o.*, m.* from Order o join Member m on o.MEMBER_ID = m.MEMBER_ID Fetch Join 을 사용하면, SQL JOIN 을 사용해서 페치 조인 대상까지 함께 조회해서, N+1 문제가 발생하지 않는다.하지만, 무분별하게 사용하면 화면에 맞춘 리포지토리 메소드가 증가할 수 있다.결국 프리젠테이션 계층이 데이터 접근 계층을 침범하는 것이다. 강제로 초기화영속성 컨테스트가 살아있을 때 프리젠테이션 계층이 필요한 엔티티를 강제로 초기화해서 반환하는 방법이다. 123456789class OrderService{ @Transactional public Order findOrder(id){ Order order = oderRepository.findOrder(id); order.getMember().getName(); // 프록시 객체를 강제로 초기화 return order; }} 글로벌 페치 전략을 지연로딩으로 설정하면, 연관된 엔티리를 실제 엔티티가 아닌 프록시 객체로 조회한다.프록시 객체는 실제 사용하는 시점에 초기화된다.order.getMember() 까지만 호출하면 단순히 프록시 객체만 반환한다. 아직 초기화 하지 않았다.member.getName() 처럼 실제 값을 사용할 때 초기화된다.프록시 초기화 하는 역할을 서비스 계층이 담당하면, 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야한다. 비즈니스 로직을 담당하는 서비스 계층에서 프리젠테이션 계층을 위한 프록시 초기화 역할을 하는 FACADE 계층이 그 역할을 담당해줄 수 있다. FACADE 계층 추가프리젠테이션 계층과 도메인 모델 계층간의 논리적 의존성을 분리한다.프리젠테이션 계층에서 필요한 프록시 객체를 초기화한다.서비스 계층을 호출해서 비즈니스 로직을 실행한다. 1234567891011121314151617class OrderFacade{ @Autowired OrderService orderService; public Order findOrder(id){ Order order = orderService.findOrder(id); // 프리젠테이션 계층이 필요한 프록시 객체를 강제 초기화 order.getMember().getName(); return order; }}class OrderService{ public Order findOrder(id){ return orderRepository.findOrder(id); }} OSIV (Open Session in View)영속성 컨텍스트를 뷰까지 열어둔다는 뜻이다. 과거 OSIV : 요청 당 트렌젝션OSIV 의 핵심은 뷰에서도 지연로딩이 가능하도록 하는 것이다.가장 단순한 구현은 클라이언트의 요청이 들어오자마자 서플릿 필터나 스프링 인터셉터에서 트렌젝션을 시작하고 요청을 끝날 때 트렌젝션도 끝내는 것이다.이것을 요청 당 트렌젝션 방식의 OSIV 라고 한다.문제는, 프레센테이션 계층이 엔티티를 변경할 수 있다는 것이다. 1234567class MemberControlelr{ public String viewMember(Long id){ Member member = memberService.getMember(id); member.setName(&quot;XXX&quot;); model.addAttribute(&quot;member&quot;, member); }} 개발자의 의도는 단순히 뷰에 노출할 때만 고객이름을 XXX 로 변경하고 싶은 것이지, 데이터베이스에 있는 고객 이름까지 변경하고자 하는 것이 아니다.하지만 요청당 트렌젝션 방식은 뷰 렌더링 이후에 트렌젝션을 커밋한다.커밋을 하면 영속성 컨텍스트를 플러쉬해서, 영속성 컨텍스트의 변경 감지 기능이 동작하여 변경된 엔티티를 데이터베이스에 반영해버린다. 따라서, 프레젠테이션 계층에서 엔티티를 수정하지 못하게 해야한다.다음과 같은 방법이 있다. 엔티티를 읽기 전용 인터페이스로 제공 엔티티 레핑 DTO 만 반환 엔티티를 읽기 전용 인터페이스로 제공1234567891011121314interface MemberView{ public String getName();}@Entityclass Member implements MemberView{ ...}class MemberService { public MemberView getMember(id){ return memberRepository.findById(id); }} 엔티티 레핑엔티티의 읽기 전용 메소드만 가지고 있는 엔티티를 감싼 객체를 만들고, 이것을 프리젠테이션 계층에 반환하는 방법입니다. 123456789101112class MemberWrapper{ private Member member; public MemberWrapper(member){ this.member = member; } // 읽기 전용 메소드만 제공 public String getName(){ member.getName; }} DTO 만 반환12345678910class MemberDTO { private STring name; //GETTER, SETTER}...MemberDTO memberDTO = new MemberDTO();memberDTO.setName(member.getName());return memberDTO; 최근에는 비즈니스 계층에서만 트렌젝션을 유지하는 방식의 OSIV 를 사용한다.스프링 프레임워크가 제공하는 OSIV 방식이다. 스프링 OSIV : 비즈니스 계층 트렌젝션 클라이언트의 요청이 들어오면 영속성 컨텍스트를 생성한다. 이 때, 트렌젝션을 시작하지 않는다. 서비스 계층에서 트렌젝션을 시작하면 앞에서 생성해둔 영속성 켄텍스트에 트렌젝션을 시작한다. 비즈니스 로직을 실행하고 서비스 계층이 끝나면 트렌젝셩르 커밋하면서 영속성 컨텍스트를 플러쉬한다. 이때, 트렌젝션만 종료하고 영속성 컨텍스트를 살려둔다. 클라이언트의 요청이 끝날 때 영속성 컨텍스트를 종료한다. 영속성 컨텍스트는 트렌젝션 범위 안에서 엔티티를 조회하고 수정할 수 있다.영속성 컨텍스트는 트렌젝션 범위 밖에서 엔티티를 조회만 할 수 있다. 자바 ORM 표준 프로그래밍 &lt;김영한&gt;","link":"/2019/06/12/web-application-persistencen-context/"},{"title":"[자바 ORM 표준 JPA 프로그래밍] 15장_고급 주제와 성능 최적화","text":"JPA 를 사용하며 주의할 점과, 성능 최적화 내용을 정리한다. 트랜잭션 롤백트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다. 다음 경우를 보자. 엔티티를 조회해서 수정하는 중에 문제가 발생했다. 트랜잭션이 롤백된다. 데이터베이스의 데이터는 원래대로 복구된다. 수정된 객체는 영속성 컨텍스트에 그대로 남아있다. 그럼 어떻게 해야할까 ? 영속성 컨텍스트를 새로 생성해서 사용하거나 EntityManager.clear() 로 영속성 컨텍스트를 초기화해야한다. 스프링에서는, 트랜잭션당 영속성 컨텍스트의 경우 : 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료 OSIV 인 경우 : 트랜잭션을 롤백하면서 영속성 컨텍스트를 초기화 엔티티 비교영속성 컨텍스트가 같을 때는, 다음 세 조건을 만족한다. identical : == 비교가 같음 equivalent : equals() 비교가 같음 DB equivalent : @Id 인 DB 식별자가 같음 영속성 컨텍스트가 다를 때는, identical 비교에 실패한다. N+1 문제코드보 보자. 12345678910111213141516@Entitypublic class Member { @Id @GeneratedValue private Long id; @OneToMany(mappedBy = &quot;member&quot;, fetch = FetchType.EAGER) private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();}@Entity@Table(name = &quot;ORDERS&quot;)public class Order { @Id @GeneratedValue private Long id; @ManyToOne private Member member;} 위와 같은 경우에, Member 하나를 다음 처럼 조회하면 즉시 로딩으로 설정한 주문 정보도 같이 조회한다. 1em.find(Member.class, id); 실행되는 SQL 은 다음과 같다. 123SELECT M.*, O.*FROM MEMBER MOUTER JOIN ORDERS O ON M.ID=O.MEMBER_ID 여기까지는 좋다. 문제는, 다음처럼, JPQL 을 사용할 때다. 1em.createQuery(&quot;select m from Member m&quot;, Member.class).getResultList(); 실행되는 SQL 은 다음과 같다. 1SELECT * FROM MEMBER 회원 엔티티와 연관된 주문 컬렉션이 즉시 로딩으로 설정되어 있다. 그래서, 즉시 로딩하려고 다음 SQL 을 추가로 실행한다. 1SELECT * FROM ORDERS WHERE MEMBER_ID = ? 조회된 회원이 100명이면, 위와 같은 쿼리가 100번 추가적으로 실행되는 것이다. 지연 로딩과 N+1결론부터 말하면, 지연 로딩의 경우에도 N+1 문제는 동일하게 발생한다. 지연로딩으로 설정하고 JPQL 로 회원들을 조회해보자. 지연 로딩이므로 회원들만 조회되기 때문에, N+1 문제는 여기서 발생하지 않는다.하지만 다음 처럼, 회원이 100명이면 100명의 주문도 100번 조회된다. 이것이 문제다. 123for (Member m : members){ m.getOrders().size(); } 다음 처럼, 1234SELECT * FROM ORDERS WHERE MEMBER_ID = 1SELECT * FROM ORDERS WHERE MEMBER_ID = 2SELECT * FROM ORDERS WHERE MEMBER_ID = 3... Fetch JoinN+1 문제를 해결할 수 있는 간단한 방법이다. fetch join 을 사용하면, 연관된 엔티티를 같이 조회한다. fetch join 을 사용하는 JPQL 은 다음과 같다. 1selectm from Member m join fetch m.orders 실행되는 SQL 은 다음과 같다. 123SELECT M.*, O.*FROM MEMBER MINNER JOIN ORDERS O ON M.ID=O.MEMBER_ID 읽기 전용 쿼리 성능 최적화영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관해서, 더 많은 메모리를 사용한다.데이터를 단순히 조회만 하는 읽기 전용 쿼리의 경우에, 이와 같은 불필요한 메모리 사용이 필요없다. 스칼라 타입으로 조회스칼라 타입으로 모든 타입 조회하면, 영속성 컨텍스트가 결과를 관리하지 않는다. 1select o.id, o.name, o.price from Order o 읽기 전용 쿼리 힌트 사용하이버네이트 전용 힌트인 org.hibernate.readOnly 를 사용하면, 영속성 컨텍스트는 스냅샷을 보관하지 않는다. 12TypedQuery&lt;Order&gt; query = em.createQuery(&quot;select o from Order o&quot;, Order.class);query.setHint(&quot;org.hibernate.readOnly&quot;, true) 읽기 전용 트랜잭션 사용다음 처럼 사용하면, 스프링 프레임워크가 하이버네이트 세션 (JPA Entity Manager 의 구현체) 의 플러쉬 모드를 MANUAL 로 설정한다.그래서, 강제로 플러쉬를 호출하지 않는 한 플러쉬가 일어나지 않는다. 트랜잭션을 커밋해도 영속성 컨텍스트를 플러쉬 하지 않아서, 스냅샷 비교와 같은 무거운 로직이 수행되지 않는다. 1@Transactional(readOnly = true) 트랜잭션 밖에서 읽기트랜잭션을 사용하지 않아서, 플러쉬가 일어나지 않아 조회 성능이 향상된다. 1@Transactional(propagation = Propagation.NOT_SUPPORTED) 배치 처리수백만 건의 데이터를 배치 처리할 때, 엔티티를 계속 조회하면 영속성 컨텍스트에 많은 엔티티가 쌓인다.그러면, 메모리 부족 오류가 발생할 것이다. 그래서, 적절한 단위로 영속성 컨텍스트를 초기화해아한다. 등록 배치100만건의 엔티티를 DB 에 저장한다고 해보자.엔티티 100 건을 저장할 때마다 em.flush() 를 호출하고, em.clear() 할 수 있다. 수정 배치100만건의 데이터를 조회해서 수정한다고 해보자. 한 번에 메모리에 올려둘 수 없어서, pagingpaging 처리 방법을 이용할 수 있다. 즉, 한 번에 100 건씩 페이징 쿼리로 조회하면서 엔티티를 수정하고 영속성 컨텍스트를 flush 하고 clear 한다. cursorcursor 를 이용할 수 있다. 하이버네이트는 scroll 이라는 이름으로 JDBC cursor 를 지원한다. 트랜잭션을 지원하는 쓰기 지연1234567insert(member1); // INSERT INTO...insert(member2); // INSERT INTO...insert(member3); // INSERT INTO...insert(member4); // INSERT INTO...insert(member5); // INSERT INTO...commit(); 네트워크 호출은 비용이 많이 드는 작업이다.위의 경우에, SQL 을 직접 다루면 한 번의 커밋과 다섯 번의 insert SQL 로, 총 여섯 번의 데이터베이스 통신을 한다.최적화 화려면 어떻게 해야할까 ? insert SQL 을 모아서 한 번에 데이터베이스에 보내면 된다.JPA 는 flush 기능으로 이것이 가능하다. SQL Batch1234567em.persist(new Member()); // 1em.persist(new Member()); // 2em.persist(new Member()); // 3em.persist(new Child()); // 4em.persist(new Member()); // 5em.persist(new Member()); // 6em.persist(new Member()); // 7 하이버네이트에서는, hibernate.jdbc.batch_size 속성의 값에 50 을 주면, 최대 50 건씩 모아서 SQL 배치를 실행한다. 그런데 주의할 점은, 같은 SQL 일 때만 유효하다.예를 들어 위의 경우에, 1-3 을 모아서 SQL 배치 실행, 4 를 실행, 5-7 을 모아서 SQL 실행한다. 식별자 생성 전략 IDENTITY엔티티의 식별자 생성 전략이 IDENTITY 이면, 쓰기 지연을 활용한 성능 최적화를 할 수 없다.왜냐하면, 엔티티가 영속 상태가 되려면 식별자가 필요한데, 식별자를 구하려면 데이터베이스에 저장해야 구할 수 있어서 em.persist() 를 호출하면 바로 insert SQL 이 데이터베이스에 전달된다. DB table row lock time 최소화트랜잭션을 지원하는 쓰기 지연의 본질적인 장점은, DB table row lock time 최소화이다.영속성 컨텍스를 flush 하기 전까지는 데이터베이스에 로우에 락을 걸지 않기 떄문이다.다음 로직을 보자. 1234update(member); // UPDATE SQL logicA();logicB();commit(); JPA 를 사용하지 않고 SQL 을 직접 다루면, update(member); 를 호출할 때 UPDATE SQL 이 실행되면서 DB table row 에 lock 을 건다.이 lock 은 commit 을 호출될 때까지 유지된다. 그러면, 현재 수정 중인 데이터를 수정하려는 다른 트랜잭션은 lock 이 풀릴 때까지 기다려야한다. JPA 는 commit() 에서 UPDATE SQL 을 실행하고 바로 트랜잭션을 커밋한다. 즉, 데이터베이스 락에 걸리는 시간을 최소화한다.데이터베이스 락에 걸리는 시간을 최소화하면 뭐가 좋을까? 동시에 더 많은 트랜잭션을 처리할 수 있다. 자바 ORM 표준 프로그래밍 &lt;김영한&gt;","link":"/2019/06/29/jpa-performance-optimize/"},{"title":"[자바 ORM 표준 JPA 프로그래밍] 16장_트랜잭션과 락,2차 캐시","text":"Transaction트랜잭션이란 논리적인 작업의 단위이다. 이 트랜잭션은 ACID 를 보장해야한다. Atomicity트랜잭션 내에서 실행한 작업들은 하나의 작업 처럼, 모두 성공하거나 모두 실패해야한다. Consistency트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야한다.예를 들면, 데이터베이스의 무결성 제약 조건을 항상 만족해야한다. Isolation동시에 실행되는 트랜잭션은 서로 영향을 미치지 않아야한다. Durability트랜잭션을 성공적으로 끝내면, 그 결과가 데이터베이스에 항상 기록되어야한다. 문제는 격리성이다. 트랜잭션간에 완벽하게 격리성을 보장하기 위해서는 어떻게 해야할까 ?트랜잭션을 차례대로 실행해야한다. 그러면, 동시성이 처리 기능이 떨어진다.그래서 트랜잭션 격리 수준이 등장한다. Isolation Level격리 수준이 낮을 수록 더 많은 문제가 발생한다.READ UNCOMMITTED, READ COMMITTED , REPEATABLE READ, SERIALIZABLE 으로 격리 수준이 높아진다.애플리케이션은 대부분 동시성 처리가 중요하기 때문에, 데이터베이스들은 보통 READ COMMITTED 격리 수준이 기본이다. READ UNCOMMITTED커밋하지 않은 데이터를 읽을 수 있다. DIRTY READ 문제가 발생할 수 있다. 트랜잭션 1 이 데이터를 수정하고 있다. 트랜잭션 2 가 수정 중인 데이터를 조회한다. 트랜잭션 1 이 롤백을 하게 되면 데이터 정합성에 문제가 생긴다. READ COMMITTED커밋한 데이터만 읽을 수 있다. NON-REPEATABLE READ 문제가 발생할 수 있다. 트랜잭션 1 이 회원 A 를 조회중이다. 트랜잭션 2 가 회원 A 를 수정하고 커밋한다. 트랜잭션 1 이 다시 회원 A 를 조회하면 수정된 데이터가 조회된다. REPEATABLE READ한 번 조회한 데이터를 반복해서 조회해도 같읕 데이터가 조회된다. PHANTOM READ 문제가 발생할 수 있다. 트랜잭션 1 이 10살 이하의 회원을 조회했다. 트랜잭션 2 가 5살 회원을 추가하고 커밋했다. 트랜잭션 1 이 다시 10살 이하의 회원을 조회하면 회원 하나가 추가된 상태로 조회된다. SERIALIZABLE가장 엄격한 격리수준이다. 동시성 처리 성능이 떨어진다. Optimistic Lock트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법이다.데이터베이스가 제공하는 락 기능을 사용하는 것이 아니라, Application 이 제공하는 락이다.낙관적 락은 트랜잭션을 커밋하기 전까지 트랜잭션 충돌을 알 수 없다. Pessimistic Lock트랜잭션의 충돌이 발생할 것이라 비관적으로 가정하는 방법이다. 그래서, 우선 락을 걸고 본다.데이터베이스가 제공하는 락 기능을 사용한다. Second Lost Updates Problem트랜잭션 만으로는 해결할 수 없는 두 번의 갱실 문제는, 다음과 같은 경우에 발생한다. 사용자 A 와 B 가 동시에 같은 공지사항을 수정하고 있다. 사용자 A 가 먼저 수정 완료 버튼을 눌렀다. 사용자 B 가 수정 완료 버튼을 눌렀다. 결과적으로, 사용자 B 의 수정사항만 반영된다. 해결 방법으로는, 마지막 커밋만 인정 최초 커밋만 인정 충돌하는 갱신 내용 병합 @VersionJPA 가 제공하는 낙관적 락을 사용하기위해서는, @Version 으로 버전 관리 기능을 추가해야한다.다음 처럼, 엔티티에 버전 관리용 필드를 추가하고 @Version 을 붙이면 된다. 12345678@Entitypublic class Person { @Id private String id; private String title; @Version private Integer version;} 엔티티를 수정할 때 마다, 버전이 하나씩 증가한다.그리고, 엔티티를 수정할 때 조회 시점의 버젼과 수정 시점의 버젼이 다르면 예외가 발생한다.그래서, 버전 정보를 사용하면 최초 커밋만 인정된다. 다음 그림으로 보자. Transaction 01 과 Transaction 02 가 조회한다. Transaction 02 가 title 을 B 로 수정하고 커밋한다. Version 이 2 로 증가한다. Transaction 01 이 title 을 C 로 수정하고 커밋하려는 순간, 예외가 발생한다. Version 비교 방법JPA 는 버젼 정보를 어떻게 비교할까 ? 엔티티를 수정하고 트랜잭션을 커밋한다. 영속성 컨텍스트를 flush 하면서, 아래와 같은 update query 를 실행한다.1234567UPDATE PersonSET TITLE = ? VERSION = ? (version + 1 증가)WHERE ID = ? AND VERSION = ? DB 의 버젼이 이미 증가해서 WHERE 문의 VERSION 값이 다르면 수정할 대상이 없기 때문에, JPA 가 예외를 던진다. JPA Lock JPA 에서 추천하는 전략 : READ COMMITTED 트랜잭션 격리 수준 + 낙관적 버전 관리 ( 두 번의 갱신 내역 분실 문제 예방 ) JPA 가 제공하는 Lock Option 은 javax.persistence.LockModeType 에 정의되어 있다. JPA 낙관적 락JPA 낙관적 락을 사용하려면 @Version 이 있어야한다.낙관적 락의 옵션을 하나씩 보자. NONELock Option 을 정의하지 않아도 엔티티에 @Version 을 붙인 필드가 있으면 적용된다.조회 시점부터 수정 시점까지를 보장하여, Second Lost Updates Problem 을 에방한다. OPTIMISTIC엔티티를 조회만 해도 버젼을 체크한다.즉, 한 번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경하지 않음을 보장한다.트랜잭션을 커밋할 때 버전 정보를 조회해서 (SELECT) 현재 엔티티의 버젼과 같은지 검증한다.NONE Option 은 엔티티를 수정해야 버전 정보를 확인하지만, OPTIMISTIC Option 은 엔티티 수정 없이 조회만 해도 버젼을 확인한다. OPTIMISTIC_FORCE_INCREMENT데이터를 수정하지 않아도 트랜잭션을 커밋할 때 버젼 정보가 증가한다. JPA 비관적 락JPA 비관적 락은 DB 트랜잭션 락 메커니즘에 의존한다.비관적 락을 사용하면, 락을 획들할 때까지 트랜잭션이 대기한다.무한정 대기할 수 없으므로 타임아웃을 줄 수 있다. 비관적 락의 옵션을 간단 보자. PESSIMISTIC_WRITE비관적 락이면, 일반적으로 이 옵션이 많이 사용된다.DB select for update 를 사용해서 락을 건다.lock 이 걸린 로우는 다른 트랜잭션이 수정할 수 없다. PESSIMISTIC_READ데이터를 읽기만 하고 수정하지 않는 용도로 락을 건다. PESSIMISTIC_FORCE_INCREMENT비관적 락이지만 버젼 정보를 강제로 증가시킨다. 1차 캐쉬영속성 컨텍스트 범위의 캐쉬이다. 2차 캐쉬애플리케이션 범위의 캐쉬이다. 애플리케이션이 종료될 때까지 캐쉬가 유지된다.예를 들면, EHCACHE 를 2차 캐쉬로 사용할 수 있다. 2차 캐쉬는 캐쉬한 객체의 복사본을 만들어서 반환한다. 왜일까 ?만약 캐쉬한 객체를 그대로 반환하면, 여러 곳에서 같은 객체를 동시에 수정하는 문제가 발생할 수 있다.이 문제를 해결하기 위해, 락을 걸면 동시성이 떨어질 수 있다.그래서, 객체를 복사해서 반환한다. 자바 ORM 표준 프로그래밍 &lt;김영한&gt;","link":"/2019/06/30/jpa-transaction-lock/"},{"title":"[오브젝트] 1장_객체, 설계","text":"티켓 판매 애플리케이션관람객이 초대장이 있으면 초대장을 티켓으로 바꿔서 극장에 입장하고, 없으면 티켓을 구입한 후에 극장에 입장하는 간단한 애플리케이션을 구현한다. 초대장을 구현한다. 123456import java.time.LocalDateTime;public class Invitation { private LocalDateTime when;} 티켓을 구현한다. 12345678public class Ticket { private Long fee; public Long getFee() { return fee; }} 관람객의 가방을 구현한다. 1234567891011121314151617181920212223242526272829303132333435public class Bag { private Long amount; private Invitation invitation; private Ticket ticket; public Bag(Long amount) { this(null, amount); } public Bag(Invitation invitation, Long amount) { this.invitation = invitation; this.amount = amount; } public boolean hasInvitation() { return invitation != null; } public boolean hasTicket() { return ticket != null; } public void setTicket(Ticket ticket) { this.ticket = ticket; } public void minusAmount(Long amount) { this.amount -= amount; } public void plusAmount(Long amount) { this.amount += amount; }} 관람객을 구현한다. 123456789101112public class Audience { private Bag bag; public Audience(Bag bag) { this.bag = bag; } public Bag getBag() { return bag; }} 티켓 판매소를 구현한다. 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class TicketOffice { private Long amount; private List&lt;Ticket&gt; tickets = new ArrayList&lt;&gt;(); public TicketOffice(Long amount, Ticket... tickets) { this.amount = amount; this.tickets.addAll(Arrays.asList(tickets)); } public Ticket getTicket() { return tickets.remove(0); } public void minusAmount(Long amount) { this.amount -= amount; } public void plusAmount(Long amount) { this.amount += amount; }} 판매원을 구현한다. 123456789101112public class TicketSeller { private TicketOffice ticketOffice; public TicketSeller(TicketOffice ticketOffice) { this.ticketOffice = ticketOffice; } public TicketOffice getTicketOffice() { return ticketOffice; }} 극장을 구현한다. 1234567891011121314151617181920public class Theater { private TicketSeller ticketSeller; public Theater(TicketSeller ticketSeller) { this.ticketSeller = ticketSeller; } public void enter(Audience audience) { if (audience.getBag().hasInvitation()) { Ticket ticket = ticketSeller.getTicketOffice().getTicket(); audience.getBag().setTicket(ticket); } else { Ticket ticket = ticketSeller.getTicketOffice().getTicket(); audience.getBag().minusAmount(ticket.getFee()); ticketSeller.getTicketOffice().plusAmount(ticket.getFee()); audience.getBag().setTicket(ticket); } }} 무엇이 문제인가로머트 마틴에 따르면 모든 모듈 (크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소) 은 제대로 실행되어야 하고 이해하기 쉽고 변경이 용이해야한다. 위 티켓 판매 애플리케이션은 1번만 만족한다. 왜일까 ? 예상을 빗나가는 코드현재의 코드는 우리의 예상과는 너무 다르게 동작하기 때문에 코드를 읽는 사람과 의사소통하지 못한다.관람객의 입장에서 문제는, 소극장이라는 제 3자가 초대장 확인을 위해 가방을 마음대로 열어본다.판매원 입장에서 문제는, 소극장이 매표소에 보관 중인 티켓과 현금을 마음대로 열어본다. 변경에 취약한 코드세부적인 사실이 바뀌면 해당 클래스뿐만 아니라 이 클래스에 의존하는 Theater 도 함께 변경해야한다.그래서, 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야한다. 설계 개선하기자율성을 높여서, 개선해보자.즉, Audience 와 TicketSeller 가 직접 Bag 과 TicketOffice 를 처리하도록 자율적인 존재가 되도록 수정하자. Theater 를 다음과 같이 수정한다. 123456789101112public class Theater { private TicketSeller ticketSeller; public Theater(TicketSeller ticketSeller) { this.ticketSeller = ticketSeller; } public void enter(Audience audience) { ticketSeller.sellTo(audience); }} TicketSeller 를 다음과 같이 수정한다. 123456789101112131415161718192021222324public class TicketSeller { private TicketOffice ticketOffice; public TicketSeller(TicketOffice ticketOffice) { this.ticketOffice = ticketOffice; } public TicketOffice getTicketOffice() { return ticketOffice; } public void sellTo(Audience audience) { if (audience.getBag().hasInvitation()) { Ticket ticket = ticketOffice.getTicket(); audience.getBag().setTicket(ticket); } else { Ticket ticket = ticketOffice.getTicket(); audience.getBag().minusAmount(ticket.getFee()); ticketOffice.plusAmount(ticket.getFee()); audience.getBag().setTicket(ticket); } }} 하지만, Audience 는 여전히 자율적인 존재가 아니다.TicketSeller 가 Audience 내부의 Bag 에 접근을 직접하고 있기 때문이다. 그래서, TicketSeller 다음과 같이 수정한다. 12345678910111213141516public class TicketSeller { private TicketOffice ticketOffice; public TicketSeller(TicketOffice ticketOffice) { this.ticketOffice = ticketOffice; } public TicketOffice getTicketOffice() { return ticketOffice; } public void sellTo(Audience audience) { ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket())); }} Audience 다음과 같이 수정한다. 1234567891011121314151617181920212223public class Audience { private Bag bag; public Audience(Bag bag) { this.bag = bag; } public Bag getBag() { return bag; } public long buy(Ticket ticket) { if (bag.hasInvitation()) { bag.setTicket(ticket); return 0L; } else { bag.setTicket(ticket); bag.minusAmount(ticket.getFee()); return ticket.getFee(); } }} 무엇이 개선됐는가Audience 와 TicketSeller 의 내부 구현을 변경하더라도 Theater 를 함께 변경할 필요가 없어졌다.수정된 코드는 변경 용이성의 측면에서 확실히 개선됐다. 어떻게 한 것인가객체의 자율성을 높였다.핵심은, 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해 상호작용 하도록 만드는 것이다. 더 개선할 수 있다Bag 을 자율적인 존재로 만들자. 1234567891011121314151617181920212223242526272829303132333435363738public class Bag { private Long amount; private Invitation invitation; private Ticket ticket; public Bag(Long amount) { this(null, amount); } public Bag(Invitation invitation, Long amount) { this.invitation = invitation; this.amount = amount; } public Long hold(Ticket ticket) { if (hasInvitation()) { setTicket(ticket); return 0L; } else { setTicket(ticket); minusAmount(ticket.getFee()); return ticket.getFee(); } } private boolean hasInvitation() { return invitation != null; } private void setTicket(Ticket ticket) { this.ticket = ticket; } private void minusAmount(Long amount) { this.amount -= amount; }} 이제 Audience 는 Bag 의 구현이 아닌, 인터페이스에만 의존할 수 있다. 123456789101112public class Audience { private Bag bag; public Audience(Bag bag) { this.bag = bag; } public long buy(Ticket ticket) { return bag.hold(ticket); }} TickSeller 역시 TicketOffice 에 있는 Ticket 을 마음대로 접근하고 있다.개선하자. TickSeller 를 수정한다. 123456789101112public class TicketSeller { private TicketOffice ticketOffice; public TicketSeller(TicketOffice ticketOffice) { this.ticketOffice = ticketOffice; } public void sellTo(Audience audience) { ticketOffice.sellTicketTo(audience); }} TicketOffice 를 수정한다. 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class TicketOffice { private Long amount; private List&lt;Ticket&gt; tickets = new ArrayList&lt;&gt;(); public TicketOffice(Long amount, Ticket... tickets) { this.amount = amount; this.tickets.addAll(Arrays.asList(tickets)); } public void sellTicketTo(Audience audience) { plusAmount(audience.buy(getTicket())); } private Ticket getTicket() { return tickets.remove(0); } private void plusAmount(Long amount) { this.amount += amount; }} 의인화Theater, Bag, TicketOffice 는 실세계에서 자율적인 존재가 아니다.하지만 비록 현실에서는 수동적인 존재라고 하더라도 객체지향 세계에서는 모든 것이 능동적이고 자율적인 존재가 된다.이것을 의인화라고 한다. 객체지향 설계훌륭한 객체지향 설계는, 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다.협력하는 객체들 사이의 의존성을 적절하게 조절해서 변경에 용이한 설계를 만들어야한다. Source Codehttps://github.com/junhee-ko/object-ticket-example 오브젝트 &lt;조영호&gt;","link":"/2019/11/04/object-chapter1/"},{"title":"[오브젝트] 2장_객체지향 프로그래밍","text":"영화 예매 시스템사용자가 영화 시스템을 이용해서 영화를 예매할 수 있는 애플리케이션을 구현한다. 협력, 객체, 클래스객치지향 패러다임은, 클래스가 아닌 객체에 초점을 맞춰야한다. 다음 두가지에 집중해야 한다. 어떤 클래스가 필요한지를 고민하기 전에, 어떤 객체들이 필요한지 고민하라. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 객체는 독립적인 존재가 아니라, 기능 구현을 위한 협력 공동체의 일원이다. 도메인의 구조를 따르는 프로그램 구조도메인이란, 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야이다.객체지향 패러다임에서는, 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결된다.일반적으로 클래스의 이름은, 대응되는 도메인의 개념의 이름과 동일하거나 유사하게 지어야한다. 클래스 구현하기클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은, 클래스의 경계를 구분짓는 것이다.외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게해야한다.경계의 명확성이 객체의 자율성을 보장하기 때문이다. 또, 프로그래머에게 구현의 자유를 제공하기 때문이다. 자율적인 객체객체는 스스로 판단하고 행동하는 자율적인 존재다.객체가 자율적인 존재가 되기 위해서는, 외부의 간섭을 최소화해야한다.캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. (인터베이스와 구현의 분리) Public Interface : 외부에서 접근 가능한 부분 Implementation : 외부에서 접근 불가능한 부분 프로그래머의 자유프로그래머의 역할은, 클래스 작성자와 클라이언트 프로그래머로 구분할 수 있다. 클래스 작성자 : 새로운 데이터 타입을 프로그램에 추가 클라이언트 프로그래머 : 클래스 작성자가 추가한 데이터 타입을 사용 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨야한다.클라이언트 프로그래머가 숨겨 놓여진 부분에 접근하는것을 막아 내부 구현을 마음대로 변경할 수 있다.객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야할 지식 양이 줄고 클래스 작성자가 자유롭게 구현을 변경할 수 있다.변경될 가능성이 있는 세부적인 내용은 private 영역으로 감춰 변경으로 인한 혼란을 막을 수 있다. Screening 클래스는 사용자들이 예매하는 대상인 ‘상영’ 도메인이다. 12345678910111213141516171819202122232425262728293031323334import java.time.LocalDateTime;public class Screening { private Movie movie; private int sequence; private LocalDateTime whenScreened; public Screening(Movie movie, int sequence, LocalDateTime whenScreened) { this.movie = movie; this.sequence = sequence; this.whenScreened = whenScreened; } public LocalDateTime getStartTime() { return whenScreened; } public boolean isSequence(int sequence) { return this.sequence == sequence; } public Money getMovieFee() { return movie.getFee(); } public Reservation reserve(Customer customer, int audienceCount) { return new Reservation(customer, this, calculateFee(audienceCount), audienceCount); } private Money calculateFee(int audienceCount) { return movie.calculateMovieFee(this).times(audienceCount); }} Money 는 금액과 관련된 여러 계산을 구현하는 클래스이다.금액을 Money 클래스로 정의하면, 저장하는 값이 금액과 관련돼 있다는 의미를 전달 할 수 있다. (Long Type 은 그렇지 못함)객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839import java.math.BigDecimal;public class Money { public static final Money ZERO = Money.wons(0); private final BigDecimal amount; public Money(BigDecimal amount) { this.amount = amount; } public static Money wons(long amount) { return new Money(BigDecimal.valueOf(amount)); } public static Money wons(double amount) { return new Money(BigDecimal.valueOf(amount)); } public Money plus(Money amount) { return new Money(this.amount.add(amount.amount)); } public Money minus(Money amount) { return new Money(this.amount.subtract(amount.amount)); } public Money times(double percent) { return new Money(this.amount.multiply(BigDecimal.valueOf(percent))); } public boolean isLessThan(Money other) { return amount.compareTo(other.amount) &lt; 0; } public boolean isGreaterThanOrEqual(Money other) { return amount.compareTo(other.amount) &gt;= 0; }} Reservation 클래스는 영화 예매 도메인이다. 1234567891011121314public class Reservation { private Customer customer; private Screening screening; private Money money; private int audienceCount; public Reservation(Customer customer, Screening screening, Money money, int audienceCount) { this.customer = customer; this.screening = screening; this.money = money; this.audienceCount = audienceCount; }} 협력객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 ‘요청’ 할 수 있다. 요청 받은 객체는 요청 처리후에 ‘응답’ 한다.객체가 다른 객체와 상호작용하는 방법은, ‘메세지’ 를 전송하는 것뿐이다. 메세지를 받는 객체는 메세지를 ‘수신했다’ 고 한다.수신된 메세지를 처리하기 위한 자신만의 방법을 ‘메서드’ 라고 한다. 메시지를 수신한 Movie 는 스스로 자신의 적절한 메서드를 선택한다. 할인 요금 계산을 위한 협력 시작하기Movie 클래스를 구현하자.calculateMovieFee 메서드에는 어떤 할인 정책을 사용할 것인지 결정하는 코드가 안보인다.여기에는 상속과 다형성 개념이 숨겨져있다. 123456789101112131415161718192021222324import java.time.Duration;public class Movie { private String title; private Duration runningTime; private Money fee; private DiscountPolicy discountPolicy; public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) { this.title = title; this.runningTime = runningTime; this.fee = fee; this.discountPolicy = discountPolicy; } public Money getFee() { return fee; } public Money calculateMovieFee(Screening screening) { return fee.minus(discountPolicy.calculateDiscountAmount(screening)); }} 할인 정책과 할인 조건할인 정책은, 금액 할인 정책과 비율 할인 정책으로 나뉜다.두 클래스는 대부분의 코드가 유사하고 할인 요금 계산하는 방식만 조금 다르기 때문에, 중복 코드 제거를 위해 추상 클래스를 사용한다.부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 Template Method Pattern 을 이용했다. 12345678910111213141516171819202122232425import java.util.ArrayList;import java.util.Arrays;import java.util.List;public abstract class DiscountPolicy { private List&lt;DiscountCondition&gt; conditions = new ArrayList&lt;&gt;(); public DiscountPolicy(DiscountCondition... conditions) { this.conditions = Arrays.asList(conditions); } public Money calculateDiscountAmount(Screening screening) { for (DiscountCondition condition : conditions) { if (condition.isSatisfiedBy(screening)) { return getDiscountAmount(screening); } } return Money.ZERO; } protected abstract Money getDiscountAmount(Screening screening);} 1234567891011121314public class AmountDiscountPolicy extends DiscountPolicy { private Money discountAmount; public AmountDiscountPolicy(Money discountAmount, DiscountCondition... conditions) { super(conditions); this.discountAmount = discountAmount; } @Override protected Money getDiscountAmount(Screening screening) { return discountAmount; }} 1234567891011121314public class PercentDiscountPolicy extends DiscountPolicy { private double percent; public PercentDiscountPolicy(double percent, DiscountCondition... conditions) { super(conditions); this.percent = percent; } @Override protected Money getDiscountAmount(Screening screening) { return screening.getMovieFee().times(percent); }} 할인 조건은, 순번 조건과 기간 조건으로 나뉜다. 1234public interface DiscountCondition { boolean isSatisfiedBy(Screening screening);} 12345678910111213public class SequenceCondition implements DiscountCondition { private int sequence; public SequenceCondition(int sequence) { this.sequence = sequence; } @Override public boolean isSatisfiedBy(Screening screening) { return screening.isSequence(sequence); }} 12345678910111213141516171819202122import java.time.DayOfWeek;import java.time.LocalTime;public class PeriodCondition implements DiscountCondition { private DayOfWeek dayOfWeek; private LocalTime startTime; private LocalTime endTime; public PeriodCondition(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) { this.dayOfWeek = dayOfWeek; this.startTime = startTime; this.endTime = endTime; } @Override public boolean isSatisfiedBy(Screening screening) { return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &amp;&amp; startTime.compareTo(screening.getStartTime().toLocalTime()) &lt;= 0 &amp;&amp; endTime.compareTo(screening.getStartTime().toLocalTime()) &gt;= 0; }} 할인 정책 구성하기생성자의 파라미터 목록을 이용해 초기화에 필요한 정보를 전달하도록 강제하면, 올바른 상태를 가진 객체의 생성을 보장할 수 있다.위에서 정의한 Movie 의 생성자는 오직 하나의 DiscountPolicy 인스턴스만 받을 수 있도록 선언되어 있다.반면, DiscountPolicy 의 생성자는 여러 개의 DiscountCondition 인스턴스를 허용한다. 컴파일 시간 의존성, 실행 시간 의존성코드의 의존성과 실행시점의 의존성이 서로 다를 수 있다.Movie 인스턴스는 실행 시에 AmountDiscountPolicy 나 PercentDiscountPolicy 의 인스턴스에 의존해야한다.하지만, 코드 수준에서 Movie 클래스는 두 클래스중 어떤 것에도 의존하지 않는다. 오직 추상 클래스인 DiscountPolicy 에만 의존한다. 차이에 의한 프로그래밍부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을, 차이에 의한 프로그래밍이라고 한다.AmountDiscountPolicy 와 PercentDiscountPolicy 는 DiscountPolicy 에서 정의한 추상 메서드를 오버라이딩해서 DiscountPolicy 의 행동을 수정한다. 상속과 인터페이스자식 클래스는 부모 클래스가 수신할 수 있는 모든 메세지를 수신할 수 있기 때문에, 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 한다.Movie 는 협력 객체가 calculateMovieFee 라는 메세지를 이해할 수 있으면, 그 객체가 어떤 인스턴스인지 상관하지 않는다.즉, 자식 클래스인 AmountDiscountPolicy 와 PercentDiscountPolicy 는 부모 클래스의 인터페이스를 물려받아서 부모 클래스 대신 사용될 수 있다. 12345678import java.time.Duration;public class Movie { public Money calculateMovieFee(Screening screening) { return fee.minus(discountPolicy.calculateDiscountAmount(screening)); }} 다형성Movie 는 동일한 메세지를 전송하지만, 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 다르다. 이것이 다형성이다.다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다.다형성을 구현하는 방법은 다양하지만, 공통점은 메세지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행시점에 결정한다는 것이다.이를 지연바인딩, 동적바인딩 이라고 한다. 추상화같은 계층에 속하는 클래스들이 공통으로 가질 수 있는 인턴페이스를 구현하며 구현의 일부 (추상클래스) 또는 전체 (인터페이스) 를 자식 클래스가 결정할 수 있도록 결정권을 위임한다.추상화의 장점은, 세부사항에 억눌리지 않고 상위 개념만으로 도메인의 중요한 개념을 설명할 수 있다( Movie - DiscountPolicy - DiscountCondition ) 기존 구조를 수정하지 않고, 새로운 기능을 쉽게 추가하고 확장할 수 있다. 유연한 설계책임의 위치를 결정하기 위해, 조건문을 사용하는 것은 협력의 설계 측면에서 좋지 않은 선택이다.0 원 이라는 할인 요금을 계산할 책임을 그대로 DiscountPolicy 계층에 유지하기 위해, NoneDiscountPolicy 클래스를 추가할 수 있다.그럼, 기존의 Movie 와 DiscountPolicy 는 수정하지 않고, 새로운 클래스를 추가하는 것만으로 애플리케이션 환장이 가능하다. 1234567public class NoneDiscountPolicy extends DiscountPolicy { @Override protected Money getDiscountAmount(Screening screening) { return Money.ZERO; }} 상속상속의 단점은, 캡슐화 위반이다. 부모 클래스가 변경되면, 자식 클래스도 함께 변경될 확률이 높다. 설계가 유연하지 않다. 부모클래스와 자식클래스의 관계를 컴파일 시점에 결정해서 실행시점에 객체의 종류를 변경할 수 없다. 인스턴스 변수로 연결하면, 실행 시점에 할인 정책을 간단히 변경할 수 있다. 합성인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법이 합성이다.합성은 상속의 두가지 문제를 해결한다. 인터페이스에 정의된 메세지를 통해서만 재사용하기 때문에 구현을 효과적으로 캡슐화한다. 의존하는 인스턴스를 교체하는 것이 쉽기 때문에 유연하다. 상속은 클래스를 통해 강하게 결합되지만, 합성은 메세지를 통해 느슨하게 결합된다. 오브젝트 &lt;조영호&gt;","link":"/2019/11/06/object-chapter2/"},{"title":"[오브젝트] 3장_역할, 책임, 협력","text":"객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고 한다.객체가 협력에 참여하기 위해 수행하는 로직은 책임이다.객체들이 협력 안에서는 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다. 협력자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메세지를 전송해 협력을 요청한다.메세지 전송은 객체 간 협력을 위해 사용할 수 있는 유일한 수단이다.메세지를 수신한 객체는 메세드를 실행해 요청에 응답한다.Screening 이 Movie 에게 처리를 위임하는 이유는 요금을 계산하는데 필요한 기본 요금과 할인 정책을 가장 잘 알고 있는 객체가 Movie 이기 때문이다. 협력이 설계를 위한 문맥을 결정Movie 객체는 어떤 행동을 수행할 수 있어야할까 ?Movie 의 행동을 결정하는 것은 영화 예매를 위한 협력이다.Movie 가 기본 요금인 fee 와 할인 정책인 discountPolicy 라는 인스턴스 변수를 상태의 일부로 포함하고 있는 이유는, 요금 계산이라는 행동을 수행하는데 이 정보들이 필요하기 때문이다.객체가 참여하는 협력이 객체를 구성하는 행동과 상태를 결정한다. 책임객체는 협력에 필요한 지식과 방법을 가장 잘 알고 있는 객체에게 도움을 요청한다. 책임을 할당한다는 것은 메세지의 이름을 결정하는 것과 같다. ex) 예매하라 메세지를 선택했으면 메세지를 처리할 적절한 객체를 선택해야한다. 영화 예매와 관련된 정보를 가장 많이 알고 있는 객체에게 할당하 것이 바람직다. ex) Screening 영화 예매를 위해서는 예매 가격을 계산해야한다. Screening 은 예매에 대해서는 정보 전문가지만, 영화 가격 자체에 대해서는 모른다. 그래서 외부의 객체에게 가격 계산을 요청해야한다. 새로운 메세지가 필요하다. ex) 가격을 계산하라 가격 계산을 위해 정보 전문가가 필요하다. ex) Movie 책임 주도 설계책임 주도 설계란, 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법이다.협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다. 협력이 책임을 이끌어내고 책임이 협력에 참여할 객체를 결정한다.책임을 할당할 때 고려해야할 두 가지 요소 메세지가 객체를 결정 행동이 상태를 결정 메세지가 객체를 결정메세지가 객체를 선택해야하는 이유는, 객체가 최소한의 인터페이스를 가지게 된다. 추상적인 인터페이스를 가질 수 있다. 무엇을 하는지만 표현해야지, 어떻게 수행하는지는 노출해서는 안된다. 행동이 상태를 결정객체가 협력에 적합한지를 결정하는 것은 그 객체의 행동이다.상태는 단지 객체가 행동을 정상 수행하기 위한 필요한 재료일 뿐이다.협력이 객체의 행동을 결정하고 행동이 상태를 결정한다.그 행동이 객체의 책임이다. 역할역할은, 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합이다.‘예매하라’ 라는 메세지를 처리하기 위해 적합한 객체로 Screening 을 선택하는 데는 두가지 단계가 있다. 영화 예매를 할 수 있는 적절한 역할이 무엇인가 ? 역할을 수행할 객체로 Screening 인스턴스를 선택한다. 유연하고 재사용 가능한 협력AmountDiscountPolicy 와 PercentDiscountPolicy 인스턴스라는 두가지 종류의 객체가 할인 요금을 계산하라 라는 메세지에 응답할 수 있어야한다.그럼, 두 종류의 객체가 참여하는 협력을 개별적으로 만들어야할까?할인 요금을 계산하라라는 메세지에 응답할 수 있는 대표자를 생각한다면 두 협력을 하나로 통합할 수 있다.이 대표자를 협력에서는 두 종류의 객체로 바꿔 끼울 수 있는 슬롯으로 생각할 수 있다. 이 슬롯이 역할이다.변경 전의 절차적 설계에서는 Theater 가 전체적인 작업을 도맡아 했다. 변경 후의 객체지향 설계에서는 각 객체가 자신이 맡은 일을 스스로 처리했다. 역할의 구현역할을 구현하는 방법은, 추상 클래스 (책임의 일부를 구현해 놓은 것) 인터페이스 (구현 하나 없이, 책임의 집합을 나열해 놓은 것) 객체 대 역할협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 된다.한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다.설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 중요하다.단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제하며, 필요한 순간에 객체로부터 역할을 분리하는 것이 좋다. 역할과 추상화추상화를 이용한 설계의 장점은, 중요한 정책을 상위 수준에서 단순화할 수 있다. 설계가 유연해진다. 오브젝트 &lt;조영호&gt;","link":"/2019/11/12/object-chapter3/"},{"title":"[오브젝트] 4장_설계 품질과 트레이드오프","text":"훌륭한 설계란, 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것이다.적절한 비용 안에서 쉽게 변경할 수 있는 설계는, 응집도가 높고 서로 느슨하게 결합되어 있다.결합도와 응집도를 합리적인 수준으로 유지할 수 있는 원칙은, 객체의 행동에 초점을 맞추는 것이다. 캡슐화상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기위해서다.변경될 가능성이 높은 것을 구현, 상대적으로 안정적인 것을 인터페이스라고 한다.캡슐화란, 변경 가능성이 높은 것을 객체 내부로 숨기는 추상화 기법이다. 응집도응집도는 모듈에 포함된 내부 요소들이 연관되어 있는 정도이다.객체 지향 관점에서는, 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지이다.응집도가 높은 설계에서는, 하나의 요구사항 변경을 반영하기 위해 오직 하나의 모듈만 수정하면 된다.응집도가 낮은 설계에서는, 하나의 원인에 의해 변경해야 하는 부분이 다수의 모듈에 분산되어 있기 때문에 여러 모듈을 동시 수정해야한다. 결합도결헙도는 의존성의 정도이다.다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도이다.내부 구현을 변경하면 이것이 다른 모듈에 영향을 미치는 경우 두 모듈 사이의 결합도가 높다고 말한다.반면, 퍼블릭 인터페이스를 수정했을 때만 다른 모듈에 영향을 미치면 결합도가 낮다고 말한다.그래서 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.이것이 인퍼페이스에 대해 프로그래밍 하라 이다. 데이터 중심 설계의 문제점데이터 중심 설계는 변경에 취약하다. 이유는, 너무 이른시기에 데이터를 결정하도록 강요한다. 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다. 데이터 중심 설계는 객체의 행동보다, 상태에 초점을 맞춘다.데이터 중심 관점에서 객체는 그저 단순한 데이터의 집합이다.그래서, 접근자와 수정자를 과도하게 추가하여 객체의 캡슐화가 무너진다. 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하면,데이터에 관한 지식이 객체의 인터페이스에 드러난다.결과적으로, 객체의 인터페이는 구현을 캡슐화 하는데 실패하고 코드는 변경에 취약해진다. 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 결정한다.객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하면,이미 구현된 객체의 인터페이스를 억지로 끼워넣게 된다.협력의 문맥 안에서 필요한 책임을 결정하고 이를 수행할 적절한 객체를 결정하는 것이 가장 중요하다.설계의 중심이 객체의 내부가 아니라 외부에 맞추어져 있어야한다. 오브젝트 &lt;조영호&gt;","link":"/2019/11/17/object-chapter4/"},{"title":"[오브젝트] 5장_책임 할당하기","text":"데이터 중심 설계로 인한 문제를 해결하기 위한 가장 기본적인 방법은, 책임에 초점을 맞추는 것이다.이번 장에서는 GRASP 패턴을 살펴본다.결합도와 응집도를 합리적인 수준으로 유지할 수 있는 원칙이 있다. 객체의 행동에 초점을 맞추는 것이다.이번 장에서는 책임이 아닌, 상태를 표현하는 데이터 중심의 설계를 보고 객체지향적으로 설계한 구조와 어떤 차이가 있는지 확인한다.상속, 지연 바인딩도 중요하지만, 구현 측면에 치우쳐져 있기 때문에 객체지향 패러다임의 본질과는 거리가 멀다. 01 책임 주도 설계를 향해두 가지 원칙이 있다. 데이터보다 행동을 먼저 결정하라 협려이라는 문맥안에서 책임을 결정하라 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하기 위해 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. 그래서 책임에 초점을 맞추면 안정적인 설계를 할 수 있다. 데이터보다 행동을 먼저 결정하라데이터는 객체가 책임 수행을 위해 필요한 재료일 뿐이다.“이 객체가 해야하는 책임은 무엇인가” 를 결정하고, 이 책임을 수행하는데 필요한 데이터는 무엇인가 결정해라. 99 Page 객체의 종류를 저장하는 인스턴스 변수 (movieType) 와 인스턴의 종류에 따라 배타적으로 상용될 인스턴스 변수 (discountAmount, discountPercent) 를 하나의 클래승 안에 포함시키는 방식은 데이터 중심 설계에서 흔히 보인다.메세지를 수신한 객체는 메세드를 실행해 요청에 응답한다. Screening 이 Movie 에게 처리를 위임하는 이유는 요금을 계산하는데 필요한 기본 요금과 할인 정책을 가장 잘 알고 있는 객체가 Movie 이기 때문이다.자율적인 객체란 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체이다. 객체의 자율성을 보장하기 위해서는 필요한 정보와 정보에 기반한 행동을 같은 객체 안에 모아두어야 한다.결과적으로 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화 하는 것이다.자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메세지를 전송해 협력을 요청한다. 협력이라는 문맥 안에서 책임을 결정하라책임은 객체의 입장이 아니라, 객체가 참여하는 협력에 적합해야한다. 즉, 메세지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야한다. 책임 주도 설계 시스템이 사용자에게 제공해야 하는 기능인, 시스템 책임을 파악 시스템 책임을 더 작은 책임으로 분할 분할된 책임을 수행할 적절한 객체, 또는 역할을 찾아 책임 할당 객체가 책임 수행중 다른 객체의 도움이 필요하면, 이를 책임질 적절한 객체나 역할 찾음 해당 객체 또는 역할에게 책임 할당해서 두 객체가 협력하도록 02 책임 할당을 위한 GRASP 패턴General Responsibility Assignment Software Pattern : 일반적인 책임 할당을 위한 소프트웨어 패턴객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다. 도메인 개념에서 출발하기어떤 책임을 할당할 때 가장 먼저 고민해야하는 유력한 후보는 도메인 개념이다. 필요한 것은 도메인을 그대로 투영한 모델이 아니라, 구현에 도움이 되는 모델이다.도메인 개념을 정리하는데 많은 시간을 들이지 말고,빠르게 설계와 구현을 진행하라. 정보 전문가에게 책임을 할당하라 메세지를 전송할 객체는 무엇을 원하는가 ?협력을 시작하는 객체는 미정이다. 하지만 객체가 원하는 것은 영화를 예매하는 것이다. 따라서 메세지는 “예매하라” 메세지를 수신할 객체는 누구인가 ?책임을 수행할 정보를 알고 있는 객체에게 책임을 할당해라. (정보 전문가 패턴) 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수 있다. 정보 전문가가 반다스 데이터를 저장하고 있을 필요는 없다. 여기서는, 영화에 대한 정보와 상영 시간, 상영 순번 등 예매에 필요한 정보를 알고 있는 “상영” 이 적합하다. Screening 내부로 들어가 메세지 처리에 필요한 절차와 구현을 고민한다.“예매하라” 메세지를 완료하기 위해 예매 가격을 계산하는 작업이 필요하다. 가격 계산하는데 필요한 정보를 상영이 모르기 때문에 외부 객체에게 도움을 요청해야한다. 새로운 메세지“가격을 계산하라” 책임질 객체 선택Movie 가격 계산을 위해 Movie 가 어떤 작업을 해야하나할인 조건에 따라 영화가 할인 가능한지 판단해아한다 새로운 메세지“할인 여부를 판단해라” 책임질 객체 선택DiscountCondition DiscountCondition 은 자체적으로 할인 여부를 판단하는데필요한 정보를 알고 있어서 외부의 도움 없이 스스로 판단할 수 있다. 높은 응집도와 낮은 결합도Movie 대신 Screening 이 직접 DiscountCondition 과 협력하도록 하는건 어떨까 ?높은 응집도와 낮은 결합도를 얻을 수 있는 설계를 선택해야한다.도메인 상으로 Movie 가 DiscountCondition 목록을 속성으로 포함하고 있다. 이미 결합되어 있기 때문에 Movie 가 DiscountCondition 과 협력하게 하면 설계 전체적으로 결합도를 추가하지 않고 협력을 완성할 수 있다.Screening 이 DiscountCondition 과 협력한다면 Screening 이 영화 요금 계산과 관련된 책임 일부를 맡아야한다. 그래서, 영화 예매 요금을 계산하는 방식이 바뀔 경우, Screening 도 함께 변경해야한다.반면, Movie 의 주된 책임은 영화 요금 계산이다. 그래서, 영화 요금 계산하는데 필요한 할인 조건을 판단하기 위해 DiscountCondition 과 협력하는 것은 응집도에 아무러 해를 끼치지 않는다. 창조자에게 객체 생성 책임을 할당하라GRASP 의 창조자 패턴은, 객체를 생성할 책임을 어떤 객체에게 할당할지 지침을 제공한다.창조자 패턴은 어떤 방식으로든, 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.Reservation 을 잘 알고 있거나, 긴밀하게 사용하거나, 초기화에 필요한 데이터를 가지고 있는 객체는 무엇인가 ?Screening 이다. Screening 을 Reservation 의 Creator 로 선택해라. 03 구현을 통한 검증Screening 은 영화 예매할 책임을 맡고 있으며, Reservation 인스턴스를 생성할 책임을 수행해야한다. 12345public class Screeing { public Reservation reserve(Customer customer, int audienceCount){ }} Screeing을 구현하는 과정에서, Movie 에 전송하는 메세지의 시그니처는 메세지의 수신자인 Movie 가 아니라 송신자인 Screening 의 의도를 표한한다. 이처럼, Movie 의 구현을 고려하지 않고 필요한 메세지를 결정하면 Movie 의 내부 구현을 캡슐화할 수 있다. DiscountCondition 개선하기151 Page 변경에 취약한 클래스란, 코드를 수정해야하는 이유를 하나 이상 가지는 클래스다.DiscountCondition 은 다음 서로 다른 이유로 변경될 수 있다. 새로운 할인 조건 추가 순번 조건을 판단하는 로직 변경 기간 조건을 판단하는 로직 변경 이를 해결 하기 위해, 변경의 이유에 따라 클래스를 분리해아한다.일반적으로, 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로 시작하는 것이 좋다. 코드를 통해 변경 이유를 파악할 수 있는 방법은, 인스턴스 변수가 초기화 되는 시점을 살펴봐라. 함께 초기화 되는 속성을 기준으로 코드 분리 해야한다.응집도 높은 클래스는 인터스턴 생성할 때 모든 속성을 함께 초기화한다.DiscountCondition 클래스는 순번 조건을 표현하는 경우 sequence 는 초기화되지만, dayOfWeek, startTime, endTime 은 초기화되지 않는다. 인스턴스 변수를 사용하는 방식을 봐라. 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드 분리해야한다.모든 메서드가 객체의 모든 속성을 사용하면 클래스의 응집도가 높다. isSatisfiedByPeriod 메서드는 dayOfWeek, startTime, endTime 은 사용하지만 sequence 는 사용하지 않는다. 타입 분리하기SequnceCondition 과 PeriodCondition 으로 분리한다.SequnceCondition 과 PeriodCondition 은 자신의 모든 인스턴스 변수를 함께 초기화할 수 있다. 그리고, 클래스에 있는 모든 메서드는 동일한 인스턴스 변수 그룹을 사용한다.하지만 이 방법은 두가지 문제가 있다. Movie 클래스가 SequnceCondition 과 PeriodCondition 클래스 양쪽에 결합한다. 새로운 할인 조건 추가가 어렵다. 다형성을 통해 분리하기Movie 입장에서 SequnceCondition 과 PeriodCondition 은 동일한 책임을 수행한다. 즉, 동일한 역할을 수행한다. 역할을 대체할 클래스들 사이에서구현을 공유하면, 추상클래스를 사용 구현 공유가 필요없고 역할을 대체하는 객체들의 책임만 정의하고 싶다면 인터페이스 사용 객체의 타입에 따라 변하는 행동이 있다면, 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당해라. 이것이 다형성 패턴이다. 변경으로부터 보호하기Movie 입장에서 DiscountCondition 의 타입이 캡슐화 된다는 것은 새로운 DiscountCondition 타입을 추가해도, Movie 가 영향을 받닌 않는다. 이처럼, 변경을 캡슐화 하도록 책임 할당하는 것을 GRASP 에서 변경 보호 패턴이라고 한다.클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화하면, 결합도와 응집도를 향상시킨다. Movie 클래스 개선하기AmountDiscountMovie / PercentDiscountMovie / NoneDiscountMovie 변경와 유연성영화에 설정된 할인 정책을 실행중에 변경해야하는 요구사항이 생기면, 상속을 이용하고 있기 때문에 새로운 인스턴스 생성후에 필요한 정보를 복사해야한다. 이것은 번거롭고 오류 발생 가능성이 높다.해결방법은 합성을 이용하는 것이다. 할인 정책을 DiscountPolicy 로 분리하고 Movie 에 합성하도록 하면 유연한 설계가 된다.도메인 모델은 코드에 대한 가이드를 제공해야하고, 코드의 변화에 맞춰 함께 변화해야한다. 04 책임 주도 설계의 대안 최대한 빠르게 목적한 기능을 수행하는 코드를 작성한다. 이해가기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보인느 동작은 바꾸지 않고 내부 구조를 변경한다. 책임 주도 설계에 익숙하지 않으면, 위와 같이 데이터 중심으로 구현하고 이를 리팩터링하는 것도 방법이다. 메서드 응집도ReservationAgency 에 포함된 로직들을 적절한 객체의 책임으로 분배한다. 긴 메서드의 단점은, 코드를 전체적으로 이해하는데 너무 많은 시간 소요 변경이 필요할 때 수정할 부분 찾기 힘듦 메서드 내부 일부 로직을 수정하더라도 메서드 나머지 부분에서 버그 발생 가능 로직의 일부만 재사용 불가능 코드 중복 초래 짧고 이해하기 쉬운 이름으로 된 메서드는, 다른 메서드에서 사용될 확률 높음 일련의 주석을 읽는 것 같은 느낌 오버라이딩 쉬움 객체로 책임을 분배할 때 가장 먼저, 메서드를 응집도 높은 수준으로 분해하는 것이다. 메서드들의 응집도가 높아졌지만, ReservationAgency 의 응집도는 아직 낮다. 그래서, 변경의 이유가 다른 메서드들을 적절한 위치에 분배한다. 적절한 위치란, 각 메서드가 사용하는 데이터를 정의하고 있는 클래스다.isDiscountable 메서드가 ReservationAgency 에 속할 때는 구현의 일부였지만, DiscountCondition 에 옮기고 나서는 퍼블릭 인터페이스의 일부가 된다. 오브젝트 &lt;조영호&gt;","link":"/2019/11/18/object-chapter5/"},{"title":"[오브젝트] 6장_메세지와 인터페이스","text":"이번 장에서는, 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는데 도움이 되는 설계 원칙과 기법을 익힌다. 01 협력과 메세지클라이언트-서버 모델 클라이언트 : 메세지를 전송하는 객체 서버 : 수신하는 객체 객체는 자신의 희망을 메세지 형태로 전송하고 메세지를 수신한 객체는 요청을 처리하고 응답한다.객체는 독립적으로 수행할 수 있는 더 큰 책임을 수행하기 위해, 다른 객체와 협력해야 한다. 메세지와 메세지 전송메세지는 객체들이 협력하기 위해 사용하는 유일한 의사소통 수단이다. 한 객체가 다른 객체에게 도움을 요청하는 것을 메세지 전송이라고 한다. 메세지와 메서드메세지를 수신했을 때 실제로 수행되는 함수 또는 프로시저를 메서드라고 한다.메세지 전송자와 메세지 수신자는 서로에 대한 상세한 정보를 알지 못하고 메세지라는 얅고 가는 끈을 통해 연결된다. 퍼블릭 인터페이스와 오퍼레이션 객체가 의사소통을 위해 외부에 공개하는 메세지의 집합을 퍼블릭 인터페이스라고 한다.오퍼레이션은 내부의 구현 코드는 제외하고 단순히 메세지와 관련된 시그니처이다.메세지를 수신했을 때 실제로 실행되는 코드는 메서드이다.객체가 다른 객체에게 메세지를 전송하면 런타임 시스템은 메세지 전송을 오퍼레이션 호출로 해석하고 메세지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다. 시그니처오퍼레이션 관점에서 다형성이란, 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이다. 02 인터페이스와 설계 품질퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법들 디미터 법칙 묻지 말고 시켜라 의도를 드러내는 인터페이스 명령-쿼리 분리 디미터 법칙디미터 법칙은 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다. dot 를 이용해 메세지 전송을 표현하는 언어에서는 “오직 하나의 도트만 사용하라” 라는 말로 요약된다.디미터 법칙을 따르면 shy code 를 작성할 수 있다. shy code 란 불필요한 다른 객체에게 어떤 것도 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다. 12// 디미터 법칙 위반screening.getMovie().getDiscountCondition(); 위 코드는, 메세지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메세지를 전송한다. “기차 충돌” 이라고 한다. 12// 디미터 법칙 준수screening.calculateFee(audienceCount); 위 코드는, 객체의 내부 구조에 대해 묻지 않고 수신자에게 무언가를 시키는 메세지를 전송한다. 묻지 말고 시켜라이 원칙을 지키다보면, 자연스럽게 정보 전문가에게 책임을 할당하고 높은 응집도를 가진 클래스를 얻게된다.호출하는 객체는 이웃 객체가 수행하는 역할을 사용해 무언을 원하는지 서술하고 호출되는 객체가 어떻게 해야하는지를 스스로 결정하게 해야한다. 일반적으로 Tell, Don’t Ask 라고 한다. 공싱적으로는 디미터 법칙이라고 한다. 의도를 드러내는 인터페이스메서드 명명 방법 두가지 메서드가 작업을 어떻게 수행하는지 나타낸다.Bad. 메서드의 내부 구현을 설명하게 된다. 1234567public class PeriodCondition{ public boolean isSatisfedByPeriod(Screening screening) {...}}public class SequenceCondition{ public boolean isSatisfedBySequence(Screening screening) {...}} 클라이언트는 메서드의 이름이 다르기 때문에, 내구 구현일 정확히 이해하지 못하면 두 메서드가 동일한 작업을 한다는 것을 모른다. 무엇을 하는지 드러낸다. 1234567public class PeriodCondition{ public boolean isSatisfied(Screening screening) {...}}public class SequenceCondition{ public boolean isSatisfied(Screening screening) {...}} 두 메서드가 동일한 목적을 가진다는 것을 메서드 이름 통해서 명확하게 표현된다. 클라이언트가 두 메서드를 가진 객체를 동일한 타입드로 간주할 수 있도록 타입 계층으로 묶어야한다. 123public interface DiscountCondition{ public boolean isSatisfied(Screening screening);} 이처럼 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드 이름 짓는 패턴을 “의도를 드러내는 선택자” 라고 한다. 에릭 에반스는 도메인 주도 설계에서 “의도를 드러내는 선택자” 를 인터페이스 레벨로 확장한 “의도를 드러내는 인터페이스” 를 제시했다. 함께 모으기 디미터 법칙을 위반하는 티켓 판매 도메인 1audience.getBag().minusAmount(ticket.getFee()); Audience 의 퍼블릭 인터페이스 뿐만 아니라, 내부 구조에 대해서도 결합된다. 묻지 말고 시켜라 인터페이스에 의도를 드러내자TicketSeller 의 setTicket(), Audience 의 setTicekt(), Bag 의 setTicket() 명확하게 클라이언트의 의도를 드러내는 메서드 명인가 ?Theater 가 TicketSeller 에게 setTicket 메서드를 전송해서 얻고 싶었던 결과는 ? Audience 에게 티켓을 판매하는 것이다. 따라서 setTicket 보다 sellTo 가 의도를 명확하게 드러내는 메세지이다.TicketSeller 가 Audience 에게 setTicekt 메세지를 전송하는 이유는 ? Audience 가 티켓을 사도록 만드는 것이 목적이다. 따라서 클라이언트가 원하는 것은 buy 라는 메세지이다.Audience 가 Bag 에게 setTicekt 메세지를 전송하는 이유는 ? 티켓을 보관하도록 하기 위함이다. 따라서, hold 메세지가 명확하다. 03 원칙의 함정디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다1IntStream.of(1,15,20,3,9).filter(x-&gt; x&gt;10).distinct().count(); 위 코드는, 디미터 법칙을 위반하지 않는다.of, filter, distinct 메서드는 모두 IntStream 이라는 동일한 클래스 인스턴스를 반환한다. 즉, 이들은 IntStream 인스턴스를 또 다른 IntStream 의 인스턴스로 변환한다.단지 IntStream 을 다른 IntStream 변환할 뿐, 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대해 어떤 정보도 외부로 노출하고 있지 않으면 그것은 디미터 법칙을 준수한 것이다.객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따라야하고, 자료 구조라면 내부를 노출해야하므로 적용할 필요가 없다. 결합도와 응집도의 충돌123456public class PeriodCondition implements DiscountConditiono { public boolean isSatisfied(Screening screening) { return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &amp;&amp; .... ; }} 이 코드는 얼핏 보기에, Screening 의 내부 상태를 가져와 사용하기 때문에 캡슐화를 위반한 것 처럼 보인다.그래서, 할인 여부 판단 로직을 Screening 의 isDiscountable 메서드로 옮기고 PeriodCondition 이 이 메서드를 호출하도록 변경하면 묻지 말고 시켜라 스타일을 준수하는 인터페이스를 얻는다고 생각할 것이다.하지만, 이렇게 하면 Screening 이 기간에 따른 할인 조건을 판단하는 책임을 떠안게 된다. Screening 의 본직적인 책임은 영화를 예매하는 것이다. 반면, PeriodCondition 은 할인 조건을 판단하는 것이 본질적인 책임이다.따라서, Screening 의 캡슐화를 향상시키는 것보다, Screening 의 응집도를 높이고 Screening 과 PeriodCondition 사이의 결합도를 낮추는 것이 전체적인 관점에 더 좋은 방법이다. 04 명령-쿼리 분리 원칙 명령 : 객체의 상태를 수정하는 오퍼레이션 == 프로시저 쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션 == 함수 반복 일정의 명령과 쿼리 분리하기명령과 쿼리를 섞으면 실행 결과를 예측하기 힘들다. 명령과 쿼리를 명확하게 분리해야한다. 명령-쿼리 분리와 참조 투명성참조 투명성이란, 표현식 e를 e 의 값으로 e 의 위치 모두에 교체하더라도 결과가 달라지지 않는 특성이다. f(1) = 3 이라고 하면, 123f(1) + f(1) = 6f(1) * 2 = 6f(1) - 1 = 2 1233 + 3 = 63 * 2 = 63 - 1 = 2 f(1) 이 항상 3인 이유는, f(1) 의 값이 변하지 않기 때문이다. 어떤 값이 변하지 않는 성질을 “불변성” 이라고 한다. 어떤 값이 불변하다는 것은 부수효과가 발생하지 않는 다는 것이다.객체지향 패러다임이 객체의 상태 변경이라는 부수 효과를 기반으로 하기 때문에, 참조 투명성은 예외이다.하지만, 명령 쿼리 분리 원칙을 사용하면 균열을 줄일 수 있다. 즉, 부수 효과를 가지는 “명령” 으로부터 부수효과를 가지지 않는 “쿼리” 를 명백하게 분리함으로써 제한적으로 참조 투명성의 혜택을 얻을 수 있다. 책임에 초점을 맞춰라 디미터 법칙을을 준수하고, 묻지 말고 시켜라 스타일을 따르며, 의도를 드러내는 인터페이스를 설계하는 방법은메세지를 선택하고 그 후에 메세지를 처리할 객체를 선택하는 것이다. 명령과 쿼리를 분리하고, 계약에 의한 설계 개념을 통해 객체의 협력 방식을 명시적으로 드러내는 방법은객체 구현 이전에 객체 사이의 협력에 초점을 맞추는 것이다. 이 모든 방식의 중심에는 객체가 수행할 책임이 있다. 오브젝트 &lt;조영호&gt;","link":"/2019/11/24/object-chapter6/"},{"title":"[오브젝트] 7장_객체 분해","text":"하향식 기능 분해 -&gt; 모듈 -&gt; 추상 데이터 타입 -&gt; 클래스 01 프로시저 추상화와 데이터 추상화 데이터 추상화 추상 데이터 타입 : 데이터 중심으로 타입을 추상화 객체지향 : 데이터 중심으로 프로시저를 추상화 02 프로시저 추상화와 기능 분해메인 함수로서의 시스템전통적인 기능 분해방법은 하향식 접근법이다. 즉, 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법이다. 급여 관리 시스템모든 문장이 정제 과정을 거치면서 하나 이상의 좀 더 단순하고 구체적인 문장들의 조합으로 분해된다. 직원의 급여를 계산한다 사용자에게 소득세율을 입력 받는다 “세율을 입력하세요 : “ 라는 문장을 화면에 출력한다 … 직원의 급여를 계산한다 전역 변수에 저장된 직원의 기본접 정보를 얻는다 … 양식에 맞게 출력한다 … 급여 관리 시스템 구현하향식 기능 분해로, 시스템을 최상위의 가장 추상적인 메인함수로 정의하고 메인함수를 구현 가능한 수준까지 세부적인 단계로 분해한다. 메인함수를 루트로 하는 ‘트리’ 로 표현할 수 있다. 하향식 기능 분해의 문제점 하나의 메인 함수라는 비현실적 아이디어 새로운 요구사항이 나오면 지속적으로 새로운 기능을 추가한다. 이것은 시스템이 오직 하나의 메인 함수로 구현된다는 개념과 모순된다. 메인 함수의 빈번한 재설계 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야한다. 비즈니스 로직과 사용자 인터페이스 결합 사용자 인터페이스는 시스템에서 자주 변경되는 부분이다. 비즈니스 로직은 변경이 적게 발생한다. 하향식 접근 방법은 인터페이스와 비즈니스 로직을 섞기 때문에 사용자 인터페이스를 변경하는 경우 비즈니스 로직까지 변경에 영향을 받는다. 성급하게 결정된 실행 순서 함수들의 실행순서를 정의하는 시간 제약을 강조한다. 메인 함수가 작은 함수들로 분해되기 위해서는 우선 함수들의 순서를 결정해야한다. 문제는, 함수의 제어 구조가 빈번한 변경의 대상이라는 점이다. 분해된 함수들은 재사용이 어렵다 모든 함수는 상위 함수를 분해하는 과정에서 필요에 따라 식별되며, 그에 따라 상위 함수가 강요하는 문맥 안에서만 의미를 가지기 때문이다 데이터 변경으로 인한 파급 효과 어떤 데이터를 어떤 함수가 사용하고 있는지 추적이 어렵다. 그래서, 데이터 변경으로 인해 어떤 함수가 영향 받을지 예상이 어렵다 언제 하향식 분해가 유용한가 ?이미 해결된 알고리즘을 문서화하고 서술하는데 훌륭한 기법이다. 03 모듈정보 은닉과 모듈변경을 관리하는 기본 적략은, 함꼐 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것이다.정보 은닉은, 시스템에서 자주 변경되는 부분을 덜 변경되는 안정적인 인터페이스 뒤로 감춰야한다는 것이 핵심이다.모듈은 다음 두가지를 감춰야한다. 복잡성외부에 모듈을 추상화 할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다. 변경 가능성변경 발생히, 하나의 모듈만 수정하면 되도록 변경 가능한 설계 과정을 모듈 내부로 감추고 외부에는 쉽게 견경되지 않을 인터페이스를 제공한다. 모듈의 장점과 한계모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이다. 따라서, 모듈 내부는 높은 응집도를 유지한다.모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신한다. 따라서, 낮은 결합도를 유지한다.모듈의 장점은, 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 받는다 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다 전역변수와 전역 함수를 제거해서, 네임스페이스 오염을 방지하고 이름 충돌의 위험을 완화한다. 모듈의 단점은, 인스턴스 개념을 제공하지 않는다. 높은 수준의 추상화를 위해서는 직원 전체가 아니라 개별 직원을 독립적인 단위로 다룰 수 있어야 한다. 이것이 추상 데이터 타입이다. 04 데이터 추상화와 추상 데이터 타입추상 데이터 타입개별 직원의 인스턴스를 생성할 수 있는 Employee 추상 데이터 타입은, 전체 직원을 캡슐화하는 Employees 모듈 보다 더 개념적으로 사람들의 사고방식의 가깝다.추상 데이터 타입을 구현하기 위해, 프로그래밍 언어는 다음 지원이 필요하다. 타입 정의 선언 가능해야함 타입의 인스턴스를 다루기 위해, 오퍼레이션의 집합을 정의할 수 있어야함 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호 할 수 있어야함 타입에 대해 여러개의 인스턴스를 생성할 수 있어야함 05 클래스클래스는 추상 데이터 타입인가 ?동일하지 않다. 클래스는 상속과 다형성을 지원하는데, 추상데이터타입은 그렇지 않다.추상 데이터 타입으로 구현된 Employee 타입을 보면, 하나의 타입처럼 보이는 Employee 내부에는 정규 직원과 아르바이트 직원이라는 두개의 타입이 공존한다. 하나의 대표적인 타입이 다수의 세부적인 타입을 감추기 때문에 이를, 타입 추상화 라고한다.추상 데이터타입이 오퍼레이션을 기준으로 타입을 묶는 방법이라면, 객체지향은 타입을 기준으로 오퍼레이션을 묶는다. 객체지향은 정규 직원과 아르바이트 직원 각각에 대한 클래스를 정의하고 각 클래스들이 calculatePay 와 monthlyBasePay 오퍼레이션을 적절하게 구현한다.정규 직원과 아르바이트 직원 두 가지 클래스로 분리하면, 공통 로직은 어디에 둘것인가 ? 공통 로직을 포함할 부모 클래스를 정의하고 두 직원 유형의 클래스가 부모 클래스를 상속 받으면 된다 추상 데이터 타입에서 클래스로 변경하기객체지향에서는, 각 직원의 타입을 독립적인 클래스로 구현한다. 변경을 기준으로 선택하라인스턴스 변수에 저장된 값을 기준으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반한 것이다. 클래스가 추상 데이터 타입의 개념을 따른 것이다.언제 추상 데이터 타입이, 객체 지향이 낫나 ? 타입 추가라는 변경의 압력이 강하면, 객체 지향이 낫다.추상 데이터 타입의 경우, 새로운 타입을 추가하면 타입 체크하는 클라이언트 코드를 모두 찾아 수정해야한다. 오퍼레이션 추가라는 변경의 압력이 강하면, 추상 데이터 타입이 낫다.추상 데이터 타입은 전체 타입에 대한 구현 코드가 하나의 구현체 내에 포함돼서 새로운 오퍼레이션 추가가 간단한다. 협력이 중요하다객체지향의 핵심 : 역함, 책임, 협력“객체가 참여할 협력을 결정하고, 협력에 필요한 책임을 수행하기 위해, 어떤 객체가 필요한지 고민하라” 오브젝트 &lt;조영호&gt;","link":"/2019/12/02/object-chapter7/"},{"title":"[오브젝트] 8장_의존성 관리하기","text":"이번장에서는 충분히 협력적이고 유연한 객체를 만들기 위해, 의존성을 관리하는 방법을 정리한다. 01 의존성 이해하기변경과 의존성어떤 객체가 협력을 위해 다른 객체가 필요할 때, 두 객체 사이의 의존성이 존재한다.아래 코드에서, 어떤 형태로든 DayOfWeek, LocalTime, Screening, DiscountCondition 이 변경되면 PeriodCondition 도 함께 변경될 수 있다. 12345678910public class PeriodCondition implements DiscountCondition { private DayOfWeek dayOfWeek; private LocalTime startTime; private LocalTime endTime; ... public boolean isSatisfiedBy(Screening screening){ ... }} 의존성 전이 PeriodCondition 이 Screening 에 의존하면, PeriodCondition 은 Screening 이 의존하는 대상에 대해서도 의존하게 된다는 것이다.의존성이 실제로 전이 될지 여부는 변경의 방향과 캡슐화의 정도에 따라 다르다. Screening 이 내부 구현을 효과적으로 캡슐화하면 Screening 에 의존하고 있는 PeriodCondition 까지는 변경이 전파되지 않는다.의존성의 종류는, 직접 의존성한 요소가 다른 요소에 직접 의존하는 경우. PeriodCondition 이 Screening 에 의존 간접 의존성의존성 전이에 의해 영향이 전파되는 경우 런타임 의존성과 컴파일타임 의존성 런타임애플리케이션이 실행되는 시점 컴파일 타임작성된 코드를 컴파일 하는 시점. 문맥에 따라서는, 코드 그 자체 12345678910111213public class Movie { ... private DiscountPolicy discountPolicy; public Movie(String title, ... , DiscountPolicy discountPolicy){ ... this.discountPolicy = discountPolicy; } public Money calcuateMovieFee(Screening screening){ return fee.minus(discountPolicy.caculateDiscountAmount(screening)); }} 코드를 작성하는 시점에서 Movie 클래스는 AmountDiscountPolicy 클래스와 PercentDiscountPolicy 의 존재를 모르지만, 실행 시점의 Movie 인스턴스는 AmountDiscountPolicy 인스턴스와 PercentDiscountPolicy 인스턴스와 협력할 수 있어야한다.협력할 인스턴스의 구체적인 클래스를 알면 안된다. 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야한다.핵심 : 유연하고 재사용 가능한 설계를 만들기 위해서는 동일한 소스 코드 구조로 다양한 실행 구조를 만들 수 있어야한다. 컨텍스트 독립성클래스가 특정 문맥에 강하게 결합되면 다른 문맥에서 사용하기 어렵다. 클래스가 사용될 특정 문맥에 대해 최소한의 가정으로만 이뤄져 있다면 다른 문맥에서 사용하기 쉽다. 이것이 컨텍스트 독립성이다. 의존성 해결하기의존성 해결이란, 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것이다. 해결 방법으로, 객체 생성 시점에, 생성자로 의존성 해결 1Movie avater = new Movie(&quot;아바타&quot;, new AmountDiscountPolicy(...), ....); 객체 생성 후, setter 메서드를 통해 의존성 해결 12Movie avater = new Movie(...);avater.setDiscountPolicy(new AmountDiscountPolicy(...)); 장점은, 실행 시점에 대상을 변경할수 있어서 설계가 유연하다.단점은, 객체를 생성하고 의존 대상 설정 전까지는 객체의 상태가 불완전할 수 있다. 123Movie avater = new Movie(...);avatar.calculatFee(...); //NPE 예외 발생avater.setDiscountPolicy(new AmountDiscountPolicy(...)); 생성자 방식과 setter 방식 혼합 12Movie avater = new Movie(&quot;아바타&quot;, new AmountDiscountPolicy(...), ....);avater.setDiscountPolicy(new PercentDiscountPolicy(...)); 메서드 실행 시 인자를 이용해 의존성 해결 12345public class Movie{ public Money calulateMovieFee(Screening screening, DiscountPolicy discoutPolicy){ ... }} 협력 대상에 지속적으로 의존 관계 맺을 필요 없이, 메서드가 실행되는 동안 일시적으로 의존관계가 존재해도 되거나, 메서드 실행 시점에 매번 의존 대상이 변경되는 경우 유용하다. 02 유연한 설계의존성과 결합도바람직한 의존성이란, 컨텍스트에 독립적이고 다양한 환경에서 재사용될 수 있는 가능성을 열어놓은 것이다. loose coupling, weak coupling 지식이 결합을 낳는다.한 요소가 다른 요소에 대해 많은 정보를 알면 알수록, 두 요소는 강하게 결합된다. Movie 클래스가 PercentDiscountPolicy 에 직접 의존하면, Movie 는 협력할 객체가 비율 할인 정책에 따라 할인 요금을 계산할 것이라는 걸 알아야 한다. Movie 클래스가 추상 클래스인 DiscoutPolicy 에 의존하면, 구체적인 계산 방법은 알 필요 없이 할잉ㄴ 요금을 계산한다는 사실만 알면 된다. 결합도를 느슨하게 만들기 위해선, 협력 대상에 대해 필요한 정보 외에는 최대한 감추어야한다. 방법은 추상화이다. 추상화에 의존하라의존하는 대상이 추상적일 수록, 결합도는더 낮아진다.아래로 갈수록, 클라이언트가 알아야하는 지식의 양이 적어져 결합도가 느슨해진다. 구체 클래스 의존성 추상 클래스 의존성 인터페이스 의존성 구체 클래스에 비해, 추상 클래스는 메서드의 내부 구현과 자식 클래스의 종류에 대한 지식을 클라이언트에게 숨길 수 있다.추상 클래스에 비해, 인터페이스는 상속 계층을 모르더라도 협력이 가능하다. 명시적인 의존성“숨겨진 의존성을 밝은 곳으로 드러내서 널리 알리자” 숨겨진 의존성 123456789public class Movie { ... private DiscountPolicy discountPolicy; public Movie(String title, ...){ ... this.discountPolicy = new AmountDiscountPolicy(...); }} 위 코드는, 생성자에서 구체 클래스인 AmountDiscountPolicy 의 인스턴스를 직접 생성해서 대입하고 있다. Movie 는 추상 클래스인 DiscountPolicy 뿐만 아니라, AmountDiscountPolicy 에도 의존하고 있다.Movie 가 DiscountPolicy 에 의존하고 있다는 것을 감춘다. 이것이 숨겨진 의존성이다.의존성 파악을 위해 내부 구현을 직접 살펴봐야한다. 그리고, 의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야한다. 명시적인 의존성 123456789public class Movie { ... private DiscountPolicy discountPolicy; public Movie(String title, ... , DiscountPolicy discountPolicy){ ... this.discountPolicy = discountPolicy; }} 위 코드는, 생성자 안에서 직접 인스턴스를 생성하지 않고 생성자의 인자로 선언한다.Movie 가 DiscountPolicy에 의존하고 있다는 것을 Movie 의 퍼블릭 인터페이스로 드러내고 있다. 이것이 명시적인 의존성이다. new 는 해롭다결합도 측면헤서 해로운 이유는, new 연산자 사용 위해 구체 클래스의 이름을 직접 기술해야한다. 그래서, new 를 사용하는 클라이언트는 구체 클래스에 의존을 해서 결합도가 높아진다. 구체 클래스의 어떤 인자를 사용해서 클래스의 생성자를 호출해야하는지도 알아야한다. 그래서, 클라이언트가 알아야하는 지식의 양이 늘어나 결합도가 높아진다. 123456789public class Movie { ... private DiscountPolicy discountPolicy; public Movie(String title, ... ){ ... this.discountPolicy = new AmountDiscountPolicy(....) }} AmountDiscountPolicy 인스턴스 생성을 위해, 생성자에 전달해야하는 인자를 알아야한다.해결방법은, 인스턴스 생성 로직과 사용 로직을 분리한다. 즉, Movie 는 외부로부터 이미 생성된 AmountDiscountPolicy 의 인스턴스를 전달받아야한다.외부에서 인스턴스를 전달받는 방법은, 생성자의 인자 setter 메서드 메서드의 인자 123456789public class Movie { ... private DiscountPolicy discountPolicy; public Movie(String title, ... , DiscountPolicy discountPolicy){ ... this.discountPolicy = discountPolicy; }} AmountDiscountPolicy 생성 책임은 Movie 의 클라이언트로 옮겨지고, Movie 는 AmountDiscountPolicy 인스턴스를 사용하는 책임만 남는다. 가끔은 생성해도 무방하다주로 협력하는 기본 객체를 설정하고 싶으면 가끔은 생성해도 무방하다.설계는 트레이드오프다. 12345678910111213public class Movie { ... private DiscountPolicy discountPolicy; public Movie(String title, ... ){ this(title, ..., new AmountDiscountPlicy(...)); } public Movie(String title, ... , DiscountPolicy discountPolicy){ ... this.discountPolicy = discountPolicy; }} 표준 클래스에 대한 의존은 해롭지 않다변경될 확률이 거의 없으면, 의존성이 문제가 되지 않는다.ex) JDK 에 포함된 표준 클래스 컨텍스트 확장하기 NoneDiscountPolicy할인 정책이 존재 하지 않는다는 사실을 할인 정책의 한 종류로 간주 OverlappedDiscountPolicy중복 할인 정책을 표현하기 위함 설계를 유연하게 할 수 있었던 이유는, DiscountPolicy 라는 추상화에 의존 생성자를 통해 DiscountPolicy 에 대한 의존성을 명시적으로 드러냄 new 와 같이 구체 클래스를 직접 다뤄야하는 책임을 Movie 외부로 옮김 조합 가능한 행동훌륭한 객체 지향 설계는, 어떻게 하는지 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현해서 객체들이 무엇을 하는지 표현하는 설계다. 오브젝트 &lt;조영호&gt;","link":"/2019/12/10/object-chapter8/"},{"title":"[오브젝트] 9장_유연한 설계","text":"이번 장은, 8장에서 설명한 의존성 관리 기법들을 원칙이라는 관점에서 정리한다. 01 개팡-폐쇄 원칙소프트웨어 개체(클래스, 모듈, 함수 …) 는 확장에 열려있고, 수정에 닫혀 있어야한다. 확장에 열려 있다요구사항이 변경될 때, 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있다. 수정에 닫혀 있다기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다. 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라 런타임 의존성실행 시에 협력에 참여하는 객체들 사이의 관계 컴파일 타임 의존성코드에서 드러나는 클래스들 사이의 관계 중복 할인 정책을 추가하기 위해 한 일은, DiscountPolicy 의 자식 클래스로 OverlappedDiscountPolicy 클래스를 추가한 것이다. 단순히 새로운 크래스를 추가하는 것만으로 Movie 를 새로운 컨텍스트에 사용되도록 확장할 수 있었다.이 설계 방식은, 새로운 할인 정책을 추가해서 새로운 기능을 확장할 수 있도록 허용한다. 즉, 확장에 열려 있다. 기존의 코드를 수정할 필요 없이 새로운 클래스 추가만으로 새로운 할인 정책을 확장한다. 즉, 수정에 닫혀 있다. 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란, 컴파일 타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조이다. 추상화가 핵심이다개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.추상화를 통해 생략된 부분은 확장의 여지를 남긴다. 123456789101112131415publc abstract classs DiscoutPolicy{ ... public Money calculateDiscountAmount(Screening screening){ for(DiscountCondition each : conditions){ if(each.isSatisfiedBy(screening)){ // 할인 여부를 판단하는 로직 return getDiscountFee(screenig); } } return screeing.getMovieFee(); } ...} 위 코드에서 변하지않는 부분은, 할인 여부를 판단하는 로직이다.변하는 부분은, 할인 요금을 계산하는 방법이다. 이 부분이 추상화를 통해 생략된 부분이다. 상속을 통해 생략된 부분을 구체화함으로써 할인 정책을 확장할 수 있다.변하는 부분을 고정하고 변하지 않는 부분을 생략하는 추상화 메커니즘이 개방-폐쇄 원칙의 기반이 된다. 02 생성 사용 분리12345678910111213public class Movie { ... private DiscountPolicy discountPolicy; public Movie(String title, ...){ ... this.discountPolicy = new AmountDiscountPolicy(...); // 객체 생성 } public Money cacluateMovieFee(Screening screening){ return fee.minus(discountPolicy.calculateDiscountAmount(screenig)); // 객체 사용 }} 위 코드에서, Movie 의 할인 정책을 비율 할인 정책으로 변경할 수 있는 방법은, 직접 코드를 수정하는 것이다. 이것은 동작을 추가하거나 변경하기 위해 기존 코드를 수정하도록 만들어서, 개방-폐쇄 원칙을 위반한다.문제는, 부적절한 곳에서 객체를 생성한다는 것이다. 동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 다른 목적을 가진 코드가 공존한다는 것이다.객체의 관련된 두 가지 책임을 서로 다른 객체로 분리해야한다. 즉, 객체애 대한 생성과 사용을 분리해야한다. 현재의 컨텍스트에 관한 결정권을 가지고 있는 클라이언트로 컨텍스트에 대한 지식을 옮겨 Movie 는 특적한 클라이언트에 결합되지 않고 독립될 수 있다. FACTORY 추가하기Movie 를 사용하는 Client 역시도, 특정한 컨텍스트에 묶이지 않기를 바란다고 가정하자.객체 생성에 특화된 객체인, FACTORY 를 사용하면 된다. 1234567891011public class Factory { public Movie cacluateAvatarMovie() { return new Movie(&quot;아바타&quot;, ....); }}public class Client { private Factory factory; ...} 순수한 가공물에게 책임 할당하기위의 FACTORY 는 도메인 모델에 속하지 않는다. FACTORY는 순수하게 기술적인 결정이다. 즉, 객체 생성 책임을 할당할 만한 도메인 객체가 존재하지 않을 때 선택한 PURE FABRICATION 이다.시스템을 객체로 분해하는 방법으로 표현적 분해와 행위적 분해가 있다. 표현적 분해도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것이다. 행위적 분해그런데, 실제로 동작하는 애플리케이션은 데이터베이스에 접근 위한 객체와 같이 도메인 개념을 초월하는 기계적인 개념도 필요하다. 이렇게 도메인과 무관한 인공적인 객체를 PURE FABRICATION (순수한 가공물) 이라고 한다. PURE FABRICATION은 특정한 행동을 표현하는 것이 일반적이다. 03 의존성 주입의존성 주입이란, 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결 하는 방법이다.의존성 주입에서 의존성 해결 방법은 , 생성자 주입 : 객체 생성 시점에 생성자 통해 의존성 해결 setter 주입 : 객체 생성 후 세터 메서드로 의존성 해결 메서드 주입 : 메서드 실행 시 인자로 의존성 해결 숨겨진 의존성을 나쁘다의존성 주입 외에, 의존성 해결 방법으로 SERVICE LOCATOR 패턴이 있다.SERVICE LOCATOR 는, 의존성 해결할 객체들을 보관하는 일종의 저장소이다. 외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리, 객체가 직접 SERVICE LOCATOR 에게 의존성을 해결해달라고 요청한다. 123456789101112131415161718192021222324252627282930public class Movie { ... private DiscountPolicy discountPolicy; public Movie(String title, ...){ ... this.discountPolicy = ServiceLocator.discountPolicy(); }}public class ServiceLocator { private static ServiceLocator soleInstance = new ServiceLocator(); private DiscountPolicy discountPolicy; public static DiscountPolicy discountPolicy(){ return soleInstance.discountPolicy; } public static void provide(DiscountPolicy discountPolicy){ soleInstance.discountPolicy = discountPolicy; } private ServiceLocator { }}serviceLocator.provide(new AmountDiscountPolicy(...));Movie avater = new Movie(&quot;아바타&quot;, ... ); Movie 는 DiscountPolicy 에 의존하고 있지만, Movie 의 퍼블릭 인터페이스 어디에도 의존성에 대한 정보가 표시되어 있지 않다. 의존성이 암시적이며 코드 깊숙히 숨겨져 있다.숨겨진 의존성은, 이해하기 어렵고 디버깅이 어렵다. 문제점을 발견할 수 있는 시점이 코드작성 시점이 아니라 실행시점으로 미뤄지기 때문이다. 또한, 클래스 사용법을 익히기 위해서 구현 내부를 샅샅이 뒤져야한다. 핵심은, 의존성 주입이 SERVICE LOCATOR 패턴보다 좋다는 것이 아니다. 명시적인 의존성이 숨겨진 의존성보다 좋다는 것이다. 04 의존성 역전 원칙추상화와 의존성 역전 123public class Movie { private AmountDiscountPolicy discountPolicy; // 구체적인 방법, 하위 수준} 위 설계가 변경에 취약한 이유는, 요금을 계산하는 상위 정책이 요금을 계산하는데 필요한 구체적인 방법에 의존하기 때문이다.객체 사이의 협력이 존재하면, 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다. 상위 수준의 클래스가 하위 수준의 클래스에 의존하면, 하위 수준의 변경에 의해 상위 수준의 클래스가 영향을 받게 된다. 재사용이 어렵다. 상위 수준의 클래스를 재사용할 때 하위 수준의 클래스도 필요하기 때문이다. 가장 중요한 핵심은, 추상화에 의존해야한다는 것이다. 모든 의존성의 방향이 추상클래스나 인터페이스와 같은 추상화를 따라야한다. 즉, 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야한다. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야한다. 의존성 역전 원칙과 패키지 위 그림은, 인터페이스의 소유권을 클아이언트 모듈이 아닌 서버 모듈에 위치시켰다. Movie 를 다양한 컨텍스트에서 재사용하기 위해서는 불필요한 클래스들이 Movie 와 함께 배포되어야한다. 즉, DiscountPolicy 클래스에 의존하기 위해서는, 같은 패키지안에 있는 AmountDiscountPolicy 와 PercentDiscountPolicy 클래스도 함께 존재해야한다. 위 그림은 인터페이스 소유권을 클라이언트에 위치시켰다. Movie 를 다른 컨텍스트에서 재사용하기 위해서는, 단지 Movie 와 DiscountPolicy 가 포함된 패키지만 재사용하면 된다. 05 유연성에 대한 조언유연한 설계는 유연성이 필요할 때만 옳다유연한 설계는 복잡하다. 유연하지 않은 설계는 단순하다.유연성을 코드를 읽는 사람들이 복잡함을 수용할 때만 가치가 있다. 협력과 책임이 중요하다역할, 책임, 협력에 집중하라.객체를 생성하는 방법은 모든 책임이 자리를 잡은 후 마지막 시점에 내리는 것이 적절하다. 오브젝트 &lt;조영호&gt;","link":"/2019/12/15/object-chapter9/"},{"title":"[오브젝트] 10장_상속과 코드 재사용","text":"이번 장은, 클래스 재사용을 위해 새로운 클래스를 추가하는 가장 대표적 기법인 상속에 대해 정리한다. 01 상속과 중복 코드DRY 원칙 (Don’t Repeat Yourself)“동일한 지식을 중복하지 마라”중복 여부를 판단하는 기준은 변경이다. 중복 코드는 변경을 방해한다. 이것이 중복 코드를 제거해야하는 핵심적 이유이다.중복 코드는 코드를 수정하는데 노력을 몇배로 증가시킨다. 왜냐하면, 어떤 코드가 중복인지 찾아야하고, 찾아낸 모든 코드를 일관되게 수정해야하고, 개별적으로 테스트를 다 해야하기 때문이다. 중복과 변경한 달에 한 번씩 가입자별로 전화 요금 계산하는 간단한 애플리케이션을 개발해보자.개별 통화 기간을 저장하는 클래스가 필요하다. 1234567891011121314151617public class Call { private LocalDateTime from; //통화 시작 시간 private LocalDateTime to; // 통화 종료 시간 public Call(LocalDateTime from, LocalDateTime to) { this.from = from; this.to = to; } public Duration getDuration(){ return Duration.between(from, to); } public LocalDateTime getFrom(){ return from; }} 전체 통화 목록에 대해 알고 있는 정보 전문가에게 요금 계산 책임 을 할당해야한다. 123456789101112131415161718192021222324252627282930313233343536public class Phone { private Money amount; private Duration seconds; private List&lt;Call&gt; calls = new ArrayList&lt;&gt;(); public Phone(Money amount, Duration seconds) { this.amount = amount; this.seconds = seconds; } public void call(Call call){ calls.add(call); } public List&lt;Call&gt; getCalls() { return calls; } public Money getAmount() { return amount; } public Duration getSeconds() { return seconds; } public Money calculateFee(){ Money result = Money.ZERO; for (Call call : calls){ result = result.plus(amount.times(call.getDuration().getSeconds() / seconds.getSeconds())); } return result; }} 그런데, 심야 할인 요금제 라는 새로운 요금 방식을 추가해야하는 요구사항이 접수됐다.Phone 코드를 복사해서 새로운 클래스를 만들어보자. 1234567891011121314151617181920212223242526272829303132public class NightlyDiscountPhone { private static final int LATE_NITGHT_HOUR = 22; private Money nightAmount; private Money regularAmount; private Duration seconds; private List&lt;Call&gt; calls = new ArrayList&lt;&gt;(); public NightlyDiscountPhone(Money nightAmount, Money regularAmount, Duration seconds) { this.nightAmount = nightAmount; this.regularAmount = regularAmount; this.seconds = seconds; } public Money calculateFee(){ Money result = Money.ZERO; for (Call call : calls){ if(call.getFrom().getHour() &gt;= LATE_NITGHT_HOUR){ result = result.plus( nightAmount.times(call.getDuration().getSeconds() / seconds.getSeconds()) ); }else { result = result.plus( regularAmount.times(call.getDuration().getSeconds() / seconds.getSeconds()) ); } } return result; }} 통화 요금에 부과할 세금을 계산하는 요구사항을 추가해보자. 12345678910111213141516public class Phone { ... private double taxRate; ... public Money calculateFee(){ Money result = Money.ZERO; for (Call call : calls){ result = result.plus(amount.times(call.getDuration().getSeconds() / seconds.getSeconds())); } return result.plus(result.times(taxRate); }} 1234567891011121314151617181920212223public class NightlyDiscountPhone { ... private double taxRate; ... public Money calculateFee(){ Money result = Money.ZERO; for (Call call : calls){ if(call.getFrom().getHour() &gt;= LATE_NITGHT_HOUR){ result = result.plus( nightAmount.times(call.getDuration().getSeconds() / seconds.getSeconds()) ); }else { result = result.plus( regularAmount.times(call.getDuration().getSeconds() / seconds.getSeconds()) ); } } return result.minus(result.times(taxRate)); }} 이처럼, 많은 코드 속에서 어떤 코드가 중복인지리 파악하는 것은 쉬운 일이 아니다.두 클래스 사이의 중복 제거 방법으로, 클래스를 하나로 합치고 요금제를 구분하는 타입 코드를 추가하는 방법이 있다. 타입 코드 값에 따라 로직을 분기시키는 것이다. 하지만 이 방법은 낮은 응집도와 높은 결합도의 문제가 있다. 상속을 이용해 중복 코드 제거하기123456public class NightlyDiscountPhone extends Phone{ @Override public Money calculateFee(){ ... } 10시 이전의 통화요금 계산하는 경우는 Phone 에 구현된 로직을 재사용하고 10시 이후의 통화 요금 계산은 NightlyDiscountPhone 에서 구현하기로 결정한다.이 예제처럼, 상속을 이용해 코드 재사용 하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 가정을 정확하게 이해해야한다. 이것은 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야한다는 것을 의미한다.따라서 상속은 결합도를 높인다. 강하게 결합된 Phone 과 NightlyDiscountPhone자식 클래스가 부모 클래스의 구현에 강하게 결합되면 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는다. 02 취약한 기반 클래스 문제부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 취약한 기반 클래스 문제라고 한다.취약한 기반 클래스 문제는, 자식 클래스가 부모 클래스의 구현 세부 사항에 의존하도록 만들기 때문에 결합도를 높인다. 캡슐화를 약화 시킨다. 불필요한 인터페이스 상속 문제 다음 코드를 보자. 123456789Stack&lt;String&gt; stack = new Stack&lt;&gt;();stack.push(&quot;1st&quot;);stack.push(&quot;2nd&quot;);stack.push(&quot;3rd&quot;);stack.add(0, &quot;4th&quot;);assertEquals(&quot;4th&quot;, stack.pop()); // 에러 반환값은 3rd 이다. 왜냐하면, Vector 의 add 메서드를 이용해서 스택의 맨 앞에 “4th” 를 추가했기 때문이다.문제 원인은, Stack 이 규칙을 무너뜨릴 여지가 있는 위험한 Vector 의 퍼블릭 인터페이스까지도 함께 상속 받았기 때문이다. 다음 코드를 보자. 1234567Properties properties = new Properties();properties.setProperty(&quot;aaa&quot;, &quot;C++&quot;);properties.setProperty(&quot;bbb&quot;, &quot;Java&quot;);properties.put(&quot;ccc&quot;, 67);assertEquals(&quot;C&quot;, properties.getProperty(&quot;ccc&quot;)); // 에러 “ccc” 를 키로 검색하면 null 이 반환된다. Properties 의 getProperty 메서드가 반환할 값이 String 이 아니면 null 을 반환하도록 구현되어 있기 때문이다.Hashtable 의 인터페이스에 포함되어 있는 put 메서드를 이용해서 String 타입 이외의 키 값이라도 Properties 에 저장을 한 것이다. 메서드 오버라이딩의 오작용 문제상속은 코드 재사용을 위해 캡슐화를 희생한다. 부모 클래스와 자식 클래스의 동시 수정 문제03 Phone 다시 살펴보기추상화에 의존하자부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정하자 차이를 메서드로 추출하자변하는 것으로부터 변하지 않는 걸을 분리하자. 변하는 부분을 찾고 이를 캡슐화하자. 중복 코드를 부모 클래스로 올려라123456789101112131415public abstract class AbstractPhone { private List&lt;Call&gt; calls = new ArrayList&lt;&gt;(); public Money calculateFee(){ Money result = Money.ZERO; for(Call calls : calls){ result = result.plus(calculateCallFee(call)); } return result; } abstract protected Money calculateCallFee(Call call);} 1234567891011121314public class Phone extends AbstractPhone { private Money amount; private Duration seconds; public Phone(Money amount, Duration seconds) { this.amount = amount; this.seconds = seconds; } @Override protected Money calculateCallFee(Call call) { return amount.times(call.getDuration().getSeconds() / seconds.getSeconds()); }} 1234567891011121314151617181920212223public class NightlyDiscountPhone extends AbstractPhone{ private static final int LATE_NITGHT_HOUR = 22; private Money nightlyAmount; private Money regularAmount; private Duration seconds; public NightlyDiscountPhone(Money nightlyAmount, Money regularAmount, Duration seconds) { this.nightlyAmount = nightlyAmount; this.regularAmount = regularAmount; this.seconds = seconds; } @Override public Money calculateCallFee(Call call) { if(call.getFrom().getHour() &gt;= LATE_NITGHT_HOUR){ return nightlyAmount.times(call.getDuration().getSeconds() / seconds.getSeconds()); } return regularAmount.times(call.getDuration().getSeconds() / seconds.getSeconds()); }} 추상화가 핵심이다공통 코드를 이동시킨 후에, 각 클래스는 서로 다른 변경 이유를 가진다. AbstractPhone전체 통화 목록을 계산하는 방법이 바뀔 경우에만 변경 Phone일반 요금제의 통화 한건을 계산하는 방법이 바뀔 경우에만 변경 NightlyDisoucoutPhone심야 할인 요금제의 통화 한건을 계산하는 방법이 바뀔 경우에만 변경 그리고, 추상화에 의존함으로써 부모 클래스는 자신의 내부에 구현된 추상 메서드를 호출함으로써 추상화에 의존하고, 요금 계산과 상위 수준의 정책을 구현하는 AbstractPhone 이 세부적인 요금 계산 로직을 구현하는 Phone 과 NightlyDisoucoutPhone 에 의존하지 않고 그 반대로 의존하기 때문에 의존성 역전 원칙을 지키고, 새로운 요금제룰 추가하기도 쉽다. AbstractPhone 을 상속받는 클래스를 추가하고 calculateCallFee 메서드만 오버라이딩 하면 된다. 개방 폐쇄 원칙을 준수한다. 확장에 열려있고 수정에 닫혀 있기 때문이다. 의도를 드러내는 이름 선택하기123public abstract class Phone { ... }public class RegularPhone extends Phone { ... }public class NightlyDiscountPhone extends Phone { ... } 세금 추가하기통화 요금에 세금 부과하는 요구사항 추가해보자. 1234567891011121314151617public abstract class Phone { private double taxRate; private List&lt;Call&gt; calls = new ArrayList&lt;&gt;(); public Money calculateFee(){ Money result = Money.ZERO; for(Call calls : calls){ result = result.plus(calculateCallFee(call)); } return result.plus(result.times(taxRate)); } abstract protected Money calculateCallFee(Call call);} 04 차이에 의한 프로그래밍기존 코드와 다른부분을 추가해서 애플리케이션의 기능을 확장하는 방법을 차이에 의한 프로그래밍이라고 한다.차이에 의한 프로그래밍의 목표는 중복 코드를 제거하고 코드를 재사용 하는 것이다.객체지향 세계에서 중복 코드 제거하고 코드 재사용하는 가장 유명한 방법은 상속이다. 상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만든다.“정말로 필요한 경우에만 상속을 사용해라” 오브젝트 &lt;조영호&gt;","link":"/2019/12/22/object-chapter10/"},{"title":"[카프카] 1장_카프카란 무엇인가","text":"카프카 : 대용량, 대규모 메세지 데이터를 빠르게 처리하도록 개발된 메시징 플랫폼 탄생 배경end-to-end 아키텍쳐의 문제점은, 통합된 전송 영역이 없어서 복잡도 증가하고 데이터 파이프라인의 관리가 어렵다. 하지만 카프카는 아래 그림 처럼, 모든 시스템으로 데이터 전송이 가능하고 실시간 처리 가능하고 확장이 용이하다. 동작 방식과 원리메시징 시스템을 먼저 살펴보자.중앙에 메시징 시스템 서버를 두고 메시지를 Publish 하고 Subscribe 하는 형태의 통신을 Pub/Sub 모델이라고 한다. 프로듀서가 메시지를 컨슈머에게 직접 전달하는 것이 아니라, 중간의 메시징 시스템으로 전달한다. 그래서, 개체가 하나 빠지거나 수신 불능 상태가 되어도, 메세징 시스템이 살아있으면 프로듀서에서 전달된 메세지가 유실이 되지 않는다. 메세징 시스템을 중심으로 연결되기 때문에, 확장성이 용이하다. 카프카의 메세지 전달 순서는, 프로듀서가 메세지를 카프카에게 보낸다. 메세지가 Topic 에 도착해 저장된다. 컨슈머는 카프카 서버에 접속해 메세지를 가져간다. 특징 프로듀서와 컨슈머의 분리어느 한쪽 시스템에서 문제가 발생해도 연쇄 작용이 발생할 확률이 낮다.서버 추가에 대한 부담이 준다. 멀티 프로듀서, 멀티 컨슈머데이터 분석 및 처리 프로세스에서 하나의 데이터를 다양한 용도로 사용하는 요구 사항을 충족할 수 있다. 디스크에 메세지 저장컨슈머가 메세지를 읽어가도 보관 주기 동안 디스크에 메세지를 저장한다.( 일반적인 메세지 시스템은 컨슈머가 메세지를 읽어가면 큐에서 바로 메세지 삭제 ) 확장성온라인 상태에서 확장 작업 가능 높은 성능 카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;","link":"/2019/12/26/kafka-chapter1/"},{"title":"[카프카] 3장_카프카 디자인","text":"카프카 디자인의 특징분산 시스템분산 시스템이란, 같은 역할을 하는 여러 대의 서버로 이뤄진 서버 그룹이다.장점은, 단일 시스템 보다 높은 성능 하나의 서버가 장애가 발생해도 다른 서버가 대신 처리 시스템 확장 용이 페이지 캐시OS 는 물리적 메모리에 애플리케이션이 사용하는 부분을 할당하고, 남은 잔여 메모리 일부를 페이지 케시로 이용한다.즉, 디스크에 읽고 쓰기를 하지 않고 페이지 케시를 읽고 쓰는 방식으로 처리 속도가 빠르고 전체적인 성능을 향상 시킨다. 배치 전송 처리서버와 클라이언트 사이, 또는 서버 내부적으로 데이터를 주고 받는 과정에서 I/O 가 발생한다.작은 I/O 가 빈번하게 발생하는 것을 막기 위해, 작은 I/O 들을 묶어러 처리할 수 있도록 배치 작업으로 처리한다. 카프카 데이터 모델토픽메세지를 받을 수 있도록 논리적으로 묶은 개념이다. 메일 주소라고 생각하면 쉽다. 파티션토픽을 분할한 것이다.아래 그림에서, ‘뉴스 토픽’ 으로 4 개의 메세지를 보내는데 4 초가 걸린다. 아래 그림에서, ‘뉴스 토픽’ 으로 4 개의 메세지를 보내는데 1 초가 걸린다. 이렇게 빠른 전송을 위해서는, 토픽의 파티션 수와 프로듀서 수를 모두 늘려줘야한다. 그러면, 무조건 파티션 수를 늘려야 하나 ? 파티션 수가 늘어나면 카프카에 좋지 않은 영향을 끼칠 수 있다. 파일 핸들러의 낭비각 파티션은 브로커의 디렉토리와 매핑되고, 저장되는 데이터는 2 개의 파일 ( 인덱스, 실제 데이터 ) 이 있다.파티션이 많을 수록, 파일 핸들 수 역시 많아져 리소스가 낭비가 될 수 있다. 장애 복구 시간 증가 그러면, 토픽의 적절한 파티션 수는 ? 먼저, 원하는 목표 처리량의 기준을 정해야한다. 프로듀서4 개의 프로듀서가 초당 10 개의 메세지를 토픽으로 보내면, 토픽에서 초당 40 개의 메시지를 받아줘야한다. 토픽해당 토픽에서 파티션을 1로 했을 때 초당 10개의 메세지만 받아준다면, 파티션 수를 4로 조정하면 목표치를 달성한다. 컨슈머8 개의 컨슈머가 각각 초당 5 개의 메세지를 토픽에서 가져올 수 있으면, 토픽의 파티션수는 8개로 맞춰서 각 컨슈머마다 각각의 파티션에 접근하게 해줘야한다.주의할 점은, 파티션 수를 늘리는 것은 가능하지만 파티션 수을 줄이는 것은 불가능하다. 오프셋과 메세지 순서오프셋이란, 각 파티션마다 메세지가 저장되는 위치이다.파티션 내에서 유일한 숫자이고, 순차적으로 증가한다.만약 컨슈머가 파티션 0 에서 데이터를 가져간다고 하면, 오프셋 0 1 2 3 4 5 순서대로 가져갈 수 있다.절대로 오프셋 순서가 바뀐 상태로 가져갈 수 없다. 고가용성과 리플리케이션토픽을 이루는 각각의 파티션을 리플리케이션 하는 것이다. 리플리케이션 팩터와 리더, 팔로워의 역할 위 그림은, 토픽이 replication-factor 2 로 생성된 상황이다.모든 읽기와 쓰기는 리더를 통해서만 일어난다. 팔로워는 리더의 데이터를 그대로 리플리케이션만 한다.리더와 팔로워는 저장된 데이터의 순서도 일치하고 동일한 오프셋과 메시지를 갖는다.리플리케이션된 토픽의 서버가 다운되어도, 리더 변경으로 문제 없이 프로듀서의 요청을 처리할 수 있다. 리플리케이션도 단점은 있다. 디스크 사용량 증가토픽의 사이즈가 100 GB, 리플리케이션 팩터 3 이면, 카프카 클러스터 내 필요 저장소 크기는 300 GB 이다. 브로커 리소스 사용량 증가브로커는 리플리케이션 보장을 위해, 비활성화된 토픽이 리플리케이션을 잘하고 있는지 비활성화된 토픽을 계속 체크한다. 리더와 팔로워의 관리팔로워에 문제가 있어서, 리더로부터 데이터를 가져오지 못하면 정합성이 맞지 않는다.이를 해결하기 위해, ISR ( In Sync Replica ) 라는 개념이 있다. 현재 리플리케이션 되고 있는 리플리케이션 그룹이다.ISR 에 속한 구성원만이 리더의 자격이 있다.프로듀서 1, 브로커 3, 리플리케이션 팩터 3 일때, ISR 동작 순서는 프로듀서가 메세지를 토픽의 리더에게 보낸다. 리더는 메세지를 저장한다. 팔로워는 매우 짧은 주기로 리더에 새로운 메세지가 저장된 것이 있는지 확인한다. 팔로워 1은 잘 동작하고 2는 잘 동작하지 않는다고 가정하자. 리더는 팔로워가 일정 주기 동안 확인 요청을 하지 않으면 그 팔로워를 ISR 그룹에서 추방한다. 리더는 팔로워 2를 ISR 그룹에서 추방한다. 팔로워 1은 리더에게 새로운 메세지가 있음을 확인하고 메세지를 가져가서 저장한다. 모든 브로커가 다운된다면 마지막 리더가 살아나기를 기다린다.마지막 리더에게 모든 메세지가 저장되어 있을 때, 나중에 다시 살아난다면 메세지 손실이 없다.하지만 마지막 리더가 살아나지 않는 경우가 있을 수 있고, 결국 마지막 리더가 정상화 될때 까지 카프카 클러스터 장애가 길어진다. ISR 에서 추방되었지만 먼저 살아나면 자동으로 리더가 된다.메세지가 일부 손실되지만, 브로커 하나만이라도 정상화되어 서비스가 빠르게 정상화된다. 예시아래 그림은,Broker 3 / Topic “jko01” / Partition 2 / Replication Factor 3 아래 그림은,Broker 3 / Topic “jko02” / Partition 2 / Replication Factor 2 카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;","link":"/2019/12/27/kafka-chapter3/"},{"title":"[카프카] 4장_카프카 프로듀서","text":"프로듀서란, 메세지를 생산해서 카프카의 토픽으로 보내는 역할을 하는 애플리케이션 or 서버이다.주요 기능은, 각각의 메세지를 토픽 파티션에 매핑하고 파티션의 리더에 요청을 보내는 것이다.프로듀서 옵션 중에 acks 옵션 설정에 따라카프카로 메세지를 전송할 때, 메세지 손실 여부와 메세지 전송 속도 및 처리량이 달라진다. 메세지 보내고 확인하지 않기메세지 손실 가능성이 있다. 동기 전송카프카의 응답을 기다린다. 비동기 전송응답을 기다리지 않기 때문에 빠른 전송이 가능하다. 메세지 손실 가능성 높음 &amp;&amp; 빠른 전송 속도acks = 0카프카 서버의 응답을 기다리지 않고 메세지 보낼 준비가 되면 즉시 다음 요청을 보낸다. 메세지 손실 가능성 낮음 &amp;&amp; 적당한 전송 속도 asks = 1프로듀서는 메세지를 보내고 Leader 는 잘 받았으면, 바로 ack 를 한다.팔로워들은 주기적으로 리더를 확인하고 새로운 메세지가 확인되면 팔로워들에도 저장한다.메세지 손실이 발생하는 경우는 리더에 장애가 발생하는 경우이다.즉, 프로듀서가 리더에게 메세지를 보내고 리더는 메시지를 저장한 후에 바로 장애가 발생하는 경우이다. 메세지 손실 없음 &amp;&amp; 느린 전송 속도acks = all메세지를 보내고 잘 받았는지 확인하고 추가적으로 팔로워들까지 메세지를 잘 받았는지 확인한다.이 때, 프로듀서 설정 뿐만 아니라 브로커 설정도 같이 해줘야한다. 프로듀서 acks = all, 브로커 min.insync.replicas = 1 min.insync.replicas 는 최소 리플리케이션 팩터를 지정하는 옵션이다. 프로듀서는 토픽의 리더에게 메세지를 보내고, 리더는 메세지를 저장한다. 최소 하나의 리플리케이션 조건을 갖췄기 때문에 acks 를 보낸다. 프로듀서 acks = all, 브로커 min.insync.replicas = 2 프로듀서는 토픽의 리더에게 메세지를 보내고, 리더는 메세지를 저장한다. 팔로워가 2 개가 있다고 할 때, 첫번째 팔로워는 리더로부터 주기적으로 새로운 메세지를 확인하며 새로운 메세지가 확인되면 자신도 리더의 메세지를 가져와 저장한다. 최소 두 개의 리플리케이션 조건을 갖췄기 때문에 acks 를 보낸다. 손실 없는 메세지 전송을 위해서는,프로듀서 acks = all, 브로커 min.insync.replicas = 2, 리플레케이션 팩터 = 3 프로듀서 acks = all, 브로커 min.insync.replicas = 3 왜 카프카는 손실 없는 메세지 전송을 위해,min.insync.replicas = 3 이 아니라, min.insync.replicas = 2 를 추천할까 ?아래 case 를 보자. 프로듀서는 토픽의 리더에게 메세지를 보낸다. 팔로워가 2 개가 있다고 할 때, 팔로워가 위치한 브로커 하나를 강제 종료한다. 에러가 발생한다. min.insync.replicas = 3 이기 때문에, 리더, 팔로워, 팔로워 이렇게 3 곳에서 모두 메세지를 받아야만 리더는 프로듀서에게 메세지를 잘 받았다는 acks 를 받을 수 있다. 하지만, 팔로워 한 개를 강제 종료하였기 때문에 ISR 에는 리더와 팔로워 각각 하나만 남아 있는 상태다. 결국 옵션의 조건을 충족시킬 수 없는 상황이기 때문에 에러가 발생한다. 카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;","link":"/2019/12/28/kafka-chapter4/"},{"title":"[카프카] 5장_카프카 컨슈머","text":"컨슈머란, 프로듀서가 메세지를 생산해서 카프카의 토픽으로 보내면 그 토픽의 메세지를 가져와 소비하는 애플리케이션, 서버이다.주요 기능은, 특정 파티션을 관리하고 있는 파티션 리더에게 메세지를 가져오기 요청을 하는 것이다. 파티션과 메세지 순서파티션 3 개로 구성한 토픽과 메세지 순서프로듀서 다음 순서로 보낸다. 12345abcde 컨슈머에서 –from-beginning 옵션으로 받는다.메세지의 순서가 프로듀서가 보낸 순서가 아니다. 12345adbec 다음으로, 프로듀서서가 숫자를 보낸다. 1234512345 컨슈머에서 –from-beginning 옵션으로 받는다. 12345678910ad14be25c3 –partition 0, –partition 1, –partition 3 로 각각 옵션을 주어서 컨슈머를 각각 실행해보면, 1234be25 1234ad14 12c3 위 현상은 정상이다.프로듀서가 메세지를 a b c d e 순서로 보냈지만, 해당 메세지들은 하나의 파티션에만 순서대로 저장되는 것이 아니라 각각의 파티션별로 메세지가 저장되었다.컨슈머의 출력 내용은 각 파티션의 오프셋 순서대로 메세지를 가져온 것이다. 즉, 카프카 컨슈머에서의 메세지 순서는 동일한 파티션 내에서는 프로듀서가 생성한 순서와 동일하게 처리하지만, 파티션과 파티션 사이에서는 순서를 보장하지 않는다. 그림으로 나타내면 아래와 같다. 파티션 1 개로 구성한 토픽과 메세지 순서메세지 순서를 정확하게 보장받기 위해서는 토픽 파티션 수를 1 로 지정하면 된다.단점은, 분산해서 처리할 수 없고 하나의 컨슈머에서만 처리할 수 있기 때문에 처리량이 낮다. 컨슈머 그룹동일한 토픽에 대해 여러 컨슈머가 메세지를 가져갈 수 있도록 컨슈머 그룹이라는 기능을 제공한다.이 방식은, 최근에 하나의 데이터를 다양한 용도로 사용하는 요구가 많아져서 유용하다.즉, 하나의 토픽을 여러 consumer group 이 서로 다른 목적 달성을 위해 consume 하기 위해 사용되는 것이다. 아래 그림에서, 갑자기 프로듀서가 해당 토픽으로 많은 메세지를 전송한다고 가정해보자. 그러면,프로듀서가 메세지를 보내는 속도가 컨슈머가 메세지를 가져가는 속도보다 빨라서, 컨슈머가 읽어가지 못하는 메세지들이 쌓인다. 그래서 다음과 같이 컨슈머를 확장한다. 하나의 파티션, 하나의 컨슈머그런데, 이렇게 컨슈머를 추가했음에도 컨슈머가 가져가야하는 메세지가 쌓이면 어떻게 해야할까 ? 위와 같이 컨슈머 04 를 추가해보자. 그대로다.왜냐하면, 토픽의 파티션에는 하나의 컨슈머만 연결할 수 있기 때문이다.각각의 파티션에 대해서는 메세지 순서를 보장하는데 두 개의 컨슈머가 하나의 파티션을 공유하면 안정적으로 메세지 순서를 보장할 수 없다.그래서 파티션 수도 같이 늘려줘야한다. 리벨런싱컨슈머 그룹 안에서는 컨슈머들이 메세지를 가져오고 있는 토픽의 파티션에 대한 소유권을 공유한다.partition 01 의 소유권이 consumer 01 에서 consumer 02 로, partition 02 의 소유권이 consumer 01 에서 consumer 03 으로 이동할 수 있다.이렇게 소유권이 이동하는 것을 rebalancing 이라고 한다.리밸런스의 단점은, 리밸런스 하는 동안 일시적으로 컨슈머는 메세지를 가져올 수 없다는 것이다. 위와 같이, 컨슈머 그룹에서 consumer 03 이 다운되는 경우를 살펴보자.컨슈머가 컨슈머 그룹 안에서 멤버로 유지되고 할당된 파티션의 소유권을 유지하는 방법은, heart beat 를 보내는 것이다.만약, 컨슈머가 오랫동안 하트비트를 보내지 않으면 세션은 타임아웃되고 해당 컨슈머가 다운되었다고 판단해서 리밸런스가 시작된다.consumer 03 이 다운되면서 consumer 03 이 담당하던 partition 03 을 consumer 02 가 이어받는다. 커밋과 오프셋컨슈머가 poll() 을 호출할 때마다 컨슈머 그룹은 카프카에 저장되어 있는 아직 읽지 않는 메세지를 가져온다.이것이 가능한 이유는, 컨슈머 그룹이 어디까지 메세지를 가져갔는지 알 수 있기 때문이다.컨슈머 그룹의 각각 컨슈머들은 각각의 파티션에 자신이 가져간 메세지의 위치 정보인 오프셋을 기록한다.각 파티션에 대해 현재 위치를 업데이하는 것을 커밋 이라고 한다. 올드 카프카 컨슈머 (0.9 이전 버젼)오프셋 정보를 주키퍼에 저장 뉴 카프카 컨슈머내부에서 사용하는 토픽 (_consumer_offsets) 을 만들고 이 토픽에 오프셋 정보를 저장 자동 커밋1enable.auto.commit = true 컨슈머가 poll() 을 호출할 때마다 가장 마지막 오프셋을 커밋한다. 수동 커밋메세지 처리가 완료될 때까지 메세지를 가져온 것으로 간주되어서는 안되는 경우에 사용한다.ex) 메세지를 컨슈머가 가져오자마자 커밋하는 것이 아니라, 데이터베이스에 메세지를 저장한 후 커밋을 한다. 카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;","link":"/2019/12/29/kafka-chapter5/"},{"title":"[오브젝트] 11장_합성과 유연한 설계","text":"코드 재사용 기법으로는, 상속부모클래스와 자식클래스를 연결해서, 부모클래스의 코드 재사용 합성전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 객체의 코드 재사용내부에 포함되는 객체의 구현이 아니라 퍼블릭 인터페이스에 의존 01 상속을 합성으로 변경하기상속의 문제는, 불필요한 인터페이스 상속 메서드 오버라이딩 오작용 부모 클래스와 자식 클래스 동시 수정 이 문제들을 합성으로 해결해보자. 불필요한 인터페이스 상속 : java.utils.Properties, java.utils.Stack 불필요한 Hasbtable 의 오퍼레이션들이 Properties 클래스의 퍼블릭 인터페이스를 오염시키지 않는다. 1234567891011public class Properties { private Hashtable&lt;String, String&gt; properties = new Hashtable&lt;&gt;(); public String setProperty(String key, String value) { return properties.put(key, value); } public String getProperty(String key) { return properties.get(key); }} 불필요한 Vector 의 오퍼레이션들이 Stack 클래스의 퍼블릭 인터페이스를 오염시키지 않는다. 1234567891011121314151617public class Stack&lt;E&gt; { private Vector&lt;E&gt; elements = new Vector&lt;&gt;(); public E push(E item) { elements.addElement(item); return item; } public E Pop() { if (elements.isEmpty()) { throw new EmptyStackException(); } return elements.remove(elements.size() - 1); }} 메서드 오버라이딩 오작용 : InstrumentedHashSet12345678public class InstrumentedHashSet&lt;E&gt; implements Set { private Set&lt;E&gt; set; ... @Override .. @Override .. @Override ..} 부모 클래스와 자식 클래스의 동시 수정 : PersonalPlaylist12345678910111213public class PersonalPlaylis { private Playlist playlist = new Playlist(); public void append(Song song){ playlis.append(song); } public void remove(Song song){ playlist.getTracks().remove(song); playlist.getSingers().remove(song.getSinger()); }} 02 상속으로 인한 조합의 폭발적인 증가상속으로 작은 기능들을 조합해 더 큰 기능을 수행하는 객체를 만들 때의 문제는, 하나의 기능을 추가하거나 수정을 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야한다. 단일 상속만 지원하는 언어에서는 상속으로 중복 코드가 중가한다. 기본 정책과 부가 정책 조합하기 기본 정책 : 일반 요금제 / 심야 할인 요금제 부가 정책 : 세금 정책 / 기본 요금 할인 정책기본 정책의 계산 결과에 적용, 선택적으로 적용 가능, 조합 가능, 임의의 순서로 적용 가능 상속을 이용해서 기본 정책 구현하기기본 정책에 세금 정책 조합하기기본 정책에 기본 요금 할인 정책 조합하기중복 코드의 덫에 걸리다 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야하는 경우를 클래스 폭발 문제, 조합의 폭발 문제 라고 한다.이 문제는, 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 한계 때문에 발생하는 문제이다. 03 합성 관계로 변경하기 상속조합의 결과를 개별 클래스 안으로 밀어 넣는 방법 합성합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후 실행 시점에 인스턴스를 조립하는 방법 기본 정책 합성하기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public interface RatePolicy { Money calculateFee(Phone phone);}public abstract class BasicRatePolicy implements RatePolicy { @Override public Money calculateFee(Phone phone) { Money result = Money.ZERO; for(Call call phone.getCalls(){ result.plus(calculateCallFee(call)); } return result; } protected abstract Money calculateCallFee(Call call);}public class RegularPolicy extends BasicRatePolicy { private Money amnount; private Duration seconds; public RegularPolicy(Money amnount, Duration seconds) { this.amnount = amnount; this.seconds = seconds; } @Override protected Money calculateCallFee(Call call) { return amnount.times(call.getDuration().getSeconds() / seconds.getSeconds()); }} public class NightlyDiscountPolicy extends BasicRatePolicy { private static final int LATE_NIGHT_HOUR = 22; private Money nightlyAmnount; private Money regularAmnount; private Duration seconds; public NightlyDiscountPolicy(Money nightlyAmnount, Money regularAmnount, Duration seconds) { this.nightlyAmnount = nightlyAmnount; this.regularAmnount = regularAmnount; this.seconds = seconds; } @Override protected Money calculateCallFee(Call call) { if (call.getFrom.getHour() &gt;= LATE_NIGHT_HOUR) { return nightlyAmnount.times(call.getDuration().getSeconds() / seconds.getSeconds()); } return regularAmnount.times(call.getDuration().getSeconds() / seconds.getSeconds()); }} public class Phone { private RatePolicy ratePolicy; // Phone 이 다양한 요금 정책과 협력할수 있어야 하므로 인터페이스 private List&lt;Call&gt; calls = new ArrayList&lt;&gt;(); public Phone(RatePolicy ratePolicy) { this.ratePolicy = ratePolicy; } public List&lt;Call&gt; getCalls() { return Collections.unmodifiableList(calls); } public Money calculateFee() { return ratePolicy.calculateFee(this); }} 12345// 일반 요금제Phone phone = new Phone(new RegularPolicy(Money.wons(10), Duration.ofSeconds(10)));// 심야 할인 요금제Phone phone = new Phone(new NightlyDiscountPolicy(Money.wons(5), Money.wons(10), Duration.ofSeconds(10))); 부가 정책 적용하기123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class AdditionalRatePolicy implements RatePolicy { private RatePolicy next; public AdditionalRatePolicy(RatePolicy next) { this.next = next; } @Override public Money calculateFee(Phone phone) { Money fee = next.calculateFee(phone); return afterCalculated(fee); } abstract protected Money afterCalculated(Money fee);}public class TaxablePolicy extends AdditionalRatePolicy { private double taxRatio; public TaxablePolicy(RatePolicy next, double taxRatio) { super(next); this.taxRatio = taxRatio; } @Override protected Money afterCalculated(Money fee) { return fee.plus(fee.times(taxRatio)); }}public class RateDiscountPolicy extends AdditionalRatePolicy{ private Money disoucntAmount; public RateDiscountPolicy(RatePolicy next, Money disoucntAmount) { super(next); this.disoucntAmount = disoucntAmount; } @Override protected Money afterCalculated(Money fee) { return fee.minus(disoucntAmount); }} 기본 정책과 부가 정책 합성하기12345678910// 일반 요금제에 세금 정책 조합Phone phone = new Phone( new TaxablePolicy(0.05, new RegularPolicy(...)));// 일반 요금제에 기본 요금 할인 정책을 조합한 결과에 세금 정책 조합Phone phone = new Phone( new TaxablePolicy(0.05, new RateDiscountablePolicy(Money.wons(1000), new RegularPolicy(...)))); 새로운 정책 추가하기 요구사항이 변경되면 오직 하나의 클래스만 수정하면 된다.세금 정책을 변경한다고 할 때, 상속여러 클래스를 수정 합성오직 TaxablePolicy 클래스 하나만 변경 04 믹스인객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법이다.합성처럼 유연하며 상속처럼 쉽게 코드 재사용할 수 있다.스칼라의 trait 를 이용하면 믹스인 구현이 가능하다.","link":"/2019/12/27/object-chapter11/"},{"title":"[빅데이터를 지탱하는 기술] 1장_빅데이터 기초 지식","text":"1.빅데이터의 정착빅데이터 기술의 요구 : Hadoop 과 NoSQL 의 대두세계 곳곳에서 엑세스 되는 시스템 증가로, 전통적인 관계형 데이터베이스로는 취급 할 수 없는 데이터가 쌓이게 되었다.그래서 다른 구조가 필요했다. Hadoop다수의 컴퓨터에서 대량의 데이터 처리 NoSQL Database빈번한 읽기/ 쓰기 및 분산처리가 강점 분산 시스템의 비즈니스 이용 개척 : 데이터 웨어하우스와의 공존 위 그림처럼, 확장성이 뛰어난 Hadoop 에 데이터 처리를 맡겨 데이터 웨어하우스의 부하를 줄이고 있다. 직접 할 수 있는 데이터 분석 폭 확대‘여러 컴퓨터에서 분산 처리한다’ 는 빅데이터의 특징으로 하드웨어를 준비하고 관리하는게 어려웠다.하지만, 클라우드 시대에서는 필요한 자원 확보가 쉬워서 얼마든지 빅데이터를 이용할 수 있다. 데이터 디스커버리의 기초 지식 데이터 디스커버리대화형으로 데이터를 시각화하여 가치있는 정보를 찾으려고하는 프로세스 BI 도구데이터 디스커버리를 위한 셀프 서비스용 시각화 시스템 2. 빅데이터 시대의 데이터 분석 기반빅데이터 기술이 기존 데이터 웨어하우스와 다른 점은,다수의 분산 시스템을 조합하여 확장성이 뛰어난 데이터 처리 구조를 만든다는 것이다. 데이터 파이프라인 차례대로 전달해다가는 데이터로 구성된 시스템이다. 데이터 파이프라인의 기본적인 흐름은, 데이터를 모아서 축적 데이터 마트 구성 시각화 도구 데이터 수집데이터 파이프라인은 데이터를 모으는 부분부터 시작한다. 수집 방법은, 벌크형이미 어딘가에 있는 데이터를 정리해서 추출ex ) 데이터베이스와 파일 서버 등에서 정기적으로 데이터 수집 스트리밍형차례대로 생성되는 데이터를 끊임없이 보냄ex) 모바일 어플리케이션, 임베디드 장비 스트림 처리와 배치처리 스트림 처리스트리밍 형 방법으로 받은 데이터를 실시간으로 처리.장기적인 데이터 분석에는 적합하지 않음. 배치 처리정리된 데이터를 효율적으로 가공하기 위한 처리.장기적인 데이터 분석을 위해 대량의 데이터를 저장하고 처리하는데 적합한 분산 시스템이 필요. 분산 스토리지여러 컴퓨터와 디스크로 구성된 스토리지 시스템이다. 데이터 저장 방법으로, 객체 스토리지한 덩어리로 모인 데이터에 이름을 부여해서 파일로 저장.ex ) Amazon S3 NoSQL 데이터베이스많은 데이터를 읽고 쓰기에 유리. 분산 데이터 처리분산 스토리지에 저장된 데이터를 처리하기 위해, 분산 데이터 처리 프레임워크가 필요하다. ex) MapReduce주 역할은, 나중에 분석하기 쉽도록 데이터를 가공해서 그 결과를 외부 데이터베이스에 저장하는 것이다.빅데이터를 SQL 로 집계하는 방법으로, 쿼리 엔진Hive, 대화형 쿼리엔진 데이터 웨어하우스 제품ETL.데이터를 추출하고 가공한후, 데이터 웨어하우스에 로드한다. 워크플로우 관리데이터파이프라인이 복잡해지면, 한곳에서 제어하지 않으면 전체 움직임 파악이 어렵다. 데이터 웨어하우스와 데이터 마트 데이터 소스RDB 나 로그 등을 저장하는 파일 서버 ETL 플로세스데이터 소스에 보존된 raw data 를 추출하고 필요에 따라 가공한 후 데이터 웨어하우스에 저장하기까지의 흐름 데이터 마트데이터웨어 하우스에서 필요한 데이터만을 추출하여 데이터마트를 구축 데이터 레이크 모든 데이터를 원래의 형태로 추적해두고 나중에 필요에 따라 가공하는 구조가 필요하다.이 데이터 축적 장소가 데이터 레이크이다. 분산 스토리지가 데이터 레이크로 이용된다.데이터 레이크의 데이터를 가공하기 위해 MapReduce 같은 분산 데이터 처리 기술이 필요하다. 데이터 분석 기반을 단계적으로 발전시키기 데이터 엔지니어시스템의 구축 및 운용, 자동화 데이터 분석가데이터에서 가치있는 정보 추출 확증적 데이터 분석과 탐색적 데이터 분석 확증적 데이터 분석가설을 세우고 검증.통계학적 모델링에 의한 데이터 분석. 탐색적 데이터 분석데이터를 보며 의미를 읽어냄.데이터를 시각화하여 사람의 힘으로 의미를 읽어냄 빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;","link":"/2019/12/30/big-data-chapter1/"},{"title":"[빅데이터를 지탱하는 기술] 2장_빅데이터 탐색","text":"1. 크로스 집계크로스 집계 크로스 테이블행과 열이 교차하는 부분에 숫자 데이터가 들어감 트랜젝션 테이블행방향으로만 증가하고, 열방향으로는 데이터가 증가하지 않음 크로스 집계트레젝션 테이블에서 크로스 테이블로 변환하는 과정.피봇 테이블을 이용해서 할 수 있다. 룩업 테이블트랜젝션 테이블의 ‘상품 ID’ 를 사용해서 ‘상품명’ 과 ‘상품 카테고리’ 참고할 때 사용되는 것이, 룩업 테이블이다.상품 정보를 하나의 테이블로 정리해두면 나중에 속성을 추가하거나 변경하는 것도 간단하다. 2. 열 지향 스토리지처리량과 지연 시간 처리량 ( throughput )일정 시간에 처리할 수 있는 데이터의 양.배치 처리 등 대규모 데이터 처리에서 중요시. 지연 ( latency )데이터 처리가 끝날 때 까지의 대기 시간.애드 혹 데이터 분석에서 중요시. 데이터 처리의 지연데이터 처리의 응답이 빠르면, ‘지연이 적다’ 라고 한다. 메모리모든 데이터를 메모리에 올리는 것이다. RDB만일, 한 레코드의 크기가 500 바이트라고 하면, 천만 레코드의 경우 5 GB 가 된다.이 정도면, MySQL 이나 PostgreSQL 같은 일반적인 RDB 가 데이터 마트로 적합하다.RDB는 원래 지연이 적고 많은 클라이언트가 접속해도 성능이 나빠지지 않으므로 많은 사용자가 사용하는 실제 운영 환경의 데이터 마트로 적합하다.하지만, RDB 는 메모리가 부족하면 급격히 성능이 저하된다. ‘압축’, ‘분산’ 에 의해 지연 줄이기데이터를 가능한 작게 ‘압축’ 하고 여러 디스크에 ‘분산’ 함으로써 데이터 로드에 따른 지연을 줄일 수 있다.분산된 데이터를 읽기 위해서는 멀티 코어를 활용해 디스크 I/O 를 병렬 처리하는 것이 효과적이다.이런 아키텍쳐를 MPP (Massive Parallel Processing) 라고 한다.대량 데이터를 분석하기 위해 데이터베이스에 널리 사용되고 있다.ex ) Amazon Redshift, Google BigQuery 행 지향, 열 지향 데이터베이스 행 지향 데이터베이스레코드 단위로 읽고 쓰기에 최적화.테이블의 각 행을 하나의 덩어리로 디스크에 저장.새 레코드 추가할 때마다 파일의 끝에 데이터를 쓸 뿐이여서 빠르게 추가 가능.데이터 검색을 고속화하기 위해 인덱스 사용.데이터 분석에서는 어떤 칼럼 사용될지 미리 알 수 없으므로, 인덱스를 작성해도 도움이 되지 않음.ex ) Oracble, MySQL 열 지향 데이터베이스칼럼 단위의 집계에 최적화.데이터를 미리 칼럼 단위로 정리해서 필요한 칼럼만을 로드하여 디스크 I/O 를 줄임.같은 칼럼에는 종종 유사한 데이터가 나열되어서 데이터 압축 효율도 우수.ex ) Teradata, Amazon Redshift MPP 데이터베이스 행 지향 데이터베이스하나의 쿼리는 하나의 스레드에서 실행.하나의 쿼리가 충분히 짧은 시간에 끝나는 것으로 가정하므로 하나의 쿼리를 분산 처리하는 상황은 가정하지 않음. 열 지향 데이터베이스디스크에서 대량의 데이터를 읽기 때문에 한 번의 쿼리 실행 시간이 길다.멀티 코어를 활용해서 고속화 하는것이 좋음. MPP 에서는 하나의 쿼리를 다수의 태스크로 분해하고, 이를 가능한 한 병렬로 수행한다.예를 들어, 1억 래코드로 이루어진 테이블의 합계를 계산하기 위해 10만 레코드로 구분하여 1000 개의 테스크로 나눈다. 각 테스크는 각각 독립적으로 10 만 레코드의 합계를 집계해서 마지막 모든 결과를 모아 총 합계를 계산한다. MPP 를 사용한 데이터 집계는 CPU 코어수에 비례해서 고속화된다.단, 디스크로부터의 로드가 병목 현상이 발생하지 않도록 데이터가 고르게 분산되어 있어야한다. 3. 애드 혹 분석과 시각화 도구 Jupyter Notebook Redash Superset Kibana 4. 데이터 마트의 기본 구조다차원 모델과 OLAP 큐브 RDB표 형식으로 모델링된 데이터를 SQL 로 집계한다. OLAP다차원 모델의 데이터 구조를, MDX (Multidimensional Exrepssions) 등의 쿼리 언어로 집계한다. 데이터 분석을 위해 만들어진 다차원의 데이터를 OLAP 큐브라고 한다. OLAP 큐브를 크로스 집계하는 구조가 OALP 이다.컴퓨터 성능이 높지 않을 때는, 크로스 집계의 모든 조합을 데이터 베이스 안에 캐쉬해두고, 쿼리가 실행되면 이미 집계된 결과를 반환하는 구조였다.최근에는 MPP 데이터베이스와 인 메모리 데이터베이스로, 사전에 계산해 둘 필요가 없다. MPP 데이터베이스에 다차원 모델의 개념이 없기 때문에, 이를 대신해 ‘비정규화 테이블’ 을 준비한다. 비정규화 테이블을 BI 도구에서 열어서 기존의 OLAP 과 동등한 시각화를 실현할 수 있다. 트렌젝션, 마스터 테이블 트랜젝션 테이블시간과 함께 생성되는 데이터들을 기록 마스터 테이블트랜젝션에서 참고되는 각종 정보를 기록 팩트, 디맨젼 테이블 팩트 테이블트랜젝션 테이블 처럼, 사실이 기록된 것.집계의 기반이 되는 숫자 데이터 등. 디멘젼 테이블마스터 테이블 처럼, 참고되는 마스터 데이터.데이터를 분류하기 위한 속성 값. 스타 스키마 데이터 마트를 만들때는, 팩트 테이블을 중심으로 여러 디멘젼 테이블을 결합하는 것이 좋다.스타 스키마를 사용하는 이유는, 단순하고 이해하기 쉬워 데이터 분석이 쉽다. 성능 상의 이유데이터 양이 증가하면 팩트 테이블은 디멘젼 테이블보다 훨씬 커져, 팩트 테이브이 메모리 용량을 초과한 시점에 디스크 I/O 가 발생하고 그 대기 시간으로 쿼리의 지연으로 이어진다.그래서, 팩트 테이블에는 id 와 같은 키만을 남겨두고 그 이외의 나머지는 디멘젼 테이블로 옮긴다. 비정규화 테이블스타 스키마는 과거의 이야기이다. 성능 상의 문제는 열 지향 스토리지에 의해 해결된다.MPP 데이터베이스와 같은 열 지향 스토리지의 보급으로, 칼럼의 수가 아무리 늘어나도 성능에 영향이 없다.그래서, 처음부터 팩트 테이블에 모든 칼럼을 포함하고 쿼리의 실행 시에는 테이블 결합을 하지 않는 것이 간단하다.스타 스키마에 비정규화를 진행해 모든 테이블을 결합한 팩트 테이블을 비정규화 테이블이라고 한다. 테이블 추상화 비정규화 테이블을 준비했으면, 다차원 모델에 의해 추상화한다.다차원 모델은 칼럼을 디멘젼과 측정값으로 분류한다. 디멘젼주로 날짜 및 문자열.크로스 집계의 행이나 열로 사용 측정값주로 숫자값. 빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;","link":"/2019/12/30/big-data-chapter2/"},{"title":"[빅데이터를 지탱하는 기술] 3장_빅데이터 분산처리","text":"1. 대규모 분산 처리의 프레임워크비구조화 데이터를 읽어 들여 열 지향 스토리지로 변환하는 과정에서, 데이터의 가공 및 압축을 위해 많은 컴퓨터 리소스가 소비된다.그래서 사용하는 것이 Hadoop, Spark 같은 분산 처리 프레임워크다. 구조화 데이터, 비구조화 데이터, 스키마리스 데이터 구조화 데이터스키마가 명확하게 정의된 데이터.기존의 데이터 웨어하우스에서는 항상 구조화 데이터로 축적하는 것이 일반적이었다. 비구조화 데이터스키마가 없는 데이터.이 상태로는 SQL 로 제대로 집계할 수 없다. 스키마리스 데이터CSV, JSON, XML 등의 데이터는 서식은 정해져 있지만, 칼럼 수나 데이터 형은 명확하지 않다. 데이터 구조화의 파이프라인 분산 스토리지에 수집된 데이터는 명확한 스키마를 갖지 않아 그대로는 SQL 로 집계할 수 없다.그래서, 먼저 스키마를 명확하게 한 테이블 형식으로 변환해야한다.구조화된 데이터는 데이터 압축률을 높이기 위해 열 지향 스토리지에 저장한다. 열 지향 스토리지의 작성Hadoop 의 열 지향 스토리지는, Apache ORC처음에 스키마를 정한 후 데이터를 저장 Apache Parquet스키마리스에 가까운 데이터 구조로 되어 있어서 JSON 같은 데이터도 그대로 저장 Hadoop 단일 소프트웨어가 아니라 분산 시스템을 구성하는 다수의 소프트웨어로 이루어진 집합체이다.기본 구성 요소는, 분산 파일 시스템HDFS.다수의 컴퓨터에 파일을 복사하여 중복성을 높이는 특징이 있다. 리소스 관리자YARN, Mesos.YARN 은 애플리케이션이 사용하는 CPU 코어와 메모리를 컨테이너라는 단위로 관리한다.Hadoop 에서 분산 애플리케이션을 실행하면 YARN 이 클러스터 전체의 부하를 보고 비어 있는 호스트부터 컨테이너를 할당한다.어느 애플리케이션에 얼마만큼의 리소스를 할당할 지 관리해서 모든 애플리케이션이 실행되도록 제어한다. 분산 데이터 처리MapReduce, Tez.MapReduce 도 YARN 위에서 동작하는 분산 애플리케이션 중 하나이다. 쿼리 엔진 하둡에서는 다수의 쿼리 엔진이 개발되었다. 총칭해서 SQL-on-Hadoop 이라고 한다.SQL 등의 쿼리 언어에 의한 데이터 집계가 목적이면, 이를 위해 설계된 쿼리 엔진을 사용한다.Apache Hive 가 대표적이다. 쿼리를 자동으로 MapReduce 프로그램으로 변환하는 소프트웨어이다.시간이 걸리는 배치 처리에는 적합하나, 애드 혹 쿼리를 여러 번 실행하는데는 부적합하다.왜냐하면 위 그림처럼, 스테이지가 바뀔 때 대기 시간이 있기 때문이다. Apache Tez 는 Hive 를 가속화하기 위해 개발되었다. 기존의 MapReduce 를 대체할 목적이다.Hive on MR 은, 1회의 MapReduce 스테이지가 끝날 때까지 다음의 처리를 진행할 수 없다.Hive on Tez 는, 위 그림처럼 스테이지의 종료를 기다리지 않고 데이터를 차례대로 후속 처리에 전달하여 쿼리 전체 실행 시간을 단축한다. 대화형 쿼리엔진 Apache Impala 와 Presto 가 대표적이다.YARN 과 같은 리소스 관리자를 사용하지 않고, SQL 의 실행만으로 분산처리를 구현한다.순간 최대 속도를 높이기 위해 모든 오버 헤드가 제거되어, 사용할 수 있는 리소스를 최대한 활용하여 쿼리를 실행한다. Spark MapReduce, Tez 모두 데이터 처리 과정에서 만들어진 중간 데이터를 디스크에 기록한다.Spark 는 대량의 메모리를 활용하여 고속화를 실현한다.Hadoop 을 대체하는 것이 아니라, MapReduce 를 대체하는 존재다. 2. 쿼리 엔진 데이터 마트 구축의 파이프라인 Hive분산 스토리지에 저장된 데이터를 구조화하고 열 지향 스토리지 형식으로 저장 Presto완성한 구조화 데이터를 결합, 집계하고 비정규화 테이블로 만든 데이터 마트에 써서 보냄 Hive 에 의한 구조화 데이터 작성1hive&gt; CREATE EXTERNAL TABLE access_log_csv (...) CSV 파일을 읽어들여 외부 테이블을 정의한다.외부테이블이란, Hive 의 외부에 있는 특정 파일을 참고해 마치 거기에 테이블이 존재하는 것처럼 읽어 들이기 위해 지정한다.쿼리를 실행할 때마다 매번 텍스트를 읽어들이기 때문에 느리다. 그래서 열 지향 스토리지로 변환해야한다. 열 지향 스토리지로의 변환1hive&gt; CREATE TABLE access_log_orc STROED as ORC as SELECT .. 텍스트 데이터를 열 지향 스토리지로 변환함으로써 데이터의 집계가 크게 고속화된다. Hive 로 비정규화 테이블 작성하기데이터 구조화가 완료되면 데이터 마트를 구축해야한다. 즉, 테이블을 결합 및 집약해서 ‘비정규화 테이블’ 을 만든다.Preso 와 같은 대화형 쿼리 엔진, Hive 같은 배치형 쿼리 엔진을 사용할 수 있다. 시간이 걸리는 배치 처리는 Hive 를 사용해야한다.비정규화 테이블을 만드는 데 오랜 시간이 걸리므로, 가능한 효율적인 쿼리를 작성해야한다. 서브 쿼리 안에서 레코드 수 줄이기서브 쿼리 안에서 팩트 테이블을 작게 해야한다.데이터의 양의 감소 시킨 후에 테이블을 결합하는 것이 쿼리 실행 시간을 단축시킨다. 데이터 편향 피하기분산 시스템의 성능을 발휘하기 위해서, 모든 노드에 데이터가 균등하게 분산되도록 해야한다. 대화형 쿼리 엔진 Presto 구조쿼리 실행의 지연을 감소시키는 목적으로 개발된 것이 대화형 쿼리 엔진이다.Presto 의 특징은, 플러그인 가능한 스토리지다양한 데이터 소스를 테이블로 참고할 수 있다.ex) 하나의 쿼리 안에서 분산 스토리지 상의 팩트 테이블과 MySQL 의 마스터 테이블을 조인할 있다. CPU 처리의 최적화코드의 실행을 멀티 스레드화되어 단일 머신에서 수백 태스크나 병렬로 실행된다.그래서, CPU 이용 효율이 높다. 인 메모리 처리에 의한 고속화모든 데이터 처리는 메모리 상에서 실시하고 메모리가 부족하면 여유가 생길 때까지 기다리거나 오류로 실패한다. 데이터 분석의 프레임워크 선택하기 MPP Database비정규화 테이블을 고속으로 집계하는 데에 최적 Hive데이터 양에 좌우되지 않는 쿼리 엔진 Presto속도 중시, 대화식으로 특화된 쿼리 엔진 Spark분산 시스템을 사용한 프로그래밍 환경.ETL 프로세스에서 SQL 에 이르기 까지의 일련의 흐름을 하나의 데이터 파이프라인으로 기술 가능. 3. 데이터 마트의 구축분산 시스템이 준비되면 시각화를 위해 데이터 마트를 만든다. 팩트 테이블팩트 테이블 작성 방법으로, 추가새로 도착한 데이터만을 증분으로 추가 치환과거 데이터를 포함하여 테이블 전체 치환 테이블 파티셔닝위의 ‘추가’ 방법은 다음 문제가 있다. 추가에 실패한것을 알아채지 못하면, 팩트 테이블의 일부에 결손 추가를 잘못해서 여러번 실행하면, 일부 중복 나중에 팩트 테이블 다시 만들고 싶으면, 관리 복잡 그래서 파티셔닝이 필요하다.하나의 테이블을 여러 물리적인 파티션으로 나눠서 파티션 단위로 정리하여 데이터를 쓰거나 삭제하는 것이다. 집계 테이블팩트 테이블을 어느 정도 모아서 집계하면 데이터의 양이 줄어든다. 이것은 집계 테이블이라고 한다.각 칼럼이 취하는 값의 범위란, 카디널리티이다. ‘성별’ 과 같이 취할 수 있는 값이 적은 것은 카디널리티가 작은 것이다.집계 테이블을 작게 하려면 모든 칼럼의 카디널리티를 줄여야한다. 스냅샷 테이블, 이력 테이블마스터 데이터처럼 업데이트 될 가능성이 있는 테이블은,정기적으로 테이블을 통째로 저장하는 스탭샷 테이블, 또는 변경 내용만을 저장하는 이력 테이블로 관리할 수 있다. 디멘전을 추가하여 비정규화 테이블 완성시키기팩트 테이블과 디멘젼 테이블을 결합하여 비정규화 테이블을 만든다. 빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;","link":"/2019/12/30/big-data-chapter3/"},{"title":"[빅데이터를 지탱하는 기술] 5장_빅데이터 파이프라인","text":"1. 워크 플로우 관리기초 지식 워크 플로우 관리 도구 워크 플로우 관리 도구의 주요 역할은, 정기적으로 태스크를 실행하고 비정상적인 상태를 감지하여 해결을 돕는 것이다. ex) Airflow, Azkaban, Digdag, Luigi, Oozie 태스크 데이터 파이프라인의 실행 과정에서 데이터를 잇달아 이동하면서 정해진 처리를 반복하는데, 이때 실행되는 개별 처리이다. 기본 기능 테스크를 정기적인 스케쥴로 실행하고 결과 통지 테스크 간의 의존 관계를 정하고 순서대로 빠지없이 실행 테스크의 실행 결과를 보관하고, 오류 발생하면 재실행 할 수 있도록 하기 선언 형과 스크립트 형 선언형 : XML 이나 YAML 등의 서식으로 워크플로우 기술 스크립트형 : 스크립트 언어로 워크플로우 정의 오류로부터 복구 방법모든 오류를 사전에 예상하는 것은 불가능하기 때문에, 오류 발생 가능성을 고려하여 대처 방법을 결정해야한다. Retry 재시도를 반복해도 문제가 없는 태스크라면, 1회나 2회의 재시도를 실행해도 좋다. 그러나, 그 이상은 재시도가 아니라 올바른 문제 해결 방법을 찾아야한다. Backfill 플로우 전체를 처음부터 다시 실행한다. 다음 상황에 사용한다. 태스크의 실패가 며칠 동안이나 계속된 후에 이를 모아서 재시도 하고 싶을 때 새롭게 만든 워크 플로우를 과거로 거슬라 올라가 실행하고 싶을 때 재실행의 안정성을 위한 두가지 방법 원자성 조작 (Atomic Operation) 예를 들어, INSERT 문 2회를 호출하는 태스크가 있다고 하자. 첫 번째의 INSERT 가 종료되고 오류가 발생하면 태스크를 재실행하면 동일한 데이터가 다시 쓰이게 될 수 있다. 이 문제를 회피하기 위해, 각 태스크가 시스템에 변경을 가하는 것을 한 번만 할 수 있도록 하는 것이다. 쓰기가 필요한 수 만큼 테스크를 나누는 것이다. 하지만, 태스크 구현상의 버그 등으로 원자성 조작 직후에 문제가 발생하면 원자성 조작 자체는 성공했어도 워크 플로우 관리 도구에서는 오류로 여길 수 있다. 멱등한 조작 더 확실한 방법은, 동일한 태스크를 여러 번 실행해도 동일한 결과가 되도록 하는 것이다. 예를 들어 분산 스토리지에 파일을 업로드할 때, 매번 새로운 파일명을 만들 경우 데이터를 추가 (append) 하는 것이고, 동일 파일명으로 덮어쓰면 치환 (replace)하는 것이다. 치환은 반복해도 결과가 변하지 않으므로 멱등하다. 데이터 추가 멱등한 추가 과거의 모든 데이터를 치환하면 멱등하지만 부하가 커진다. 그래서, Table Partitioning 이 필요하다. 예를 들면 테이블을 1일마다 또는 1시간 마다 파티션으로 분할하고 파티션 단위로 치환하는 것이다. 파티션의 모든 데이터를 삭제할 때, TRUNCATE 문이나 INSESRT OVERWRITER 문 등을 사용할 수 있다. ex) Hive 는 파티셔닝 지원, Amazon Redshift 는 파티셔닝을 지원하지 않아 UNION ALL 사용 원자성을 지닌 추가 하나의 테이블에 여러번 데이터를 써넣는 경우, 중간 테이블을 이용해 마지막에 목적 테이블에 한 번 추가한다. 즉, 전반 부분에서는 중간 테이블을 만들기 위해 테이블을 치환하므로 멱등하다. 그러나 마지막에 INSESRT 는 단순히 추가이므로 전체로서는 멱등하지 않다. 단, 마지막에 쓰기를 1회만 실시하므로 이것은 원자성을 지닌 조작이다. 그래서 플로우가 실패해도 아무것도 쓰이지 않아 실패한 태스크를 재실행해도 복구가 완료된다. 워크 플로우 전체를 멱등하게 하기재실행의 안정성을 위해서는, 멱등하게 구현해야한다. Task Queue : 자원의 소비량 컨트롤대량의 테스크를 동시 실행하면 서버에 과부하가 걸리므로 어느 정도 제한 해야한다. 워크 플로우 관리 도구는, 태스크의 크기나 동시 실행 수를 변화시켜 자원의 소비량을 조정해 모든 태스크가 원활하게 실행되도록 할 수 있다. 이 때, Job Queue 또는 Task Queue 를 사용할 수 있다. 모든 태스크는 큐에 저장되고 일정 수의 워커 프로세스가 순서대로 꺼내며 병렬화가 실현된다. 2. 배치 형 데이터 플로우MapReduce 데이터 처리 첫 번째 단계를 Map, 그 결과를 모아서 집계하는 두 번째 단계를 Reduce 라고 한다. 이렇게 Map 과 Reduce 를 반복하면서 목적하는 결과를 얻을 때 까지 계속 데이터를 변화하는 구조가 MapReduce 이다. MapReduce 는 Map 과 Reduce 의 하나의 사이클이 끝나지 않으면 다음 처리로 이동하지 않는다. 즉, 하나의 사이클에서 다음 사이클로 이동할 때 까지 대기 시간이 발생한다. 데이터 플로우이전의 MapReduce 를 사용한 데이터 처리에서는, MapReduce 프로그램을 워크플로우의 태스크로 등록해 다단계의 복잡한 데이터 처리를 할 수 있었다. 현재는, 다단계의 데이터 처리를 분산 시스템 내부에서 실행할 수 있다. 이것을 데이터 플로우라고 한다. ex) 데이터 플로우를 위한 프레임워크 : Google Cloud Dataflow, Apache Spark, Apache Flick MapReduce 를 대신할 세로운 프레임워크세로운 프레임워크의 공통 특징은 DAG (Direct Acyclic Graph) 이다. 다음 두 가지 성질이 있다. 방향성 : 노드와 노드가 화살표로 연결 비순환 : 화살표를 따라가도 동일 노드로 돌아오지 않음 DAG 관점에서 MapReduce 와 데이터 플로우의 차이는, MapReduce MapReduce 도 Map 과 Reduce 의 두 종류 노드로 이루어진 DAG 라 생각할 수 있다. 하지만, 하나의 노드에서 처리가 끝나지 않으면 다음 처리로 진행할 수 없다. 데이터플로우 DAG 를 구성하는 노드가 모두 동싱 병행으로 실행된다. 처리가 끝난 데이터는 네트워크를 거쳐 차례대로 전달된다. 먼저 데이터 파이프라인 전체를 DAG 로 조립한 뒤 실행해서, 내부 스캐쥴러가 분산 시스템에 효과적인 실행 계획을 세운다. 데이터 플로우와 워크플로우 조합하기테스크를 정기적으로 실행하거나 실패한 테스크를 기록하여 복구하는 것은, 데이터플로우가 아니라 워크 플로우의 관리가 필요하다. 따라서, 데이터 플로우의 프로그램도 워크 플로우의 일부로 실행되는 하나의 태스크로 고려될 수 있다. 데이터를 읽어들이는 플로우 데이터 플로우로부터 읽어 들일 데이터는 성능적으로 안정된 분산 스토리지에 배치해야한다. 외부의 데이터 소스에서 데이터를 읽어들일 때는 읽기 속도에 한계가 있으므로 데이터 플로우를 사용한다고 해도 빨라진다고 단언할 수 없다. 분산스토리지로 데이터 복사가 완료되면 데이터 플로우로 처리한다. 데이터를 써서 내보내는 워크플로우 데이터 플로우 안에서 대량의 데이터를 외부에 전송해서는 안된다. 왜냐하면, 쓰기 작업에 오래 걸리면, 실행이 완료되지 않아 자원을 계속해서 소비 할 수 있다. 최악의 경우, 쓰기 작업이 실패해 처음부터 다시 데이터 처리를 재실행 해야 할 수 있다. 그래서, 데이터 플로우는 CSV 파일과 같이 취합하기 쉬운 형식으로 분산 스토리지에 넣는 것 까지한다. 외부 시스템에 데이터를 전송하는 것은 워크 플로우의 역할이다. 벌크 형 전송 도구를 사용해 태스크를 구현하거나 외부 시스템쪽에 파일을 읽어들이도록 지시한다. 데이터 플로우와 SQL 을 나누어 사용하기 SQL을 MPP 데이터베이스에서 실행 데이터웨어하우스의 파이프라인 로드되는 데이터를 만드는 부분까지가 데이터 플로의 역할 SQL을 분산 시스템 상의 쿼리 엔진에서 실행 데이터마트의 파이프라인 구조화된 데이터를 만드는 부분까지가 데이터플로우의 역할 3. 스트리밍 형 데이터 플로우배치 처리와 스트림 처리 배치 처리 도달한 데이터를 우선 분산 스토리지에 보관한다. 데이터가 영속적으로 보관되기 때문에 몇 번이고 재실행 가능하다. 집계 효율이 높은 열 지향 스토리지를 구축할 수 있다. 실행 시에 데이터 양이 정해지기 때문에 유한 데이터 (bounded data) 스트림 처리 데이터 도달과 동시에 처리가 시작된다. 재실행하는 것은 고려하지 않는다. 처리한 결과는 시계열 데이터에 적합한 데이터 스토어에 보관하거나 실시간 시스템에 전송한다. 제한 없이 데이터가 보내지기 때문에 무한 데이터 (unbounded data) ex) Spark Streaming 스트림 처리에 의한 1차 집계 분산 스토리지에도 성능 상이나 비용 상의 한계가 있다. 데이터 양이 많아 한계를 넘어서면, 스트림 처리를 사용해 흐름량을 줄일 수 있다. 스트림 처리의 두 가지 문제에 대한 대처스트림 처리의 문제 두 가지가 있다. 틀린 결과를 어떻게 수정할 것인가 새롭게 도달한 데이터만 처리한다. 늦게 전송된 데이터 취급을 어떻게 할 것인가 집계가 종료된 후에 도착한 데이터가 있어서, 스트림 처리의 결과가 부정확해질 수 있다. 이 문제 해결을 위해, 스트림 처리와 별개로 배치 처리를 실행시켜 배치 처리의 결과가 옳다고 할 수 있다. 예를 들어, 일별 보고서를 속보 값으로 하고 월별 보고서를 확정값으로 분류하는 것이다. 이를 발전 시킨 방법이 람다 아키텍쳐, 람다 아키텍쳐를 단순화한 카파 아키텍쳐가 있다. 람다 세 레이어로 구성된다. 배치 레이어 모든 데이터는 배치 레이어에서 처리한다. 대규모 배치 처리를 위해 실행하며 1회 처리가 오래 걸린다. 서빙 레이어 배치 처리 결과는 서빙 레이어를 통해 접근한다. 응답이 빠른 데이터베이스를 설치해서 집계 결과를 바로 추출한다. 서빙 레이어에서 얻어진 결과를 배치 뷰 라고 한다. 정기적으로 업데이트 되지만 실시간 정보는 얻을 수 없다. 스피드 레이어 스피드 레이어에서 얻은 결과를 실시간 뷰라고 한다. 배치 뷰가 업데이트 될 동안에만 이용되고 오래된 데이터를 순서대로 삭제된다. 배치뷰와 실시간 뷰를 조합시키는 형태로 쿼리를 실행한다. 최근 24시간 집계 결과는 실시간 뷰를 참고하고 그 이전 데이터는 배치뷰를 이용할 수 있다. 실시간 뷰의 결과는 나중에 배치 뷰로 치환된다. 그래서 스트림 처리가 정확하지 않아도 길게 보면 문제가 없다. 카파 람다 아키텍쳐는 스피드 레이어와 배치 레이어가 모두 같은 처리를 구현하고 있으므로 번거롭다. 그래서, 카파 아키테쳐는 스피드 레이어만 남긴다. 대신, 메세지 브로커의 데이터 보관 기한을 길게하여 문제 발생시 메세지 배송 시간을 과거로 다시 설정한다. 그러면 과거의 데이터가 다시 스트림 처리로 흘러 들어 실질적으로 재실행이 이루어진다. 문제점은, 부하가 높아진다는 것이다. 대량의 과거 데이터를 흘려보내면 평상시와 비교해 몇 배의 자원을 소비하기 때문이다. 클라우드 서비스 보급에 그런 자원을 확보하는 것이 어렵지 않으므로 필요에 따라 스트림 처리를 다시 하는것이 간단하는 것이 카파 아키텍쳐의 주장이다. Out of Order 의 데이터 처리 스트림 처리를 할때 늦게 도달한 메세지, 즉 프로세스 시간과 이벤트 시간의 차이는, 이벤트 시간 윈도윙으로 해결한다. 즉, 이벤트 시간에 의해 윈도우를 나누는 것이다. 메세지가 배송된 데이터는 무작위 순이기 때문에 적절히 순서를 바꿔 집계 결과를 업데이트해야한다. 데이터가 도달할 때마다 해당하는 윈도우를 재집계한다. 데이터를 무한히 계속 보관할 수 없으므로 일정 이상 늦게 온 데이터는 무시한다. 빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;","link":"/2020/01/05/big-data-chapter5/"},{"title":"[오브젝트] 12장_다형성","text":"상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축 하는 것이다. 상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 정리한다. 01 다형성다형성(Polymorphism) 은 다음 둘의 합성어이다. 즉, 많은 형태를 가질 수 있는 능력이다. ploy : 많은 morph : 형태 다형성은 다음과 같이 분류될 수 있다. 이번장은 포함 다형성에 대해 다룬다. 유니버셜 다형성 매개변수 다형성 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식. ex) List 인터페이스는 컬렉션에 보관할 요소의 타입을 임의의 타입 T로 지정하고 있으며 실제 인스턴스를 생성하는 시점에 T 를 구체적인 타입으로 지정 포함 다형성 (서브타입 다형성) 메세지가 동일해도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력. 임시 다형성 오버로딩 다형성 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우. 강제 다형성 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할수 있는 방식. ex) 이항 연산자인 ‘+’ 는 피연산자가 하나는 정수형이고 다른 하나는 문자열인 경우, 정수형 피연산자는 문자열 타입으로 강제 형변환 02 상속의 양면성 데이터 관점의 상속 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함한다. 행동 관점의 상속 데이터뿐만 아니라 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함한다. 외부의 객체가 부모 클래스의 인스턴스에 전송할 수 있는 모든 메세지는 자식 클래스의 인스턴스에도 전송할 수 있다. 상속을 사용한 강의 평가code : 394 p 메서드 오버라이딩 자식 클래스 안에 상속 받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것이다. 메서드 오버로딩 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것이다. 03 업캐스팅과 동적 바인딩같은 메세지, 다른 메서드12345Professor professor01 = new Professor(&quot;다익스트라&quot;, new Lecture(...))Professor professor02 = new Professor(&quot;다익스트라&quot;, new GradeLecture(...)) professor01.compileStatistics();professor02.compileStatistics(); 12345public String compileStatistics() { ... lecture.evalulate(); ...} 동일한 객체 참조인 lecture 에 대해 동일한 evaluate 메세지를 전송하는 동일한 코드 안에서, 서로 다른 클래스 안에 구현된 메서드를 실행할 수 있다. 이처럼, 코드 안에서 선언된 참조 타입과 무관하게 실제로 메세지를 수신한 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은 다음 두 메커니즘이 작용하기 때문이다. 업캐스팅 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능 동적 바인딩 메세지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행시점에 결정 업캐스팅 업캐스팅의 대표적인 두 가지이다. 대입문 명시적으로 타입을 변환하지 않고도 부모 클래스의 타입의 참조변수에 자식 클래스의 인스턴스를 대입할 수 있다. 1Lecture lecture = new GradeLecture(...); 메서드 파라미터 부모 클래스의 타입으로 선언된 파라미터에 자식 클래스의 인스턴스를 전달할 수 잇다. 1234567public class Professor { public Professor(String name, Lecture lecture){ ... }}Professor professor = new Professor(&quot;다익스트라&quot;, new GradeLecture(...)); 다운 캐스팅은, 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해 명시적인 타입 캐스팅이 필요하다. 12Lecture lecture = new GradeLecture(...);GradeLecture gradeLecture = (GradeLecture) lecture; 동적 바인딩 정적 바인딩 컴파일 타임에 호출할 함수를 결정하는 방식 동적 바인딩 실행될 메서드를 런타임에 결정하는 방식. 실행 시점에 어떤 클래스의 인스턴스를 생성해서 전달하는지 알아야만 실제로 실행될 메서드를 알 수 있다. 04 동적 메서드 탐색과 다형성객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다. 메세지를 수신한 객체는 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다. 존재하면 메서드를 실행하고 탐색을 종료한다. 존재하지 않으면, 부모 클래스에서 메서드 탐색을 계속한다. 적합한 메서드를 찾을 때 까지 상속 계층을 따라 올라가며 계속된다. 상속 계층의 최상위 클르스에 올라갔지만 메서드를 발견하지 못하면 예외를 발생시키며 탐색을 종료한다. 여기서 중요한 것이 sefl 참조 변수이다. 객체가 메세지를 수신하면, 컴파일러는 self 참조라는 임시 변수를 자동으로 생성해 메세지를 수신한 객체를 가리키도록 한다. 위 그림에서, GradeLecture 클래스에서 적절한 메서드를 찾지 못했다면 parent 참조를 따라 부모 클래스인 Lecture 클래스로 이동한후 탐색을 계속한다. 상속 계층을 따라 최상위 클래스인 Object 클래스에 이를 때 까지 탐색을 계속한다. 최상위 클래스에서도 메서드를 찾지 못하면 에러를 발생시킨다. 동적 메서드 탐색은 두 원리로 구성된다. 자동적인 메세지 위임 자식 클래스는 이해할 수 없는 메세지를 전송 받으면 상속 계층을 따라 부모 클래스에 처리를 위임한다. 동적인 문맥 메세지를 수신했을 때, 실제로 어떤 메서드가 실행될지 결정하는 것은 컴파일 시점이 아니라 실행시점에 이뤄진다. 자동적인 메세지 위임 메서드 오버라이딩 : 자식 클래스의 메서드가 부모 클래스의 메서드를 감추게 된다. 12Lecture lecture = new Lecture(...);lecture.evaluate(); 위 그림과 위 코드에서, 메서드 탐색은 self 참조가 가리키는 객체의 클래스인 Lecuture 에서 시작한다. Lecture 클래스 안에 evaluate 메서드가 존재하기 때문에, 메서드 실행한 후 탐색은 종료한다. 12Lecture lecture = new GradeLecture(...);lecture.evaluate(); 위 그림과 위 코드에서, Lecture 에 정의된 메서드가 아닌 실제 객체를 생성항 클래스인 GradeLecture 에 정의된 메서드가 실행된다. self 참조가 가리키는 객체의 클래스인 GradeLecture 에서 탐색을 시작하고 GradeLecture 클래스 안에 evaluate 메서드가 구현되어 있기 때문이다. 메서드 오버로딩 : 자식 클래스의 메서드와 부모 클래스의 메서드가 공존한다. 12Lecture lecture = new GradeLecture(...);lecture.average(); 위 그림과 위 코드에서, GradeLecture 클래스 안에서 메세지에 응답할 수 있는 적절한 메서드를 찾지 못한다. 그래서, 부모 클래스인 Lecture 클래스에서 메서드를 찾으려고 시도한다. 동적인 문맥메세지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다. 이 동적인 문맥을 결정하는 것이 메세지를 수신한 객체를 가리키는 self 참조이다. self 참조 가 동적 문맥을 결정한다는 것은, 종종 어떤 메서드가 실행될지 예상하기 어렵게 만든다. 대표적인 경우가 self 전송이다. self 전송은 자식 클래스에서 부모 클래스 방향으로 진행되는 동적 메서드 탐색 경로를 다시 self 참조가 가리키는 원래의 자식 클래스로 이동시킨다. 다음을 보자. 12345678910111213141516public class Lecture { public String stats(){ return getEvaluationMethod(); } private String getEvaluationMethod() { return &quot;Pass or Fail&quot;; }}public class GradeLecture extends Lecture { @Override public String getEvaluationMethod() { return &quot;Grade&quot;; }} GradeLecture 에 stats 메시지를 전송하면, 다음 그림과 같다. self 참조는 GradeLecture 인스턴스를 가리키도록 설정되고 탐색은 GradeLecture 부터 시작. GradeLecture 클래스에는 stats 메세지를 처리할 메서드가 없기 때문에 부모 클래스인 Lecture 에서 메서드 탐색을 계속속 하다가, Lecture 에서 stats 메서드를 발견하고 실행 실행 중에, self 참조가 가리키는 getEvaluationMethod 메세지를 전송하는 구문과 마주침 메서드 탐색은 self 참조가 가리키는 객체에서 다시 시작 이해할 수 없는 메세지이해할 수 없는 메세지 처리는 두 타입 언어에 따라 다르다. 정적 타입 언어 코드를 컴파일 할 때 상속 계층 안의 클래스들이 메세지를 이해할 수 있는지 여부를 판단한다. 상속 계층 전체를 탐색한 후에도 메시지를 처리할 메서드를 발견하지 못하면 컴파일 에러가 발생한다. (안정적이다) 동적 타입 언어 실제로 코드 실행 전에는 메시지 처리 가능 여부를 판단 할 수 없다. 하지만, 이해할 수 없는 메세지에 대해 예외를던 는 것 외에도 doesNotUnderstand 나 method_missing 메시제에 응답 할 수 있는 메서드를 구현할 수 있다. (유연하다) self 대 super super.average() 에 의해 호출되는 메서드는 부모 클래스의 메서드가 아니라, 더 상위에 위치한 조상 클래스의 메서드일 수 있다. self 전송 메세지를 수신한 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정 super 전송 항상 메세지를 전송하는 클래스의 부모 클래스에서부터 시작 5. 상속 대 위임 GradeLecture 인스턴스 입장에서 self 참조는, GradeLecture 인스턴스 자신이다. GradeLecture 인스턴스에 포함된 Lecture 입장에서 self 참조는, GradeLecture 인스턴스이다. self 참조는 항상 메세지를 수신한 객체를 가리키기 때문이다. 즉, 상속 계층을 구성하는 객체들 사이에서는 self 참조를 공유하기 때문에 개념적으로 각 인스턴스에서 self 참조를 공유하는 self 변수를 포함하는 것처럼 표현할 수 있다. 상속은 동적으로 메서드를 탐샘하기 위해 현재의 실행문맥을 가지고 있는 self 참조를 전달한다. 그리고 이 객체들 사이에서는 메시지를 전달하는 과정이 자동으로 이뤄진다. 그래서, 자동적인 메세지 위임이라고 한다. 오브젝트 &lt;조영호&gt;","link":"/2020/01/06/object-chapter12/"},{"title":"[오브젝트] 13장_서브클래싱과 서브타이핑","text":"상속의 두가지 용도는 다음과 같다. 타입 계층 구현 동일한 메세지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야한다. 코드 재사용 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 된다. 01 타입타입을 세 가지 관점으로 정리하자. 개념 관점의 타입 타입 우리가 인지하는 세상의 사물의 종류를 의미한다. 자바, 루비, C 를 프로그래밍 언어로가 부를 때, 이것들을 프로그래밍 언어라는 타입으로 분류하고 있는 것이다. 인스턴스 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 한다. 자바, 루비, C 는 프로그래밍 언어의 인스턴스이다. 프로그래밍 언어 관점의 타입하드웨어는 데이터를 0과 1로 구성된 일련의 비트 조합으로 취급한다. 프로그래밍 언어 관점의 타입은, 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 의미한다. 타입은 두가지 목적으로 사용된다. 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다. 자바의 ‘+’ 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없다. 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다. 자바에서 a + b 라는 연산이 있을 때 a, b 의 타입이 int 라면 두 수를 더한다. a, b 의 타입이 String 이면 두 문자열을 하나의 문자열로 합친다. 객체 지향 패러다임 관점의 타입프로그래밍 언어 관점에서 타입은 호출 가능한 오퍼레이션의 집합이다. 객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메세지이다. 객체지향 프로그래밍에서 타입을 정의하는 것은 객체가 수신할 수 있는 객체의 퍼블릭 인터페이스를 정의하는 것이다. 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다. 02 타입 계층타입 사이의 포함관계타입 계층을 구성하는 두 타입 간의 관계에서, 슈퍼타입 더 일반적인 타입 서브타입 더 특수한 타입 객체지향 프로그래밍과 타입 계층핵심은, 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주 될 수 있다는 것이다. 퍼블릭 인터페이스의 관점에서, 슈퍼타입 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것 서브타입 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것 3 서브클래싱과 서브타이핑언제 상속을 사용해야 하는가 ?다음 주 질문의 답이 ‘예’ 이면 상속을 사용해라. 상속 관계가 is-a 관계를 모델링 하는가 ? 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 되는가 ? (행동 호환성) is-a 관계타입 S 가 타입 T 의 일종이라면 “타입 S 는 타입 T 다” 하지만 is-a 관계가 생각처럼 직관적이고 명쾌한 것은 아니다. 다음 예를 보자. 팽귄은 새다. 새는 날 수 있다. 이를 코드로 옮기면 다음과 같다. 12345678910public class Bird { public void fly() { ... }}public class Penguin extends Bird { ...} 그런데, 팽귄은 새는 맞지만 날 수 없다. 위 코드에서는, 팽귄은 새이고 날 수 있다는 것을 주장한다. 이 예는, 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야한다는 사실을 보여준다. 즉,어떤 두 대상을 언어적으로 is-a 라고 표현할 수 있어도 일단은 상속을 사용할 예비 후보 정도로 생각해야한다. 행동 호환성두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다. 중요한 것은, 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이다. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대하면 두 타입을 타입 계층으로 묶을 수 있다. Penguin 이 Bird 의 서브 타입이 아닌 이유는, 클라이언트 입장에서 모든 새가 날 수 있다고 가정하기 때문이다. 다음과 같이 클라이언트가 날 수 있는 새만을 원한다고 해보자. 123public void flyBird(Bird bird){ bird.fly(); // 인자로 전달된 모든 bird 는 날 수 있어야한다.} Penguin 은 날 수 없고 클라이언트 입장에서 모든 bird 가 날 수 있기를 기대하기 때문에 flyBird 의 메서드로 전달되어서는 안된다. 상속 관계를 유지하면서 문제를 해결하기 위해 시도할 수 있는 세가지 방법이 있다. Penguin 이 fly 메서드를 오버라이딩해서 내부 구현을 비워두는 것이다. 123456public class Penguin extends Bird { @Override public void fly() { }} 하지만, 이 방법은 어떤 행동도 수행하지 않기 때문에 모든 bird 가 날 수 있다는 클라이언트의 기대를 만족하지 않는다. Penguin 의 fly 메서드를 오버라이딩한 후 예외를 던지는 것이다. 123456public class Penguin extends Bird { @Override public void fly() { throw new UnsupportedOperationException(); }} flyBird 메서드는 모든 bird 가 날 수 있다고 가정한다. flyBird 메서드 fly 메시지를 전송한 결과로 UnsupportedOperationException 예외가 던져질 것이라고 기대하지 않을 것이다. flyBird 메서드를 수정해서 인자로 전달된 bird 타입이 팽귄이 아닐 경우에만 fly 메세지를 전송하는 것이다. 12345public void flyBird(Bird bird){ if (!(bird instanceof Penguin)){ bird.fly(); }} 만약 팽귄이 이외에 날 수 없는 또 다른 새가 상속 계층에 추가되면, flyBird 메서드 안에 새로운 타입을 체크하는 코드가 추가된다. 이것은 구체적인 클래스에 대한 결합도를 높여, 개방-폐쇄 원칙을 위반한다. 클라이언트의 기대에 따라 계층 분리하기문제 해결을 위해서는, 위 세가지 방법 말고 클라이언트의 기대에 따라 계층을 분리해야한다. 날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 서로 다른 요구사항을 가진 클라이언트를 만족 시킬 수 있다. 12345678910111213public class Bird { ... }public class FlyingBird extends Bird{ public void fly(){ ... }}public class Penguin extends Bird { ...} 123public void flyBird(FlyingBird bird){ bird.fly();} 또 다른 방법으로는, 다음 그림과 같이 클라이언트에 따라 인터페이스를 분리하는 것이다. 더 좋은 방법은, 합성을 사용하는 것이다. 설계가 꼭 현실 세계를 반영할 필요는 없다. 자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중해라. 서브클래싱과 서브타이핑상속을 사용하는 목적에 따라 다음과 같이 나눌 수 있다. 서브클래싱 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우이다. 구현상속, 클래스 상속이라고도 부른다. 왜냐하면, 내부 구현 자체를 상속하는 것에 초점을 맞추기 때문이다. 서브타이핑 타입 계층을 구성하기 위해 상속을 사용하는 것이다. 인터페이스 상속이라고도 부른다. 왜냐하면, 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속하는 것 처럼 보이기 때문이다. 04 리스코프 치환 법칙리스코프 치환 법칙이란, 클라이언트가 차이점을 인식하지 못한 채 파생 클래스의 인터페이스를 통해 서브 클래스를 사용할 수 있어야한다는 것이다. 10장의 Stack 과 Vector 는 리스코프 치환 법칙을 위반하는 전형적인 예이다. 클라이언트가 부모 클래스인 Vector 에 대해 기대하는 행동을 Stack 에 대해서는 기대할 수 없기 때문에 행동 호환성을 만족하지 못하기 때문이다. 다른 예로, “직사각형은 사격형이다 “ 가 있다. 하지만, 직사각형은 사각형이 아닐 수 있다. 다음은 사각형이다. 123456789101112131415161718192021222324252627282930public class Rectangle { private int x, y, width, height; public Rectangle(int x, int y, int width, int height) { this.x = x; this.y = y; this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getArea() { return width * height; }} 다음은 정사각형이다. 123456789101112131415161718public class Square extends Rectangle{ public Square(int x, int y, int size) { super(x, y, size, size); } @Override public void setWidth(int width) { super.setWidth(width); super.setHeight(width); } @Override public void setHeight(int height) { super.setWidth(height); super.setHeight(height); }} 문제는 다음과 같이, Rectangle 과 협력하는 클라이언트는 사각형의 너비와 높이가 다르다고 가정한다. 12345public void resize(Rectangle rectangle, int width, int height){ rectangle.setWidth(width); rectangle.setHeight(height); assert rectangle.getWidth() == width &amp;&amp; rectangle.getHeight() == height;} 다음과 같이, 위 코드에서 resize 메서드 인자로 Rectangle 대신, Square 를 전달한다고 해보자. 12Square square = new Square(10,10,10);resize(square, 50, 100); 메서드의 실행이 실패하고 만다. 중요한 것은, 클라이언트 입장에서 행동이 호환되는지의 여부이다. 행동이 호환될 경우, 자신 클래스가 부모 클래스 대신 사용될 수 있다. 클라이언트와 대체 가능성Square 가 Rectangle 을 대체할 수 없는 이유는, 클라이언트 관점에서 Square와 Rectangle 이 다르기 때문이다. 대체 가능성을 결정하는 것은 클라이언트이다. is-a 관계 다시 살펴보기상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계이다. 서브 클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계가 아니다. 리스코프 치환 원칙은 유연한 설계의 기반이다.클라이언트 입장에서, 퍼블릭 인터페이스의 행동방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있다. 8장에서 중복 할인 정책을 구현하기 위해 기존의 DiscountPolicy 상속 계층에 새로운 자식 클래스인 OverlappedDiscountPolicy 를 추가하더라도 클라이언트를 수정할 필요가 없었다. 위 설계는 다음 원칙을 조합한 유연할 설계이다. 의존성 역전 원칙 상위 수준 모듈인 Movie 와 하위 수준 모듈인 OverlappedDiscountPolicy 모두 추상 클래스인 DiscountPolicy 에 의존한다. 리스코프 치환 원칙 OverlappedDiscountPolicy 는 클라이언트에 대한 영향 없이도 DiscountPolicy 를 대체할 수 있다. 개방-폐쇄 원칙 중복할인이라는 새로운 기능을 추가하기 위해 OverlappedDiscountPolicy 를 추가하더라도, Movie 에는 영향이 없다. 5. 계약에 의한 설계와 서브타이핑‘계약에 의한 설계’ 란, 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것이다. 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는, 클라이언트와 슈퍼타입 간에 체결된 ‘계약’ 을 준수해야한다. 즉, 서브타입이 슈퍼타입처럼 보일 수 있는 유일한 방법은, 클라이언트가 슈퍼타입과 맺은 계약을 서브 타입이 준수하는 것이다. 오브젝트 &lt;조영호&gt;","link":"/2020/01/13/object-chapter13/"},{"title":"[오브젝트] 14장_일관성 있는 협력","text":"01 핸드폰 과금 시스템 변경하기 기본 정책 확장 고정 요금 방식 ex ) 10초당 18원 시간대별 방식 ex ) 00시-19시 : 10초당 19월, 19시-24시 : 10초당 15원 요일별 방식 ex ) 평일 : 10초당 38원, 공휴일 : 10초당 19원 구간별 방식 ex) 초기 1분 : 10초당 50원, 초기 1분 이후 : 10초당 20원 고정 요금 방식 구현하기1234567891011121314public class FixedFeePolicy extends BasicRatePolicy { private Money amount; private Duration duration; public FixedFeePolicy(Money amount, Duration duration) { this.amount = amount; this.duration = duration; } @Override protected Money calculateCallFee(Call call) { return amount.times(call.getDuration().getSeconds() / seconds.getSeconds()); }} 시간대별 방식 구현하기TimeOfDayDiscountPolicy 클래스에서 가장 중요한 것은, 시간에 따라 서로 다른 요금 규칙을 정의하는 방법을 결정하는 것이다. 이를 위해 서로 다른 List 를 가질 수 있다. 같은 규칙에 포함된 요소들은 List 의 동일한 인덱스에 위치한다. 12345678910111213public class TimeOfDayDiscountPolicy extends BasicRatePolicy { private List&lt;LocalTime&gt; starts = new ArrayList&lt;&gt;(); private List&lt;LocalTime&gt; ends = new ArrayList&lt;&gt;(); private List&lt;LocalTime&gt; duration = new ArrayList&lt;&gt;(); private List&lt;Money&gt; amounts = new ArrayList&lt;&gt;(); @Override protected Money calculateCallFee(Call call) { ... } ...} 요일별 방식 구현하기시간대별 방식의 4개 List 와 다르게, 규칙을 DayOfWeekDiscountRule 이라는 하나의 클래스로 구현해보자. 123456789101112131415161718public class DayOfWeekDiscountRule { private List&lt;DayOfWeek&gt; dayOfWeeks = new ArrayList&lt;&gt;(); private Duration duration = Duration.ZERO; private Money amount = Money.ZERO; public DayOfDiscountRule(List&lt;DayOfWeek&gt; dayOfWeeks, Duration duration, Money amount) { this.dayOfWeeks = dayOfWeeks; this.duration = duration; this.amount = amount; } public Money caculate(DateTimeInterval interval){ if(dayOfWeeks.contains(interval.getFrom().getDayOfWeek())){ return ... } ... }} 123456789101112public class DayOfWeekDiscountPolicy extends BasicRatePolicy { private List&lt;DayOfWeekDiscountRule&gt; rules = new ArrayList&lt;(); public DayOfWeekDiscountPolicy(List&lt;DayOfWeekDiscountPolicy&gt; rules) { this.rules = rules; } @Override protected Money calculateCallFee(Call call) { ... } } 구간별 방식 구현하기(구간별 방식 구현 코드는 생략) 지금까지의 구현의 가장 큰 문제는, 이 클래스들이 유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다는 것이다. 02 설계에 일관성 부여하기협력을 일관성 있게 만들기 위해서는, 변하는 개념을 변하지 않는 개념으로 분리하라. 변하는 개념을 캡슐하하라. 조건 로직 객체 탐색4장의 절차적인 방식으로 구현했던 ReservationAgency 코드를 보자. 1234567891011121314151617181920212223public class ReservationAgency { public Reservation reservation(Screening screening, Customer customer, int audienceCount){ for(DiscountCondition condition : movie.getDiscountConditions(){ if(condition.getType() == DiscountCondition.PERIOD){ //기간조건 }else { //회차 조건 } } if(discountable){ switch (movie.getMovieType()){ case AMOUNT_DISCOUNT: //금액할인 정책 case PERCENT_DISCOUNT: // 비율 할인 정책 ... } } else{ ... } }} 객체지향에서는, 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것이다. 1234567public class Movie { private DiscountPolicy discountPolicy; public Money calculateMovieFee(Screening screening){ return fee.minus(discountPolicy.calculateDiscountAmount(screening)); }} 12345678910111213public abstract class DiscountPolicy { private List&lt;DiscountCondition&gt; conditions = new ArrayList&lt;&gt;(); public Money calculateDiscountAmount(Screening screening){ for(DiscountCondition each : conditions){ if(each.isSatisfiedBy(screening)){ return getDiscountAmount(screening); } } return screening.getMovieFee(); }} 객체지향적인 코드는 조건을 판단하지 않는다. 단지 다음 객체로 이동할 뿐이다. Movie 는 현재의 할인 정책이 어떤 종류인지 판단하지 않는다. 단지 DiscountPolicy 로 향하는 참조를 통해 메세지를 전달할 뿐이다. DiscountPolicy 역시 할인 조건의 종류를 판단하지 않는다. 단지 DiscountCondition 으로 향하는 참조를 통해 메세지를 전단할 뿐이다. 협력을 일관성 있게 만들기 위한 방법을 다시 정리하면, 변하는 개념을 변하지 않는 개념으로 분리하라. 각 조건문을 개별적인 객체로 분리했고 이 객체들을 일관성 있게 협력하기 위해 타입 계층을 구성했다. 변하는 개념을 캡슐하하라. Movie 가 알고 있는 사실은 협력하는 객체가 단지 DiscountPolicy 클래스의 인터페이스에 정의된 calculateDiscountAmount 메세지를 이해할 수 있다는 것 뿐이다. 메세지 수신자 타입은 Movie 에 대해 완벽히 캡슐화되었다. 캡슐화 다시 살펴보기캡슐화란 변하는 어떤 것이든 감추는 것이다. 다음 그림에는 다양한 종류의 캡슐화가 공존한다. 데이터 캡슐화 클래스는 내부에 관리하는 데이터를 캡슐화한다. 메서드 캡슐화 DiscountPolicy 클래스에 정의된 getDiscountAmount 메서드의 가시성은 protected 이다. 즉, 클래스의 외부에서는 이 메서드에 접근하지 못하고 클래스 내부와 서브 클래스에서만 접근이 가능하다. 객체 캡슐화 Movie 클래스는 DiscountPolicy 타입의 인스턴스 변수를 포함한다. 이 인스턴스 변수는 private 가시성을 가지므로 Movie 와 DiscountPolicy 사이의 관계를 변경해도 외부에는 영향을 미치지 않는다. 즉, 합성이다. 서브타입 캡슐화 Movie 는 DiscountPolicy 에 대해서 알고 있지만, AmountDiscountPolicy 에 대해서는 모른다. 그러나 실행 시점에 협력할 수 있다. 서트타입의 종류를 캡슐화하고 있기 때문에, 다형성의 기반이 된다. 3 일관성 있는 기본 정책 구현하기전체 설계는 다음과 같다. 변경 분리하기시간대별, 요일별, 구간별 방식의 공통점은 각 기본 정책을 구성하는 방식이 유사하는 것이다. 기본 정책은 한 개 이상의 규칙으로 구성된다. 하나의 규칙은 적용 조건과 단위요금을 조합이다. 모든 규칙에 적용 조건이 포함된다는 사실은 변하지 않지만 실제 조건의 세부 내용은 다르다. 즉, 조건의 세부 내용이 바로 변화에 해당하는 것이다. 변하지 않는 ‘규칙’ 으로부터 변하는 ‘적용 조건’ 을 분리해야한다. 변경 캡슐화하기 변하는 FeeCondition 의 서브 타입은 변하지 않는 FeeRule 로부터 캡슐화된다. 협력 패턴 설계하기 BasicRatePolicy 의 calculateFee 메서드는 인자로 전달받은 통화 목록의 전체 요금을 계산한다. BasicRatePolicy 는 목록에 포함된 각 Call 별로 FeeRule 의 calculateFee 메서드를 실행한다. 하나의 BasicRatePolicy 는 하나 이상의 FeeRule 로 구성되어서, Call 하나당 FeeRule 에 다수의 calculateFee 메세지가 전송된다. 추상화 수준에서 협력 패턴 구현하기변하지 않는 요소와 추상적인 요소만으로 요금 계산에 필요한 전체적인 협력 구조를 설명할 수 있다. 구체적인 협력 구현하기code : 505 Page 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성을 유지할 수 있는 방법이다. 개념적 무결성이란, 일관성이다. 오브젝트 &lt;조영호&gt;","link":"/2020/01/20/object-chapter14/"},{"title":"[카프카] 8장_카프카 스트림즈 API","text":"카프카 스트림즈 API 를 통해 스트림을 처리하는 방법을 정리한다. 기본 개념스트림 프로세싱과 배치 프로세싱오늘날 데이터 분석 시스템은 스트림 처리 시스템과 배치 처리 시스템을 모두 갖추어서 실시간과 정확성을 보장한다. 스트림 프로세싱데이터들이 지속적으로 유입되고 나가는 과정에서 데이터에 대한 분석이나 질의를 수행하는 것이다.데이터가 분석 시스템이나 프로그램에 도달하자마자 처리를 해서 실시간 분석이라고도 한다. 배치 처리이미 저장된 데이터를 기반으로 분석이나 질의를 수행하고 특정 시간에 처리하는 것이다. 스티름 프로세싱의 장점은, 이벤트 발생, 분석, 조치에 지연시간이 없기 때문에, 최신의 데이터를 반영한다. 데이터 저장 후 분석을 하지 않으므로, 정적 분석보다 더 많은 데이터를 분석할 수 있다. 시간에 따라 지속적으로 유입되는 데이터 분석에 최적화되어 있다. 대규모 공유 데이터베이스에 대한 요구를 줄일 수 있어 인프라에 독립적으로 수행될 수 있다. 상태 기반 스트림 처리, 무상태 스트림 처리 상태 기반 스트림 처리이전 스트림을 처리한 결과를 참조하는 방식의 처리이다.애플리케이션에서 각각의 이벤트를 처리하고 결과를 저장할 상태 저장소가 필요하다. 무상태 스트림 처리이전 스트림의 처리 결과와 관계 없이, 현재 애플리케이션에 도달한 스트림만을 기준으로 처리한다. 카프카 스트림즈의 특징과 개념카프카 스트림즈는 카프카에 저장된 데이터를 처리하고 분석하기 위해 개발된 클라이언트 라이브러리이다.카프카 스트림즈의 특징은, 간단하고 가벼운 클라이언트 라이브러리이다. 시스템이나 카프카에 대한 의존성이 없다. 이중화된 로컬 상태 저장소를 지원한다. 카프카 브로커나 클라이언트에 장애가 생겨도, 스트림에 대해선 한 번만 처리되도록 보장한다. 한 번에 한 레코드만 처리한다. 고수준의 스트림 DSL 를 지원하고, 저수준의 프로세싱 API 도 제공한다. 카프카 스트림즈는 스트림 처리를 하는 프로세서들이 서로 연결되어 항상 Topology 를 만들어 처리하는 API 이다. 다음 그림은 카프카 스트림즈 프로세스 토폴리지의 예이다. 프로세서 토폴리지 중에는 특별한 프로세서가 있다. 소스 프로세서위 쪽에 연결된 프로세서가 없는 프로세서이다.하나 이상의 카프카 토픽에서 데이터 레코드를 읽어 아래 쪽 프로세서에 전달한다. 싱크 프로세서아래 쪽에 연결된 프로세서가 없는 프로세서이다.상위 프로세서로부터 받은 데이터 레코드를 특정 토픽에 저장한다. 카프카 스트림즈는 이와 같은 프로세서들을 만드는 2 가지 방법을 제공한다. 카프카 스트림즈 DSL 에서 데이터 처리를 할 때 공통적으로 필요한 데이터 프로세싱 메서드를 제공ex) map, filter, join, aggregations 프로세서 API 를 제공해서 저수준의 처리를 직접할 수 있게 하는 것이다. 카프카 스트림즈 아키텍처카프카 스트림즈에 들어오는 데이터는 카프카 토픽의 메세지이다.카프카 토픽과 스트림의 관계는, 각 스트림 파티션은 카프카의 토픽 파티션에 저장된 졍렬된 메세지이다. 스트림의 데이터 레코드는 카프카 해당 토픽의 메세지이다. 데이터 레코드의 키를 통해 다음 스트림으로 전달된다. 카프카 스트림즈는 입력 스트림의 파티션 개수만큼 태스크를 생성한다.각 태스크에는 입력 스트림, 즉 카프카 토픽 파티션들이 할당된다.이것은 한번 정해지면 입력 토픽의 파티션이 변하지 않는한 변하지 않는다.카프카 스트림즈는 사용자가 스레드의 개수를 지정할 수 있게 한다.1개의 스레드는 1개 이상의 테스크를 처리할 수 있다.다음 그림은 1개의 스레드에서 2개의 테스크가 수행되는 모습이다. 카프카, 데이터 플랫폼의 최강자 &lt;고승범, 공용준&gt;","link":"/2020/01/26/kafka-chapter8/"},{"title":"[오브젝트] 15장_디자인 패턴과 프레임워크","text":"디자인 패턴특정한 변경을 일관성있게 다룰 수 있는 협력 텝플릿 제공.설계를 재사용하는 것이 목적. 프레임워크특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿 제공.설계와 코드를 함께 재사용하기 위한 것이 목적. 01 디자인 패턴과 설계 재사용소프트웨어 패턴패턴의 특징은, 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다. 패턴을 사용해서 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있다. 다른 사람과 의사소통 가능. 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워준다. 실질적인 코드 작성을 돕는다. 패턴은 실무에서 탄생했다. 마틴 파울러에 의하면, 패턴은 하나의 실무 컨텍스트에서 유용하게 사용해왔고 다른 실무 컨텍스트엣도 유용할 것이라고 예상되는 아이디어다. 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법 등 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이다. 패턴 분류 디자인 패턴일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다. 아키텍쳐 패턴디자인 패턴의 상위에 있다. 소프트웨어의 전체적인 구조를 결정한다.미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의한다.서트시스템들 사이의 관계를 조직화하고 규칙과 가이드라인을 포함한다. 이디엄디자인 패턴의 하위에 있다. 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴이다.주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트간의 특정 측면을 구현하는 방법을 서술한다.예를 들어, C++ 의 COUNT POINT 이디엄은 자바에서는 유용하지 않다. 분석 패턴도메인 내의 개념적인 문제를 해결하는데 초점을 맞춘다. 패턴과 책임-주도 설계객체지향 설계에서 중요한 일은, 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 것이다. 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다. 예를 들면, STRATEGY 패턴다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임을 제공한다. BRIDGE 패턴추상화의 조합으로 인한 클래스의 폭발적 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해해서 설계를 확장가능하게 한다. OBSERVER 패턴유연한 통지 매커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임을 제공한다. 패턴의 구성 요소는 클래스가 아니라, ‘역할’ 이다.예를 들어, 클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있는 COMPOSITE 패턴을 보자. 패턴의 구성요소인 component, composite, leaf 는 클래스가 아니라 협력에 참여하는 객체들의 역할이다. component는 역할이기 때문에 component 가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 component 의 역할을 수행할 수 있다. 중복 할인 설계의 기본 구조는 COMPOSITE 패턴을 따른다.디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐, 구체적인 구현 방법에 대해서는 제한을 두지 않는다. 캡슐화와 디자인 패턴각 디자인 패턴은 특정한 변경을 캡슐화하기 위해 독자적인 방법을 정의하고 있다. 위 그림은 STRATEGY 패턴을 적용한 영화 예매 시스템 설계이다. 변경을 캡슐화하기 위해 합성을 이용한다. Movie 와 DiscountPolicy 사이의 결합도를 낮춰 런타임에 알고리즘을 변경할 수 있다. 위 그림은 TEMPLATE METHOD 패턴을 적용한 설계이다. 변경을 캡슐화하기 위해 상속을 이용한다. 부모 클래스의 calculateFee 메서드 안에서 추상 메서드를 호출하고 자식 클래스들이 이 메서드를 오버라이딩해서 변하는 부분을 구현하는 것이 중요하다.TEMPLATE METHOD 패턴은 합성 보다는 결합도가 높은 상속을 사용했기 때문에 런타임에 객체의 알고리즘을 변경하는 것이 불가능하다. 하지만, 알고리즘 교체와 같은 요구사항이 없었으면 복잡도를 낮출 수 있다는 장점이 있다. 위 그림은 DECORATOR 패턴을 적용한 설계이다. 객체의 행동을 동적으로 추가할 수 있는 패턴으로서, 객체의 행동을 결합하기 위해 객체 합성을 사용한다. 디자인 패턴에서 중요한 것은, 디자인 패턴의 구현 방법이나 구조가 아니다. 어떤 변경을 캡슐화하는지 이해하고 변경을 캡슐화하기 위해 어떤 방법을 사용하는지 이해해야한다. 패턴은 출발점이다패턴 입문자의 문제는, 패턴을 적용하는 컨텍스트의 적절성을 무시하고 패턴의 구조에만 초점을 맞춘다는 것이다. 패턴을 적용할 때는 설계를 단순하고 명확하게 만들 수 있는 방법이 없는지를 고민해야한다. 그리고, 코드를 공유하는 모든 사람들이 적용된 패턴을 알고 있어야한다. 02 프레임워크와 코드 재사용코드 재사용 대 설계 재사용프레임워크란, 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계이다. 또는, 애플리케이션 개바자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격이다. 상위 정책과 하위 정책으로 패키지 분리하기프레임워크의 핵심은, 추상 클래스나 인터페이스와 같은 추상화이다. 위 그림에서, 추상화는 짙은 색으로 표시되어 있다. 의존성 역전 원칙에 기반하여, 구체 클래스들은 상위 클래스에 의존하지만 추상화들은 구체 클래스에 의존하지 않는다. 상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다. 만약, 상위 정책이 자주 변하는 세부 사항에 의존하면 변경에 대한 파급 효과로 상위 정책이 불안정해진다. 요점은, 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용할 수 있어야한다. 그래서, 상위 정책과 세부 사항 모두 추상화에 의존해야한다. 프레임워크는 여러 애플리케이션에 걸쳐 재사용가능해야하기 때문에, 변하는 것과 변하지 않는 것을 서로 다른 주기로 배포할 수 있도록, 배포 단위를 분리해야한다. 이를 위해, 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리할 수 있다. 중요한 것은, 패키지 사이의 의존성 방향이다. 세부사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야한다. 상위 정책을 구현하고 있는 패키지를 다른 애플리케이션에 재사용할 수 있다. 즉, 재사용 가능한 요금 계산 로직을 구현한 프레임워크가 만들어진 것이다. 제어 역전 원리의존성 역전 원리는, 프레임워크의 가장 기본적인 설계 메커니즘이다. 의존성 역적은, 의존성 방향 뿐만 아니라 제어 흐름의 주체 역시 역전시킨다. 전통적인 구조에서는 상위 정책이 구체적인 세부 사항에 의존한다. 상위 정책의 코드가 하부의 구체적인 코드를 호출한다. 즉, 애플리케이션의 코드가 재사용 가능한 라이브러리나 툴킷의 코드를 호출한다. 하지만, 의존성을 역전 시킨 객치지향 구조에서는 반대로 프레임워크가 에플리케이션에 속하는 서브 클래스들의 메서드를 호출한다. 즉, 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. 이를 제어 역전 원리, 할리우드 원리라고 한다. 할리우드에서 캐스팅 담장자가 배우에게 “먼저 연락하지 마세요. 저희가 연락드릴게요” 라고 말하는 것처럼 프레임워크는 자신을 찾지 말라고 한다. 위 그림에서, 특정한 기본 정책을 구현하는 개발자는 FeeCondition 을 대체할 서브 타입만 개발하면 프레임워크에 정의된 플로우에 따라 요금이 계산된다. 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다. 이렇게 완성되지 않은 채로 남겨진 동작을 hook 이라고 부른다. 오브젝트 &lt;조영호&gt;","link":"/2020/01/27/object-chapter15/"},{"title":"[오브젝트] 부록 A 계약에 의한 설계","text":"인터페이스만으로 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이, 계약에 의한 설계이다.여기서 중요한 것은 코드가 아니라, 개념이다. 01 협력과 계약부수 효과를 명시적으로일반적인 정합성 체크 로직은 코드의 구현 내부에 숨겨져있어 실제로 코드를 분석하지 않는 한 정확하게 파악하기 어렵다. 하지만, Code Contracts 와 같이 계약에 의한 설계를 지원하는 라이브러리나 언어들은 일반 로직과 구분할 수 있도록 제약 조건을 명시적으로 표현하는 것이 가능하다. 02 계약에 의한 설계버트란드 마이어가 제시한 계약은, 사람들 사이의 계약과 유사하다. 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 것이다. 협력에 참여하는 객체는 계약으로부터 이익을 기대하고 이익을 얻기위해 의무를 이행한다. 협력에 참여하는 객체의 이익과 의무는 객체의 인터페이스 상에 문서화된다. 의도를 드러내는 인터페이스는 오퍼레이션의 시그니처만으로 어느 정도 클라이언트와 서버가 협력을 위해 수행해야하는 제약 조건을 명시한다. 계약은 여기서 한 걸음 더 나아간다. 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것으로 기대한다. 클아이언트는 자신이 원하는 값을 서버가 반환할 것이라고 예상한다. 클아이언트는 메세지 전송 전과 후의 서버 상태가 정상일 것이라고 기대한다. 사전 조건메서드가 호출되기 위해 만족되어야하는 조건. 클라이언트의 의무 사후 조건메서드가 실행된 후에 클라이언트에게 보장해야하는 조건. 서버의 의무 불변식항상 참이라고 보장되는 서버의 조건 사전 조건클라이언트가 사전 조건을 만족시키지 못하면, 메서드는 최대한 빨리 실패해서 클라이언트에게 버그가 있다는 사실을 알린다. 사후 조건다음 세 용도로 사용된다. 인스턴스 변수의 상태가 올바른지 서술하기 위해 메스드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해 반환값이 올바른지를 서술하기 위해 불변식객체의 내부 상태와 관련이 있다. 메서드 실행 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요가 없지만, 메서드 실행 전과 종료 후에는 항상 불변식을 만족해야한다. 03 계약에 의한 설계와 서브타이핑리스코프 치환 원칙은, 슈퍼타입의 인스턴스와 협력하는 클라이언트의 관점에서 서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미한다. 따라서 서브타입이 리스코프 치환 원칙을 만족하기 위해서는, 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야한다. 계약 규칙 서브타입에 더 강력한 사전 조건을 정의할 수 없다.계약서에 명시된 의무보다 더 많은 의무를 짊어져야한다는 사실을 납득하는 클라이언트는 없다. 서브타입에 더 완화된 사후 조건을 정의할 수 없다.계약서에 명시된 이익보다 더 적은 이익을 받게 되는 사실을 납득하는 클라이언트는 없다. 슈퍼타입의 불변식은 서브타입에서도 유지되어야 한다.메서드 실행 중에는 불변식을 만족시키지 않아도 되지만, 메서드 실행 전과 후에는 만족해야한다. 가변성 규칙 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.클라이언트는 Bird 의 인스턴스에 fly 메세지를 전송했을 때, UnsupportedOperationException 예외를 기대하지 않는다. 서브타입의 리턴타입은 공변성을 가져야한다.리턴 타입 공변성 : 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 부모 클래스에서 선언한 반환 타입의 서브타입으로 지정할 수 있는 특성 서브타입의 메서드 파라미터는 반공변성을 가져야 한다.파라미터 타입 반공병성 : 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 우 있는 특성 오브젝트 &lt;조영호&gt;","link":"/2020/02/03/object-chapter-appendix-a/"},{"title":"[오브젝트] 부록 B 타입 계층의 구현","text":"타입과 타입 계층을 구현할 수 있는 방법들을 정리하자. 클래스를 이용한 타입 계층 구현타입은 객체의 퍼블릭 인터페이스이다. 클래스는 객체의 타입과 구현을 동시에 정의한 것이다. Phone 클래스가 있다. Phone 의 인스턴스는 calculateFee 메시지를 수신할 수 있는 퍼블릭 메서드를 구현한다. 타입은 퍼블릭 인터페이스이기 때문에, Phone 클래스는 calculateFee 메세지에 응답할 수 있는 타입을 선언한 동시에 객체 구현을 정의한 것이다. 상속은, 퍼블릭 인터페이스는 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 간단한 방법이다. 하지만, 상속은 자식 클래스를 부모 클래스의 구현에 강하게 결합시킨다. 인터페이스를 이용한 타입 계층 구현인터페이스는, 상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약을 해결할 수 있는 방법이다. 추상 클래스를 이용한 타입 계층 구현추상 클래스는, 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법이다. 추상 클래스와 인터페이스 결합하기인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있으면 추상 클래스를 이용해 코드 중복을 방지 할 수 있다. 이것이 골격 구현 추상 클래스이다. 1234567891011121314public interface DiscountPolicy { Money calculateDiscountAmount(Screening screeing);}public abstract class DefaultDiscountPolicy implements DiscountPolicy { ... @Override public Money calculateDiscountAmount(Screening screeing){ ... } abstract protected Money getDiscountAmount(Screeing screening);} 덕 타이핑 사용하기덕 테스트는 어떤 대상의 행동이 오리와 같다면 그것을 오리라는 타입으로 취급해도 무방하다는 것이다. 즉, 객체가 어떤 인터페이스에 정의된 행동을 수행할 수 있다면 그 객체를 해당 타입으로 분류해도 문제가 없다. 자바 같은 대부분의 정적 타입 언어에서는 두 클래스를 동일한 타입으로 취급하기 위해서는, 코드 상의 타입이 동일하게 선언되어 있어야한다. 반면, 런타입에 타입을 결정하는 동적 타입 언어에서는 특정한 클래스를 상속받거나 인터페이스를 구현하지 않고도 객체가 수신할 수 있는 메세지의 지합으로 객체의 타입을 결정할 수 있다. 믹스인과 타입 계층믹스인은, 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브클래스이다. 사용하는 목적은, 다양한 객체의 구현 안에서 동일한 행동을 중복 코드 없이 재사용할 수 있게 만드는 것이다. 즉, 공통의 행동이 믹스인된 객체들은 동일한 메세지를 수신할 수 있는 퍼블릭 인터페이스를 공유하는 것이다. 예를 들어, 스칼라의 trait 로 구현할 수 있다. 스칼라의 trait 와 유사하게, 자바 8에 추가된 default method 는 인터페스에 메서드의 기본 구현을 추가하는 것을 허용한다. 디폴트 메서드가 제공하는 혜택을 누리기 위해서는 한계를 명확히 인식해야한다. 1234567891011121314public interface DiscountPolicy { default Money calculateDiscountAmount(Screening screeing){ for(DiscountCondition each : getConditions()){ if(each.isSatisfiedBy(screeing)){ return getDiscountAmount(screening); } } return screening.getMovieFee(); } List&lt;DiscountCondition&gt; getConditions(); Money getDiscountAmount(Screeing screening);} calculateDiscountAmount 가 내부적으로 두개의 메서드를 사용한다. 그래서 이 인터페이스를 구현하는 모든 클래스들은 해당 메서드의 구현을 제공해야한다는 것을 명시한 것이다. 추상 클래스를 사용했을 경우에는, getDiscountAmount 메서드의 가시성이 protected 였다. 하지만 이제 디폴트 메서드안에서 사용된다는 이유만으로 public 메서드가 되어야한다. 이것은 외부에 노출할 필요가 없는 메서드를 불필요하게 퍼블릭 인터페이스에 추가한 결과를 낳는다. 디폴트 메서드가 추가된 이유는, 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는 하위 호환성 문제를 해결하기 위해서이다. 추상 클래스를 제거하기 위해서가 아니다. 오브젝트 &lt;조영호&gt;","link":"/2020/02/10/object-chapter-appendix-b/"},{"title":"[오브젝트] 부록 C 동적인 협력, 정적인 코드","text":"좋은 설계는 객체 사이의 협력과 행동을 표현하는 동적 모델을 기반으로 해야한다. 동적 모델프로그램 실행 구조를 표현하는 움직이는 모델 정적 모델코드의 구조를 담는 고정된 모델 01 동적 모델과 정적 모델행동이 코드를 결정한다객체가 외부에 제공하는 행동이 중요하다. 동적 모델이 정적 모델을 결정해야한다. 02 도메인 모델과 구현도메인 모델에 관하여 도메인사용자가 프로그램을 사용하는 대상 영역 모델지식을 선택적으로 단순화하고 의식적으로 구조화한 형태 도메인 모델사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태 소프트웨어의 도메인에 대해 고민하고 도메인 모델을 기반으로 소프트웨어를 구축해야한다. 그러면, 개념과 소프트웨어 사이의 표현적 차이를 줄일 수 있기 때문에 이해하고 수정하기 쉬온 소프트웨어를 만들 수 있다. 중요한 것은, 도메인 모델을 작성하는 것이 목표가 아니라 출발점이다. 중요한 것은 객체들의 협력을 지원하는 코드 구조를 만드는 것이다. 코드의 구조를 주도하는 것은 행동이다. 행동과 변경을 고려한 도메인 모델도메인 모델은 단순히 클래스 다이어그램이 아니다. 도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것이다. 이렇게 작성된 개념이 코드에 대한 구조와 행동을 드러내면 훌륭한 도메인 모델이다. 오브젝트 &lt;조영호&gt;","link":"/2020/02/10/object-chapter-appendix-c/"},{"title":"[테스트 주도 개발] 1장_다중 통화를 지원하는 Money 객체","text":"테스트 주도 개발의 리듬은 다음과 같다. 재빨리 테스트 하나 추가 모든 테스트 실행하고 새로 추가한 것이 실패한지 확인 코드를 조금 변경 모든 테스트 실행하고 전부 성공하는지 확인 리팩토링으로 중복 제거 어떤 테스트들이 있어야 보고서에 제대로 계산되도록 하는 코드가 완성됐다고 확신할 수 있을까 ? 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변환 금액을 결과로 얻을 수 있어야한다. 어떤 금액을 어떤 수에 곱한 금액을 결과로 얻을 수 있어야한다. 앞으로 어떤 일을 해야하는지 알려주고, 하는 일에 집중할 수 있게 하고, 언제 일이 끝나는지 알려 줄 수 있도록 할 일 목록을 만든다. 작업이 끝난 항목에는 줄을 긋는다.할일 목록에서 볼 수 있듯이 곱하기를 먼저 다룬다. 작은 것부터 시작한다. 12345public void testMultiplication() { Dollar five = new Dollar(5); five.times(2); AssertionErrors.assertEquals(10, five.amount);} 위 테스트는 아직 컴파일조차 되지 않는다. 실행은 안되더라도, 컴파일만은 되도록 만들고 싶다. 네 개의 컴파일 에러가 있다. Dollar 클래스가 없음 생성자가 없음 times(int) 메서드가 없음 amount 필드가 없음 1234567891011class Dollar { int amount; Dollar(int amount) { } void times(int multiplier){ }} 위 코드에서 times(int multiplier) 는 stub 구현이다. 이 메서드를 호출하는 코드가 컴파일 될 수 있도록 껍데기만 만들어두는 것을 의미한다.테스트를 다시 실행해보자. 실패한다. 테스팅 프레임워크가 결과로 10이 나와야 하는데 0이 나왔다는 것을 알려준다. 1234class Dollar { int amount = 10; ...} 이제 다시 실행해보면, 초록 막대가 나온다. 이제 중복을 제거할 차례이다. “의존성과 중복” 의존성이 문제 그 자체라면, 중복은 문제의 징후다. 만약 특정 데이터베이스 벤더가 제공하는 세세한 기능들이 코드 곳곳에서 사용되고 있으면 다른 벤더 제품으로 변경할 때 해당 벤더에 의존성을 갖고 있다는 것을 알게 된다. 즉, 코드를 변경하지 않고 벤더를 바꿀 수 없다. 중복의 흔한 예는 로직의 중복이다. 중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고다. 다음 테스트로 진행하기 전에 중복을 제거하면, 다음 테스트도 통과되게 만들 가능성을 최대화한다. 12345678910class Dollar { int amount; Dollar(int amount) { } void times(int multiplier){ amount = 5 * 2; }} 테스트는 여전히 통과한다. 1234567891011class Dollar { int amount; Dollar(int amount) { this.amount = amount; } void times(int multiplier) { amount *= multiplier; }} 이제 첫번째 테스트를 완료했다. 다음 장에서는 Dollar 부작용에 대한 작업을 한다. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/02/24/tdd-chapter-01/"},{"title":"[테스트 주도 개발] 2장_타락한 객체","text":"TDD 주기는 다음과 같다. 테스트를 작성한다. 실행가능하게 만든다. 올바르게 만든다. (중복 제거) “작동하는 깔끔한 코드” 를 얻어야한다는 전체 문제 중에서, “작동하는” 에 해당하는 부분을 먼저 해결해라.테스트를 하나 통과했지만, Dollar 에 대한 연산을 수행한 후에 해당 Dollar 의 값이 바뀌는 것이 이상하다. 1234567void testMultiplication() { Dollar product = new Dollar(5); product.times(2); assertEquals(10, product.amount); product.times(3); assertEquals(15, product.amount);} times() 를 처음 호출한 이후에 product 는 더이상 5가 아니다. times() 가 새로운 객체를 반환하면 어떨까 ? 1234567void testMultiplication() { Dollar five = new Dollar(5); Dollar product = five.times(2); assertEquals(10, product.amount); product = five.times(3); assertEquals(15, product.amount);} 123456789101112class Dollar { int amount; Dollar(int amount) { this.amount = amount; } Dollar times(int multiplier) { amount *= multiplier; return null; }} 위 코드는 컴파일되지만 실행되지 않는다. 통과를 위해서는 올바른 금액을 갖는 새 Dollar 를 반환해야한다. 1234567class Dollar { ... Dollar times(int multiplier) { return new Dollar(amount * multiplier); }} 최대한 빨리 초록색을 보기 위한 방법이 있다. 가짜로 구현하기상수를 반환하게 만들고 진짜 코드를 얻을 때 까지 단계적으로 상수를 변수로 바꾸어간다. 명백한 구현 사용하기실제 구현을 입력한다. 보통 실무에서는 두 방법을 번갈아 사용한다. 모든일이 잘 진행되고 뭘 입력할지 알 때는 병백한 구현을 더해나간다. 예상치 못한 빨간 막대를 만나면 가짜로 구현하는 방법을 사용하면서 올바른 코드르 리펙토링한다. 그리고 다시 자신감을 찾으면 명백한 구현을 사용한다. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/02/24/tdd-chapter-02/"},{"title":"[테스트 주도 개발] 3장_모두를 위한 평등","text":"Dollar 객체같이 객체를 값처럼 쓸 수 있는 것을 객체 Value Object Pattern 이라고 한다. 값 객체에 대한 제약사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 변하지 않는다는 것이다.값 객체가 암시하는 것은, 모든 연산은 새 객체를 반환해야한다. 값 객체는 equals() 를 구현해야한다. 123void testEquality(){ assertTrue(new Dollar(5).equals(new Dollar(5)));} 빨간 막대다. 가짜로 구현하는 방법은 단순히 true 를 반환하도록 하는 것이다. 123public boolean equals(Object object){ return true;} (삼각측량) 예제가 두 개 이상 있으면 코드를 일반화 할 수 있다. 다음과 같이 5!=6 을 해보자. 1234void testEquality(){ assertTrue(new Dollar(5).equals(new Dollar(5))); assertFalse(new Dollar(5).equals(new Dollar(6)));} 이제 equlity 를 일반화하자. 1234public boolean equals(Object object){ Dollar dollar = (Dollar) object; return amount == dollar.amount;} 이렇게 어떻게 리팩토링해야하는지 감이 안오면 삼각측량을 사용하자. 코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그 방법대로 구현하면 된다.자, 동일성 문제는 일시적으로 해결했다. 널 값이나 다른 객체들과 비교하는 상황은 일반적이진 않지만 당장은 필요하지 않다. 할일 목록에 적어 두기만 하자. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/02/24/tdd-chapter-03/"},{"title":"[빅데이터] 2장_빅데이터를 위한 데이터 모델","text":"마스터 데이터 집합은 람다 아키텍처에서 반드시 오염으로부터 보호되어야하는 유일한 영역이다. 2.1 데이터의 속성 대규모 소셜 네트워크 (페이스스페이스) 를 설계한다고 하자. 각각의 정보 계층은 바로 앞 단계로부터 파생되지만 단방향성이다.앞으로 사용하게 될 용어들을 정리한다. 정보 : 지식의 일반적인 모음 데이터 : 어떤 것으로부터 파싱되지 않은 정보 질의 : 데이터에 물어볼 수 있는 질문 뷰 : 특정 타입의 질의에 응답하는데 도움을 주기 위해 만들어 지는 것 어떤 사람의 데이터는 또 다른 사람의 뷰각 될 수 있다. 어떤 광고 회사가 페이스스페이스 사용자 프로필로부터 인구 통계학 정보를 긁어 가는 수집기를 만들었다. 톰의 출생월일은 생년월일로부터 도출될 수 있기 때문에 페이스스페이스에게는 뷰 이지만, 광고 회사 입장에서는 톰에 대한 제한된 정보를 가지는 것으로 시작하므로 데이터이다.데이터의 핵심 속성을 살펴보자 : 원시성 / 불변성 / 영원성 2.1.1 데이터는 원시적이다가공되지 않은 데이터일수록 더 많은 질문을 그 데이터에 대해 던질 수 있다. 2.1.2 데이터는 불변이다.관계형 데이터메이스 갱신은 없어서는 안 될 연산이다. 그러나 불변성을 다루기 위해서는 데이터를 갱신하거나 삭제하면 안되고 추가만 해야한다. 빅데이터 시스템에서 불변 스키마를 사용하면 다음 두 가지 이점이 있다. 인적 내결함성실수로 인해 데이터가 손실되지 않는다. 잘못된 데이터가 쓰여도 이전에 있던 데이터는 그대로 남는다. 단순성마스터 데이터 집함에 새 데이터를 추가할 수 있으면 된다. 데이터에 대한 색인이 필요하지 않아 단순하다. 데이터의 불변성을 유지하는 것의 장점은 가변 스키마와 비교하면 명확하다. 톰이 LA 로 이사했다. 그러면 톰의 현재 주거지를 반영하기 위해 갱신을 해야하는데, 톰이 샌프란시스코에 살았다는 지식은 완전히 손실된다.불변 스키마를 사용하면 상황이 다르다. 사용자 정보가 바뀔 때마다 독립된 레코드를 생성한다. 이렇게 하려면 두 가지를 바꿔야한다. 사용자 정보의 각 항목을 독립된 레코드에 저장한다. 각 데이터 단위에 그 정보가 알려진 시간을 붙인다. 톰이 새 주거지로 이사를 하면, 주거지 테이블에 새 래코드를 추가한다. 이제 톰의 주거지를 저장하는 레코드가 두 개가 된다. 관련된 모든 주거지 정보를 훑으면서 타임스태프가 가장 최신인 것을 골라내, 현재 주거지를 알 수 있다.불변 방식을 사용하는 방법으로 감당해야하는 것은 가변 스키마보다 공간을 많이 사용한다는 것이다. 사용자 ID 는 가변 방식에서처럼 로우마다 한 번 나오는게 아니라 모든 속성에 나온다. 게다가 현재 상태 뿐만 아니라 이벤트 기록을 전부 저장한다.하지만, 빅데이터 기술을 통해 막대한 데이터의 저장 능력을 이용해서 불변성의 헤택을 끌어내야한다. 마스터 데이터 집합을 구축하는 일은 정말 중요하다. 2.1.3 데이터는 영원히 참이다.데이터의 불변성으로 인해 만들어지는 중요한 결과는, 데이터가 영원히 참이 된다는 것이다. 2.2 데이터 표현을 위한 팩트 기반 모델마스터 데이터 집합 안에서 데이터를 표현하는 방법은 여러가지다. 전통적인 관계형 데이터베이스의 테이블 구조화된 XML 반구조화된 JSON 팩트 기반 모델 (fact-based model) : 데이터를 fact 라고 불리는 기본 단위로 분해 2.2.1 팩트의 예와 속성 팩트 기반 모델은, 원시 데이터를 원자적인 팩트로 저장한다. 타임스탬프로 인해 팩트는 불변성을 지니며 영원히 참이다. 질의 처리 과정 중에 중복 식별이 가능하도록 각 팩트의 식별 가능성을 보장한다. 팩트는 유일하게 식별할 수 있는 데이터와 연관되어야한다. 페이스스페이스에 페이지뷰에 대한 데이터를 저장하는 경우를 생각해보자. 1234struct PageView: DateTime timestamp String url String ip_address 이 구조체를 사용한 팩트는 특정한 페이지뷰 이벤트로 유일하게 식별되지 않는다. 동일한 IP 주소에서 동일한 URL 에 대한 여러개의 페이지뷰가 동시에 발생하면, 이 때 생겨난 각각의 페이지뷰는 정확히 같은 데이터 레코드이다.서로 다른 페이지뷰를 구분하기 위해 스키마에 nonce (임시값), 각 페이지뷰마다 난수 생성법을 써서 만든 64 비트 숫자를 추가해보자. 12345struct PageView: DateTime timestamp String url String ip_address Long nonce 임시값을 추가하면 페이지뷰 이벤트를 서로 구별할 수 있고, 두 개의 페이지뷰 데이터 단위가 동일하면 이벤트도 동일하다는 것을 알 수 있다. 2.2.2 팩트 기반 모델이 주는 혜택 과거의 어느 시점에 대한 질의도 받을 수 있다.팩트에 타임스탬프가 붙어있고 불변성을 지녀 생기는 결과이다. 사람의 실수에 대해 내성을 가진다.톰이 샌프란시스코에서 로스앤잴래스로 이사한 것을 실수로 저장했다. 톰이 로스엔제렐스에 산다는 팩트를 지우면, 톰의 주거지가 자동으로 이전의 것으로 재설정된다. 부분 정보를 처리할 수 있다.톰이 나이와 성별은 입력했지만 주거지나 직업은 입력하지 않으면, 데이터 집합은 알려진 정보에 대한 팩트만 보관한다. 팩트가 존재하지 않는다는 것은, 논리적으로 null 과 동일하다. 데이터 저장소의 질의 처리 계층이 분리된다.batch layer 와 serving layer 모두에 정보가 저장되기 때문에 데이터가 정규화된 형태와 비정규화된 형태로 있게 되고, 양쪽의 모든 장점을 뽑을 수 있다. 데이터 정규화를 다루는 관계형 테이블 예를 보자. 관계형 테이블을 사용할 때는 질의 효율성과 데이터 일관성 중 어떤 것이 중요하냐에 따라 정규화 스키마와 비정규화 스키마 중 하나를 선택한다. 비정규화된 스키마동일한 이름이 여러 로우에 저장 될 수 있다. 이것은 각 회사의 직원수를 빨리 알아 낼 수 있도록 하지만, 회사가 이름을 바꾸면 많은 로우를 갱신해야한다. 정보를 여러 위치에 저장하는 것은 일관성이 깨질 위험이 있다. 정규화된 스키마오직 하나의 위치에만 저장된다. 일관성이 깨질 위험은 없지만, 질의에 응답하려면 테이블을 조인해야하고 계산 비용이 커질 수 있다. 람다 아키텍쳐에서는 질의 처리와 데이터 저장 목적이 분리되어 있다. 마스터 데이터 집합완전히 정규화되어 있다. 어떤 데이터도 중복 되지 않는다. 현재 타임스템프를 붙여 새 팩트를 추가하면 과거 팩트는 무효화되어 갱신이 쉽다. 일괄처리 뷰데이터 집합의 데이터 하나가 여러 뷰로 생성될수 있다는 점에서 비정규화된 테이블과 같다. 큰 차이는, 일괄 처리 뷰는 마스터 데이터 집합에 대한 함수로 정의된다는 것이다. 마스터 데이터 집합으로부터 계속 재생성 되므로 일괄 처리 뷰를 갱신할 필요가 없다. 2.3 그래프 스키마팩트 그 자체만으로는, 데이터 집합에 저장된 팩트의 형식에 대한 기술도 없고, 그들 사이의 관계에 대한 설명도 없다. 그래서, 그래프 스키마가 필요하다. 2.3.1 그래프 스키마의 요소세 가지 핵심 요소는, 노드 : 시스템 내의 개체 간선 : 노드 사이의 관계 속성 : 개체에 대한 정보 2.3.2 강제 기능 스키마는 왜 필요한가팩트를 저장할 때 어떤 형식으로 저장해야할까. JSON 처럼, 반구조화된 텍스트 형식을 사용한다고 하자. 실질적으로 어떤 것도 마스터 데이터 집합에 기록할 수 있어서 단순하고 유연하다. 하지만 문제가 있다.톰의 나이를 JSON 으로 나타내면, 1{&quot;id&quot; : 3, &quot;field&quot; : &quot;age&quot;, &quot;value&quot; : 29, &quot;timestamp&quot; : 133589484} 사람의 실수로 데이터 집합에 아래와 같은 팩트가 들어 갈 수 있다. 1{&quot;id&quot; : 3, &quot;field&quot; : &quot;age&quot;, &quot;value&quot; : 29} JSON 자체는 유효하지만, 형식의 일관성을 지키지 못했고 데이터도 누락되었다. 텍스트 형식으로는 이 부분을 강제할 수 없다.대안으로, 팩트의 구조를 엄격히 정의하는 강제 기능 스키마를 사용하면 된다. 처음에는 해줄게 많지만, 필요한 필드가 모두 존재하고 모든 값이 기대한 형식에 맞게 한다는 조건이 보장된다. 중요한 것은, 데이터 생성 중에 실수가 있을 때 강제 기능 스키마가 바로 그 시점에 오류를 낸다. 빅데이터, 람다 아키텍처로 알아보는 실시간 빅데이터 구축의 핵심 원리와 기법 &lt;네이선 마츠, 제임스 워렌&gt;","link":"/2020/02/25/bigdata-chapter-02/"},{"title":"[테스트 주도 개발] 4장_프라이버시","text":"12345678@Testvoid testMultiplication() { Dollar five = new Dollar(5); Dollar product = five.times(2); assertEquals(10, product.amount); product = five.times(3); assertEquals(15, product.amount);} 첫 번째 assertion 을 Dollar 와 Dollar 를 비교하는 것으로 재작성할 수 있다. 12345678@Testvoid testMultiplication() { Dollar five = new Dollar(5); Dollar product = five.times(2); assertEquals(new Dollar(10), product); product = five.times(3); assertEquals(15, product.amount);} 두 번째 assertion 도 마찬가지다. 12345678@Testvoid testMultiplication() { Dollar five = new Dollar(5); Dollar product = five.times(2); assertEquals(new Dollar(10), product); product = five.times(3); assertEquals(new Dollar(15), product);} 이제 임시 변수인 product는 필요없다. 123456@Testvoid testMultiplication() { Dollar five = new Dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));} 테스트를 고치고 나니, Dollar 의 amount 인스턴스 변수를 사용하는 코드는 Dollar 자신 밖에 없다. 따라서, 변수를 private 으로 변경 가능하다. 1private int amount; 동치성 테스트가, 동치성에 대한 코드가 정확히 동작하는 것을 검증하는데 실패하면다면 곱하기 테스트 역시, 곱하기에 대한 코드가 정확히 동작한다는 것을 검증하는데 실파헤가 된다. 이것은 TDD 를 하면서 적극적으로 관리해야할 위험 요소이다. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/02/tdd-chapter-04/"},{"title":"[테스트 주도 개발] 5장_솔직히 말하자면","text":"다음을 테스트해보자. 15 + 10CHF = $10 (환율이 2:1 일 경우) 우선 Dollar 객체와 비슷하지만 프랑을 표현할 수 있는 객체가 필요하다. Dollar 테스트를 복사한 후 수정해보자. 1234567@Testvoid testFrancMultiplication() { Franc five = new Franc(5); assertEquals(new Franc(10), five.times(2)); assertEquals(new Franc(15), five.times(3));} 4장에서 테스트를 단순화해놓아서 지금하는 작업이 더 쉬워졌다. 테스트 주기에는 서로 다른 단계들이 있다는 것을 다시 정리하자. 테스트 작성 컴파일 되게하기 실패하는지 확인하기 위해 실행 실행하게 만듦 중복 제거 처음 네 단계는 빨리 진행해야한다. 또한, 다섯 번째 단계 없이는 앞의 네 단계도 제대로 되지 않는다. 1234567891011121314151617public class Franc { private int amount; Franc(int amount) { this.amount = amount; } Franc times(int multiplier) { return new Franc(amount * multiplier); } public boolean equals(Object object) { Franc franc = (Franc) object; return amount == franc.amount; }} 중복이 엄청나게 많기 때문에, 다음 테스트를 작성하기 전에 이것들을 제거해야한다. equals() 를 일반화하는 것부터 시작하자. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/02/tdd-chapter-05/"},{"title":"[테스트 주도 개발] 6장_돌아온 모두를 위한 평등","text":"5장에서 테스트를 빨리 통과하기 위해 코드를 복사해서 붙이는 죄를 저질렀다. 이제 청소할 시간이다.Money 클래스가 공통의 equals 코드를 갖게 하면 어떨까 ? 간단한 것부터 시작하자. 12class Money {} 테스트는 여전히 돌아간다. Dollar 가 Money 를 상속받아도 여전히 어떤 것도 깨지지 않는다. 123public class Dollar extends Money { ...} 이제 amount 인스턴스 변수를 Money 로 옮길 수 있다. 123class Money { protected int amount;} 하위 클래스에서도 변수를 볼 수 있도록, 가시성을 private 에서 protected 로 변경했다.이제, equals() 를 위로 올릴 수 있다. 우선, 임시 변수 선언하는 부분을 변경하자. 12345public boolean equals(Object object) { Money dollar = (Dollar) object; return amount == dollar.amount;} 모든 테스트가 잘 돈다. 이제 cast 부부을 변경하자. 12345public boolean equals(Object object) { Money dollar = (Money) object; return amount == dollar.amount;} 좀 더 원활한 의사소통을 위해, 임시 변수의 이름을 변경하자. 12345public boolean equals(Object object) { Money money = (Money) object; return amount == money.amount;} 이제 이 메서드를 Dollar 에서 Money 로 옮길 수 있다. 123456789class Money { protected int amount; public boolean equals(Object object) { Money money = (Money) object; return amount == money.amount; }} 이제는 Franc.equals() 를 제거해야한다. 일단 동치성 테스트가 Franc 끼리의 비교에 대해서는 아직 다루지 않았다. 우리는 코드를 변경하기 전에 그곳에 있어야 했던 테스트를 먼저 작성할 것이다. 리펙토링 전에 테스트를 먼저 하자. 1234567@Testvoid testEquality() { assertTrue(new Dollar(5).equals(new Dollar(5))); assertFalse(new Dollar(5).equals(new Dollar(6))); assertTrue(new Franc(5).equals(new Franc(5))); assertFalse(new Franc(5).equals(new Franc(6)));} 또 중복이다. 1234public class Franc extends Money { private int amount; ...} Money 클래스에 있는 필드를 이용하면, amount 필드를 제거할 수 있다. 123public class Franc extends Money { ...} Franc.equals() 는 Money.equals() 와 비슷해 보인다. 이 두 부분을 똑같이 만들면 프로그램의 의미를 변화시키지 않고도 Franc.equals() 를 완전히 지울 수 있다. 우선 임시 변수 선언 부분부터 고치자. 12345public boolean equals(Object object) { Money franc = (Franc) object; return amount == franc.amount;} 다음엔 cast. 12345public boolean equals(Object object) { Money franc = (Money) object; return amount == franc.amount;} 임시 변수의 임름도 상위 클래스에 맞게 고치자. 12345public boolean equals(Object object) { Money money = (Money) object; return amount == money.amount;} 이제 Franc.equals() 는 Money.equals() 와 동일하므로, Franc 의 불필요한 코드를 제거하자. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/02/tdd-chapter-06/"},{"title":"[빅데이터] 3장_빅데이터를 위한 데이터 모델: 사례","text":"Apache Thrift 란 직렬화 프레임워크를 사용해 SuperWebAnalytics.com 데이터 모델을 구현한다. 3.1 어째서 직렬화 프레임워크인가많은 개발자들이 원시 데이터를 기록하는 방법으로 JSON 등의 스키마 없는 형식을 고른다. 작업을 쉽게 착수할 수 있는 장점이 있지만, 데이터 오염이 언제든지 터질 수 있는 단점이 있다.데이터 오염 문제는 그 문제가 어떻게 발생했는지에 대한 전후사정을 거의 손에 넣을 수 없기 때문에 디버깅이 어렵다. 예를 들어, 필수 항목이 누락되어 NPE 가 발생하면 문제의 원인이 누락된 항목이라는 것은 바로 알 수 있지만 애초에 그 데이터가 어떻게 들어왔는지에 대한 정보는 없다.강제 가능 스키마를 만들었으면, 데이터를 기록하는 시점에 오류가 나므로 데이터가 무효화된 사정과 원인에 대한 전후 사정을 알 수 있다. 그리고, 이때 발생한 오류 덕에 프로그램은 무효 데이터를 기록하지 못하므로 마스터 데이터 집합도 오염되지 않는다.직렬화 프레임워크를 사용하면 강제가능 스키마를 쉽게 적용 할 수 있다. 3.2 Apache ThriftApache Thrift 는 정적 타입의 강제가능 스키마를 정의하는데 쓰이는 도구이다. 이와 유사한 도구로, Protocol Buffers 나 Avro 등이다.Apache Thrift 의 주요 요소는 구조체 (struct) 와 공용체 (union) 타입 정의이다. 이들은 다음 필드의 조합으로 구성된다. 기본 데이터 타입 : 문자열, 정수, long 정수, double 실수 다른 타입의 집합체 (리스트, 맵, 세트) 다른 구조체와 공용체 3.2.1 노드SuperWebAnalytics.com 의 사용자 노드에서 개인은 사용자ID 나 브라우저 키기로 식별된다. 이 둘이 동시에 함께 식별에 쓰이지는 않는다. 이런 패턴은 노드를 나타날 때 흔히 볼 수 있는데, 공용체 데이터 타입과 일치한다. 하나의 값으로 여러 가지를 나타내는 타입이다. 12345678union PersonID { 1: string cookie; 2: i64 user_id;}union PageID { 1: String url;} 3.2.2 간선간선은 두 개의 노드를 포함하는 구조체로 표현될 수 있다. 간선 구조체의 이름은 그것이 표현하는 관계를 가리킨다. 간선 구조체 내의 필드는 그 관계로 엮인 개체들이다. 12345678910struct EquivEdge { 1: required PersonID id1; 2: required PersonID id2;}struct PageViewEdge { 1: required PersonID person; 2: required PageID page; 3: required i64 nonce;} 스리프트 구조체의 필드는 required 나 optional 로 표시한다. 필드가 required 정의되었는데 값이 없으면 직렬화나 역직렬화할 때 스리프트 자체에서 오류가 난다. 그래프 스키마에서 각 간선은 두개의 노드가 필수이므로 required 필드로 정의된다. 3.2.3 속성속성은 노드와 그 속성 대한 값을 가진다. 값은 여러 타입이 될 수 있으므로 공용체를 사용한다. 123456789101112131415161718192021222324252627282930union PagePropertyValue { 1: i32 page_views;}struct PageProperty { 1: required PageID id; 2: required PagePropertyValue property;}struct Location { 1: optional string city; 2: optional string state; 3: optional string country;}enum GenderType { MALE = 1, FEMALE = 2}union PersonPropertyValue { 1: string full_name; 2: GenderType gender; 3: Location location;}struct PersonProperty { 1: required PersonID id; 2: required PersonPropertyValue property;} 3.2.4 노드, 간선, 속성을 모두 엮어 데이터 객체로 만들기정보에 접근하는 단일한 인터페이스를 제공하기 좋게 모든 데이터를 함께 저장하고자 한다. 그리고, 단일 데이터 집합에 저장되면 데이터 관리도 쉽다. 123456789101112131415union DataUnit { 1: PersonProperty person_property; 2: PageProperty page_property; 3: EquivEdge equiv; 4: PageViewEdge page_view;}struct Pedigree { 1: required i32 true_as_of_secs;}struct Data { 1: required Pedigree pedigree; 2: required DataUnit dataunit;} Pedigree 구조체는 정보에 붙을 타임스탬프를 가지고 있다. 필요하면 디버깅 정보나 데이터 출처를 가질 수 있다. Data 구조체는 팩트 기반 모델의 팩트에 해당한다. 3.2.5 스키마 발전시키기스리프트는 시시때때로 스키마를 발전시키도록 설계되었다. 스키마를 변경할 때 기존 데이터와의 하위 호솬성을 유지하고자 하면 다음 규칙을 지켜야한다. 필드의 이름은 변경해도 무방하다.직렬화된 객체 형식은 필드 식별을 위해 ID 를 사용한다. 필드를 삭제할 수 있지만, 필드 ID 를 재사용하면 안된다.기존 데이터를 역직렬화할 때 스리프트는 스키마에 포함되지 않은 ID 를 갖는 필드는 모두 무시한다. 삭제된 필드의 ID 를 재사용하면 스리프트는 오래된 데이터를 새로운 필드로 역직렬화할 것이다. 그래서 유효하지 않거나 잘못된 데이터가 만들어질 수 있다. 기존 구조체에는 optional 필드만 추가할 수 있다.기존 데이터는 그 필드가 없을 것이고 결국 역직렬화가 되지 않을 것이다. (공용체의 경우 required 나 optional 개념이 없다.) 3.3 직렬화 프레임워크의 한계직렬화 프레임워크는 required 필드가 모두 존재하고, 타입이 일치하는지만 점검한다. 즉, “나이는 음수가 아니어야한다.”, “참인 시점의 타임스탬프는 미래가 아니어야한다.” 와 같은 다채로운 속성은 점검할 수 없다. 스키마는 데이터를 받아 유효 여부를 반환하는 하나의 함수로 보는게 좋다. 그런 이상적인 도구는 현실적으로 세상에 없지만, 한계를 우회할 수 있는 두 가지 방법이 있다. 생성된 코드를 추가 코드로 감싸고, 추가 코드에서 나이는 음수가 아닌 조건을 체크하는 등의 추가적인 속성을 확인하도록 한다.여러 언어를 사용한다면 동일한 로직을 여러 언어로 작성하는 중복 작업이 요구된다. 일괄 처리 작업 흐름의 시작점에서 추가 속성을 확인한다.이 확인 단계에서 데이터 집합을 유효한 데이터와 유효하지 않은 데이터로 나누고 유효한 데이터가 발견되면 알림을 보낸다. 그러면, 작업 흐름의 나머지 부분 구현이 쉬워진다. 유효성 확인을 통과한 데이터이면 엄격한 속성을 일단 가지고 있다고 가정할 수 있다. 그런데, 무효 데이터가 마스터 데이터 집합에 기록되는 것을 막지는 못하며, 데이터 오염이 발생한 전후 사정을 알아낼 수 없다. 빅데이터, 람다 아키텍처로 알아보는 실시간 빅데이터 구축의 핵심 원리와 기법 &lt;네이선 마츠, 제임스 워렌&gt;","link":"/2020/03/08/bigdata-chapter-03/"},{"title":"[테스트 주도 개발] 7장_사과와 오렌지","text":"제목 의미 : 서로 다른걸 비교할 수 없다. Franc 와 Dollar 를 비교하면 어떻게 될까 ? 12345678@Testvoid testEquality() { assertTrue(new Dollar(5).equals(new Dollar(5))); assertFalse(new Dollar(5).equals(new Dollar(6))); assertTrue(new Franc(5).equals(new Franc(5))); assertFalse(new Franc(5).equals(new Franc(6))); assertFalse(new Franc(5).equals(new Dollar(5)));} 실패한다. 오직 금액과 클래스가 동일할 때만 두 Money 가 서로 같은 것이다. 12345public boolean equals(Object object) { Money money = (Money) object; return amount == money.amount &amp;&amp; getClass().equals(money.getClass());} 자바 객체의 용어를 사용하는 것보다 재정 분야에 맞는 용어를 사용하고 싶다. currency 통화 개념 같은 게 없고, 통화 개념을 도입할 충분한 이유가 없으므로 잠시 이렇게 두자. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/11/tdd-chapter-07/"},{"title":"[테스트 주도 개발] 8장_객체 만들기","text":"times() 의 구현 코드가 거의 같다. 123456789// Franc ClassFranc times(int multiplier) { return new Franc(amount * multiplier); } // Dollar ClassDollar times(int multiplier) { return new Dollar(amount * multiplier); } 양쪽 모두 Money 를 반환하게 만들면 더 비슷해진다. 123456789// Franc ClassMoney times(int multiplier) { return new Franc(amount * multiplier); } // Dollar ClassMoney times(int multiplier) { return new Dollar(amount * multiplier); } 이제, Money 의 두 하위 클래스는 많은 일을 하지 않으므로 제거하고 싶다. 한번에 이렇게 큰 단계를 밟는 것은 TDD 를 효과적으로 보여주기 적절치 않을 것 같다.하위 클래스에 대한 직접적인 참조가 적어지면 하위 클래스를 제거하기 쉬울 것 같다. 1234567@Testvoid testMultiplication() { Dollar five = Money.dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));} 구현 코드는 Dollar 를 생성해 반환한다. 1234// Money Classstatic Dollar dollar(int amount) { return new Dollar(amount); } Test 선언부도 다음과 같이 변경한다. 1234567@Testvoid testMultiplication() { Money five = Money.dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));} 컴파일러가 이제 times() 가 정의되어 있지 않았다는 사실을 알려준다. 지금은 이걸 구현할 준비가 안되어 있기 때문에, Money 를 추상 클래스로 변경한 후 Money.times() 를 선언하자. 123456789101112131415abstract class Money { protected int amount; static Dollar dollar(int amount) { return new Dollar(amount); } abstract Money times(int multiplier); public boolean equals(Object object) { Money money = (Money) object; return amount == money.amount &amp;&amp; getClass().equals(money.getClass()); }} 이제 팩토리 메서드의 선언을 바꿀 수 있다. 1234static Money dollar(int amount) { return new Dollar(amount);} 모든 테스트가 실행된다. 이제 팩토리 메서드를 테스트 코드의 나머지 모든 곳에 사용하자. 12345678910111213141516@Testvoid testMultiplication() { Money five = Money.dollar(5); assertEquals(Money.dollar(10), five.times(2)); assertEquals(Money.dollar(15), five.times(3));}@Testvoid testEquality() { assertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertTrue(new Franc(5).equals(new Franc(5))); assertFalse(new Franc(5).equals(new Franc(6))); assertFalse(new Franc(5).equals(Money.dollar(5)));} 어떤 클라이언트 코드도 Dollar 라는 이름의 하위 클래스가 있다는 사실을 모른다. 하위 클래스의 존재를 테스트에서 분리함으로써 어떤 모델 코드에도 영향을 주지 않고 상속 구조를 마음대로 변경할 수 있게 됐다.이제 Franc 에도 적용하자. 12345678910111213141516@Testvoid testFrancMultiplication() { Franc five = Money.franc(5); assertEquals(Money.franc(10), five.times(2)); assertEquals(Money.franc(15), five.times(3));}@Testvoid testEquality() { assertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertTrue(Money.franc(5).equals(Money.franc(5))); assertFalse(Money.franc(5).equals(Money.franc(6))); assertFalse(Money.franc(5).equals(Money.dollar(5)));} 구현은 Money.dollar() 와 유사하다. 1234// Money Class public static Franc franc(int amount) { return new Franc(amount); } 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/11/tdd-chapter-08/"},{"title":"[테스트 주도 개발] 9장_우리가 사는 시간","text":"제목 : 영어에서 시간과 곱하기가 모드 ‘times’ 라는 점에서 착안한 말장난이다.통화 개념을 어떻게 테스트하길 원하는가 ? 통화를 표현하기 위한 복잡한 객체를 만들 수도 있다. 그리고, 그 객체들이 필요한 만큼만 만들어지도록 하기 위해 flyweight factories 경량 팩토리를 사용할 수 있을 것이다. 하지만, 당분간 대신 문자열을 쓰자. 123456@Testvoid testCurrency(){ assertEquals(&quot;USD&quot;, Money.dollar(1).currency); assertEquals(&quot;CHF&quot;, Money.franc(1).currency);} 우선, Money 에 currency() 메서드를 선언하자. 1abstract String currency(); 그리고 이를, 두 하위 클래스에서 구현하자. 1234567891011// Dollar Class@Override String currency() { return &quot;USD&quot;; }// Franc Class @Override String currency() { return &quot;CHF&quot;; } 우린 두 클래스를 모두. 포함할 수 있는 동일한 구현을 원한다. 통화를 인스턴스 변수에 저장하고, 메서드에서는 그냥 그걸 반환하게 할 수 있을 것이다. 1234567891011121314151617class Franc extends Money { private String currency; Franc(int amount) { this.amount = amount; currency = &quot;CHF&quot;; } Money times(int multiplier) { return new Franc(amount * multiplier); } @Override String currency() { return currency; }} 1234567891011121314151617class Dollar extends Money { private String currency; Dollar(int amount) { this.amount = amount; currency = &quot;USD&quot;; } Money times(int multiplier) { return new Dollar(amount * multiplier); } @Override String currency() { return currency; }} 이제 두 currency() 가 동일하므로 변수 선언과 currency() 구현을 모두 위로 올릴 수 있다. 123456789101112131415161718192021222324abstract class Money { protected int amount; protected String currency; static Money dollar(int amount) { return new Dollar(amount); } public static Franc franc(int amount) { return new Franc(amount); } String currency() { return currency; } public boolean equals(Object object) { Money money = (Money) object; return amount == money.amount &amp;&amp; getClass().equals(money.getClass()); } abstract Money times(int multiplier);} 문자열 ‘USD’ 와 ‘CHF’ 를 정적 팩토리 매서드로 옮기면 두 생성자가 동일해진다. 그럼 공통 구현을 만들 수 있다. 12345//Franc ClassFranc(int amount, String currency) { this.amount = amount; this.currency = &quot;CHF&quot;; } 이제, 생성자를 호출하는 코드 두 곳이 깨진다. 123456789// Money Class static Franc franc(int amount) { return new Franc(amount, null); }// Franc ClassMoney times(int multiplier) { return new Franc(amount * multiplier, null); } 잠깐. 왜 Franc.times 가 팩토리 메서드를 호출하지 않고 생성자를 호출하고 있는거지 ? 지금 이걸 고쳐야하나 ? 아니면 지금 하고 있는 일을 먼저 끝내야 하나 ? 보통 짧은 중단이 필요한 경우에는 이를 흔쾌히 받아들이자. 1234// Franc ClassMoney times(int multiplier) { return Money.franc(amount * multiplier); } 이제 팩토리 메서드가 ‘CHF’ 를 전달할 수 있다. 12345// Money Classstatic Franc franc(int amount) { return new Franc(amount, &quot;CHF&quot;); } 그리고, 마지막으로 인자를 인스턴스 변수에 할당할 수 있다. 12345//Franc ClassFranc(int amount, String currency) { this.amount = amount; this.currency = currency; } Dollar 도 이와 유사하게 수정하자. 1234// Money Class static Money dollar(int amount) { return new Dollar(amount, &quot;USD&quot;); } 12345678910class Dollar extends Money { Dollar(int amount, String currency) { this.amount = amount; this.currency = currency; } Money times(int multiplier) { return Money.dollar(amount * multiplier); }} 이제 두 생성자가 동일해졌다. 구현을 상위 클래스로 올리자. 12345// Money Money(int amount, String currency) { this.amount = amount; this.currency = currency; } 1234// Dollar Dollar(int amount, String currency) { super(amount, currency); } 1234// Franc Franc(int amount, String currency) { super(amount, currency); } 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/11/tdd-chapter-09/"},{"title":"[테스트 주도 개발] 10장_흥미로운 시간","text":"두 times() 구현이 거의 비슷하다. 하지만 완전히 동일하지 않다. 123456789class Franc extends Money { Franc(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return Money.franc(amount * multiplier); }} 123456789class Dollar extends Money { Dollar(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return Money.dollar(amount * multiplier); }} 팩토리 메서드를 인라인 시키면 어떨까 ? 123456789class Franc extends Money { Franc(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return new Franc(amount * multiplier, &quot;CHF&quot;); }} 123456789class Franc extends Money { Franc(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return new Dollar(amount * multiplier, &quot;USD&quot;); }} 바로 전 장에서 팩토리 메서드를 호출하는 것으로 바꿨었는데.. 실망스러운 일이다.Franc 에서는 인스턴스 변수 currency 가 항상 ‘CHF’ 이므로, 123456789class Franc extends Money { Franc(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return new Franc(amount * multiplier, currency); }} 123456789class Dollar extends Money { Dollar(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return new Dollar(amount * multiplier, currency); }} Franc 를 가질지, Money 를 가질지 정말 중요한 사실인가 ? 고민하는 대신 그냥 수정하고 테스트를 돌려보자. 123456789class Franc extends Money { Franc(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return new Money(amount * multiplier, currency); }} 컴파일러가, Money 를 Concrete 클래스로 바꿔야한닫고 한다. 1234567class Money { ... Money times(int multiplier){ return null; }} 빨간 막대다.Expected :me.jko.tddstudy.Franc@262b2c86Actual :me.jko.tddstudy.Money@371a67ec더 나은 메세지를 보기 위해 toString() 을 정의하자. 1234// Money public String toString(){ return amount + &quot; &quot; + currency; } 테스트도 없이 코드를 작성했네 ? 테스트를 먼저 작성하는게 맞다. 하지만. 화면에 나타나는 결과를 확인하려던 참이었다. toString 은 디버그 출력으로만 쓰이기 떄문에, 잘못 구현됨으로 인해 얻게 될 리스크가 적다. 이미 빨간 막대 상태에서는 새로운 테스트를 작성하지 않는게 좋다. 이제 에러 메세지에,expected: me.jko.tddstudy.Franc@262b2c86&lt;10 CHF&gt; but was: me.jko.tddstudy.Money@371a67ec&lt;10 CHF&gt;조금 나아졌지만, 혼란스럽다. 답은 맞았는데 클래스가 다르다. Franc 대신 Money 가 나왔다. 문제는 여기에 있다. 123456// Moneypublic boolean equals(Object object) { Money money = (Money) object; return amount == money.amount &amp;&amp; getClass().equals(money.getClass()); } 정말로 검사해야할 것은 클래스가 같은지가 아니라, currency 가 같은지 여부다.빨간 막대 상황에서는 테스트를 추가로 작성하고 싶지 않다. 하지만 지금은 실제 모델 코드를 수정하려고 하는중이고 테스트 없이는 모델 코드를 수정할 수 없다. 변경된 코드를 되돌려서 다시 초록 막대 상태로 돌아가야한다. 123456789class Franc extends Money { Franc(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return new Franc(amount * multiplier, currency); }} 다시 초록 막대이다. 우리 상황은 Franc(10, ‘CHF’) 와 Money(10, ‘CHF’) 가 서로 같기를 바라지만, 사실 그렇지 않다고 보고된 것이다. 이걸 그대로 테스트 해보자. 1234@Testpublic void testDifferentClassEquality() { assertTrue(new Money(10, &quot;CHF&quot;).equals(new Franc(10, &quot;CHF&quot;)));} 예상 대로 실패한다. equals() 는 클래스가 아니라, currency 를 비교해야한다. 1234567// Money public boolean equals(Object object) { Money money = (Money) object; return amount == money.amount &amp;&amp; currency().equals(money.currency()); } 이제 Franc.times() 에서 Money 를 반환해도 테스트가 여전히 통과한다. 123456789class Franc extends Money { Franc(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return new Money(amount * multiplier, currency); }} Dollar.times() 에도 적용하자. 123456789class Dollar extends Money { Dollar(int amount, String currency) { super(amount, currency); } Money times(int multiplier) { return new Money(amount * multiplier, currency); }} 잘 돈다. 이제 두 구현이 동일해졌다. 위로 올리자. 1234// MoneyMoney times(int multiplier) { return new Money(amount * multiplier, currency);} 이제 아무것도 안 하는 하위 클래스들을 제거할 수 있겠다. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/11/tdd-chapter-10/"},{"title":"[테스트 주도 개발] 11장_모든 악의 근원","text":"두 하위 클래스에는 이제 생성자밖에 없다. 제거하자. 코드의 의미를 변경하지 않으면서 하위 클래스에 대한 참조를 상위 클래스에 대한 참조로 변경할 수 있다. 12345678//Moneystatic Money dollar(int amount) { return new Money(amount, &quot;USD&quot;);}static Money franc(int amount) { return new Money(amount, &quot;CHF&quot;);} 이제 Dollar 에 대한 참조가 하나도 없으므로 지울 수 있다. 하지만, Franc 는 테스트 코드에서 아직 참조한다. 1234@Testpublic void testDifferentClassEquality() { assertTrue(new Money(10, &quot;CHF&quot;).equals(new Franc(10, &quot;CHF&quot;)));} 이 테스트를 지워도 될 정도로 다른 곳에서 이미 동치성 테스트를 충분히 하고 있는가 ? 12345678@Testvoid testEquality() { assertTrue(Money.dollar(5).equals(Money.dollar(5))); // 1 assertFalse(Money.dollar(5).equals(Money.dollar(6))); // 2 assertTrue(Money.franc(5).equals(Money.franc(5))); // 3 assertFalse(Money.franc(5).equals(Money.franc(6))); // 4 assertFalse(Money.franc(5).equals(Money.dollar(5)));} 3, 4 단언은 1, 2 단언과 중복이다. 지우자. 123456@Testvoid testEquality() { assertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertFalse(Money.franc(5).equals(Money.dollar(5)));} 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/11/tdd-chapter-11/"},{"title":"[테스트 주도 개발] 12장_드디어 더하기","text":"전체 더하기 기능에 대한 스토리를 어떻게 적어야할지 모르겠다. 간단한 예, “5 달러 + 5달러 = 10 달러” 에서 시작하자. 12345@Testvoid testSimpleAddition() { Money sum = Money.dollar(5).plus(Money.dollar(5)); assertEquals(Money.dollar(10), sum);} 그냥 Money.dollar(10) 을 반환하는 식으로 가짜 구현을 할 수 있지만, 어떻게 구현할지 명확하므로 다음과 같이 하겠다. 1234// MoneyMoney plus(Money addend){ return new Money(amount + addend.amount, currency);} 다중 통화 사용에 대한 내용을 시스템의 나머지 코드에 숨기고 싶다. ( 2달러 + 3CHF ) * 5 를 보자. Money 가 수식의 가장 작은 단위가 된다. 연산의 결과로 Expression 들이 생기는데, 그 중 하나가 sum 이다. 연산이 완료되면 환율을 이용해서 결과 expression 을 단일 통화로 축약할 수 있다. 이런식으로 테스트할 수 있다. 12345@Testvoid testSimpleAddition() { .... assertEquals(Money.dollar(10), reduced);} reduced 란 이름의 expression 은 expression 에 환율을 적용해서 얻어진다. 실세계에서 환율이 적용되는 곳은 어디인가 ? 은행이다. 123456@Testvoid testSimpleAddition() { ... Money reduced = back.reduce(sum, &quot;USD&quot;); assertEquals(Money.dollar(10), reduced);} 여기서, 단순히 “…reduce = sum.reduce(“USD”, back)” 라고 할수 있었다. 왜 Back 가 reduce() 를 수행할 책임을 맡았을 까 ? Expression 은 하려고 하는 일의 핵심이다. 핵심이 되는 객체가 다른 부분에 대해서 될 수 있는 한 모르도록 하자. 그러면, 핵심 객체가 가능한 오랫 동안 유연할 수 있다. 그리고, 테스트하기도 쉽고 재활용하거나 이해하기에 쉽다. Expression 과 관련이 있는 오퍼레이션이 많은 수 있다. 모든 오펴레이션을 Expression 에만 추가하면 Expression 는 무한히 커진다. 1234567@Testvoid testSimpleAddition() { ... Bank bank = new Bank(); Money reduced = bank.reduce(sum, &quot;USD&quot;); assertEquals(Money.dollar(10), reduced);} 두 Money 의 합은 Expression 이어야한다. 12345678@Testvoid testSimpleAddition() { ... Expression sum = five.plus(five); Bank bank = new Bank(); Money reduced = bank.reduce(sum, &quot;USD&quot;); assertEquals(Money.dollar(10), reduced);} 5 달러를 만드는 것은 쉽다. 12345678@Testvoid testSimpleAddition() { Money five = Money.dollar(5) Expression sum = five.plus(five); Bank bank = new Bank(); Money reduced = bank.reduce(sum, &quot;USD&quot;); assertEquals(Money.dollar(10), reduced);} 이걸 컴파일하려면 어떻게 해야하나 ? Expression 인터페이스가 필요하다. 클래스도 되지만, 더 가볍다. 12interface Expression {} Money.plus 는 Expression 을 반환해야한다. 123Expression plus(Money addend){ return new Money(amount + addend.amount, currency);} 이건, Money 가 Expressoin 을 구현해야한다는 뜻이다. Expressoin 에 아직 아무 연산이 없으니 쉽다. 1class Money implements Expression { 이제 빈 Back 클래스가 필요하다. 12class Bank {} 그리고 reduce() Stub 이 필요하다. 123456class Bank { Money reduce(Expression source, String to) { return null; }} 이제 컴파일 되고, 바로 실패한다. 간단히 가짜 구현을 하자. 123456class Bank { Money reduce(Expression source, String to) { return Money.dollar(10); }} 다시 초록막대. 리팩토링하자. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/11/tdd-chapter-12/"},{"title":"[빅데이터] 4장_일괄 처리 계층의 데이터 저장소","text":"마스터 데이터 집합은하나의 서버에 저장하기에는 너무 크다. 데이터를 여러 장비에 어떻게 분산시킬 것인지기 중요하다.이번 장은 다음을 정리한다. 마스터 데이터 집합을 저장하는데 필요한 요구사항 분산 파일 시스템이 왜 데이터 집합을 저장하는데 적합한지 4.1 마스터 데이터 집합 저장소의 요구사항“데이터를 한 번만 쓰고, 읽기는 큰 단위로 여러 번 수행된다” 방식에 초점을 두면, 다음과 같이 요구사항을 정리할 수 있다. 쓰기 데이터 추가의 효율성 : 유일한 쓰기 연산은 새로운 데이터를 추가하는 것뿐이다. 확장성 있는 저장소 : 데이터 집합이 커질 때 확장하기 쉬워야한다. 읽기 병렬 처리 지원 : 거대한 양의 데이터를 확장성 있는 방식으로 다룰 수 있도록 병렬 처리를 지원해야한다. 둘 다 저장 비용과 처리 비용 조율 : 필요에 따라 데이터를 저장학고 압축하는 방식을 선택하는 유연성이 있어야한다. 불변성 강제 4.2 일괄 처리 계층을 위한 저장소 솔루션 선택4.2.1 키/값 저장소여러 장비에 분산되는 거대하고 영속적인 hash map 값은 저장할 데이터이다. 키는 무엇일까 ? 우리가 사용하는 데이터 모델에는 데이터 자체가 대량 소비를 전제로 한다. 그래서 원래 키가 없고, 필요하지도 않다. 즉, 처음 부터 데이터 모델과 키/값 저장소의 동작 방식이 맞지 않는 것이다. 유일하게 쓸만한 방법이라면, UUID 를 생성해서 키로 사용하는 것이다. 키/값 저장소는 무작위 읽기와 쓰기를 지원하기 위해 키/값 쌍에 세밀하게 접근해야한다. 그래서, 여러 개의 키/값 쌍을 묶어서 압축하는 것도 불가능하다. 키/값 저장소는 변경 가능한 저장소에 사용하도록 만들어져서, 마스터 데이터 집합에 불변성을 강제하는 게 극히 필요한 경우라면 문제가 된다. 키/값 저장소에는 불필요한 기능이 많다. 무작위 읽기, 쓰기 그리고 이들을 가능하게 하는 모든 장치들이 이에 해당된다. 데이터 색인을 하며 우리에게는 필요 없는 서비스도 제공해서 저장소 비용이 증가하고 데이터를 읽고 쓰는 성능이 저하될 수 있다. 4.2.2 분산 파일 시스템파일은 디스크에 순차적으로 저장된다. 파일에 들어있는 바이트는 완전히 제어할 수 있고 압축도 가능하다. 파일 시스템은 딱 필요한 기능만 제공하고 세밀한 권한 시스템으로 구현되어 있어서 불변성을 강제할 수 있다.보통의 파일시스템의 문제는, 오직 하나의 장비에만 존재한다는 것이다. 그래서, 확장하려고 해도 단일 장비가 제공하는 저장소 크기와 처리 용량에 제한된다. 하지만, 저장소가 컴퓨터 클러스터에 나뉘어져 있는 분산 파일 시스템 이 있다. 클러스터에 장비를 추가함으로써 규모가 확장된다. 또한, 장비가 한 대 죽더라도 모든 파일과 데이터에 접근할 수 있다. (내결함성)분산 파일 시스템과 일반적인 파일 시스템은 조금 다르다. 분산 파일시스템에서 수행가능한 연산은 제한적이다. 예를 들어, 파일 중간에 쓸 수 없고, 파일을 만든 후에 변경이 불가능하다. 또, 작은 파일은 비효율적이라서 파일 크기를 상대적으로 크게 유지해야한다. (64MB 정도가 일반적) 4.3 분산 파일시스템의 동작 방식하둡 분산 파일 시스템 (HDFS) 를 예로 들자.HDFS 와 Hadoop MapReduce 는, 대용량 데이터를 저장하고 처리하기 위한 자바 프레임워크인 하둡 프로젝트의 구성 요소이다. 하둡은 클러스터라고 부르는 여러 서버에 배포되고, HDFS 는 확장성 있는 파일 시스템으로 클러스터에 데이터가 어떻게 저장될지를 관리한다.HDFS 에는 두 종류의 노드가 있다 : 하나의 네임 노드와 복수 개의 데이터노드파일을 HDFS 에 올리면, 그 파일은 먼저 고정된 크기의 블록으로 쪼개진다. 블록 크기는 보통 64MB ~ 256MB 이다. 그리고, 각 블록은 임의의 선택된 복수개의 (보통 3개) 데이터 노드로 복제된다. 프로그램이 HDFS 에 저장된 파일에 접근할 때는 파일 내용을 보관하고 있는 데이터 노드를 알아내기 위해 네임노드에 접속한다.각각의 블록이 추가적으로 여러 노드에 복제되어 있어서, 개별 노드가 오프라인 상태가 되어도 데이터는 여전히 사용 가능하다. 4.4 분산 파일 시스템을 사용해서 마스테 데이터 집합을 저장하기파일을 한번 생성한 후에 변경할 수 없는 가장 기본적인 분산 파일시스템을 사용해보자.파일을 변경할 수 없다면 당연히 마스터 데이터 집합 전체를 하나의 파일에 저장할 수 없다. 다른 방법으로, 마스터 데이터 집합을 여러 파일로 나누고 모든 파일을 동일한 폴더에 저장하면 된다. 각 파일에는 직렬화된 데이터 객체가 들어있다.마스터 데이터 집합에 데이터를 추가하려면, 새로운 데이터 객체를 가지고 있는 새로운 파일을 마스터 데이터 집합 폴더에 추가하면 된다. 4.5 수직분할일괄 처리 계층은 전체 데이터 집합에 대한 함수를 실행하도록 만들어졌다. 하지만, 데이터 전체를 사용할 필요가 없는 계산도 있다. 예를 들면, 지난 두 주 동안 수집된 정보만 필요한 계산도 있을 수 있다.일괄 처리 저장소는 데이터를 분할하여 함수가 자신의 계산과 관련있는 데이터에만 접근하록 해야한다. 이것이 수직분할이다. 일괄 처리 계층을 효율적으로 만든다.데이터를 개개의 폴더에 저장하는 걸로 구현할 수 있다. 예를 들어, 분산 파일 시스템에 로그인 정보를 저장한다고 하자. 각각의 로그인 정보에는 사용자 이름 / IP / 주소 / 타임스탬프가 포함된다. 날짜를 기준으로 수직분할 하면, 그날 그날의 데이터에 사용할 독립적인 폴더를 만들면 된다.이제 일부 데이터 집합에만 접근하고 싶으면, 특정 폴더에 있는 파일만 보고 나머지 파일은 무시할 수 있다. 4.6 분산 파일 시스템의 하위 수준 속성분산 파일 시스템 API 를 직접 사용하는 것은 실행해야 하는 작업에 비해, 너무 하위 수준이다.마스터 데이터 집합에 데이터를 추가하는 예를 보자. 마스터 데이터 집합은 /master 폴더에 있다. 마스터 데이터 집합에 추가하고 싶은 데이터는 /new-data 폴더에 있다. 폴더에 있는 데이터는 파일에 저장된다. 가장 뻔한 방법은 다음 의사 코드 처럼 하는 것이다. 12foreach file:&quot;/new-data&quot; mv file &quot;/master&quot; 결함이 있다. 만약, 마스터 데이터 집합 폴더에 이름이 같은 파일이 있으면 mv 연산은 실패한다. 파일의 이름을 임의의 이름으로 바꿔서 충돌을 회피해야한다.또한, /new-data 에 있는 파일과 /master 에 있는 파일의 형식이 다르면, mv 연산은 작동하지 않는다. 그래서, /new-data 에 있는 레코드를 복사해서 /master 에 있는 파일 포맷과 동일한 새로운 파일을 만들어야한다.수직 분할 된 마스터 데이터 집합에 동일한 작업을 해보자. /master 의 수직 분할을 따르지 않기 때문에, /new-data 에 있는 파일을 /master 의 최상위 경로로 바로 옮기면 안된다. 데이터 추가 연산을 허용하지 않거나, /new-data 에 대해 데이터 추가 연산의 부분으로 수직 분할을 해야한다.그런데, 여기에 파일 및 폴더용 API 를 직접 사용하면 실수를 저지르기 쉽고 데이터 집합의 수직분할도 쉽게 깨질 수 있다. 이런 작업을 바르게 처리하기 위해 일일히 필요한 연산과 점검을 챙겨야 하는 것은, 파일과 폴더는 데이터 집합을 조작하기에는 추상화 수준이 너무 낮다는 것을 의미한다.이러한 작업을 자동화해주는 라이브러리들을 다음 장에서 정리하자. 빅데이터, 람다 아키텍처로 알아보는 실시간 빅데이터 구축의 핵심 원리와 기법 &lt;네이선 마츠, 제임스 워렌&gt;","link":"/2020/03/15/bigdata-chapter-04/"},{"title":"[테스트 주도 개발] 13장_진짜로 만들기","text":"모든 중복을 제거하기 전에는 “5달러 + 5달러” 테스트는 끝난 것이 아니다. 코드 중복은 없지만, 가짜 구현에 있는 10 달러는 사실 테스트 코드에 있는 “5달러 + 5달러” 와 같다. 123Money reduce(Expression source, String to) { return Money.dollar(10);} 12345678@Testvoid testSimpleAddition() { Money five = Money.dollar(5); Expression sum = five.plus(five); // here Bank bank = new Bank(); Money reduced = bank.reduce(sum, &quot;USD&quot;); assertEquals(Money.dollar(10), reduced);} 이전에는, 가짜 구현이 있을 때 진짜 구현으로 작업해가는 것이 명확했다. 이번에는 어떻게 거꾸로 작업해야할지 명확하지 않다. 그래서 조금 불확실하지만 순방향으로 작업해보자.우선, Money.plus() 는 그냥 Money 가 아닌, Expression(Sum) 을 반환해야한다. 두 Money 의 합은 Sum 이어야한다. 12345678@Testvoid testPlusReturnsSum(){ Money five = Money.dollar(5); Expression result = five.plus(five); Sum sum = (Sum) result; assertEquals(five, sum.augend); assertEquals(five, sum.addend);} 위 코드를 컴파일하기위해서는, augend, addend 필드를 가진 Sum 클래스가 필요하다. 1234class Sum { Money augend; Money addend;} 다시 실행해보면, Money.plus() 는 Sum 이 아닌 Money 를 반환하게 되어 있어서, ClassCastExceptoin 을 발생시킨다. 그래서, 다음 처럼 수정하자. 1234// MoneyExpression plus(Money addend){ return new Sum(this, addend)} Sum 생성자도 필요하다. 12345678class Sum { Money augend; Money addend; Sum(Money augend, Money addend) { }} 그리고 Sum 은 Expression 의 일종이어야한다. 12345678class Sum implements Expression{ Money augend; Money addend; Sum(Money augend, Money addend) { }} 이제 컴파일 되는 상태이지만, 테스트는 여전히 실패한다. 왜냐하면, Sum 생성자에서 필드를 설정하지 않았기 때문이다. 123456789class Sum implements Expression{ Money augend; Money addend; Sum(Money augend, Money addend) { this.augend = augend; this.addend = addend; }} 이제 Bank.reduce() 는 Sum 을 전달받는다. 1234567@Testvoid testReduceSum(){ Expression sum = new Sum(Money.dollar(3), Money.dollar(4)); Bank bank = new Bank(); Money result = bank.reduce(sum, &quot;USD&quot;); assertEquals(Money.dollar(7), result);} 위 테스트는 테스트가 깨지도록 인자를 선택했다. Bank 클래스를 수정하자. 12345678class Bank { Money reduce(Expression source, String to) { Sum sum = (Sum) source; int amount = sum.augend.amount + sum.addend.amount; return new Money(amount, to); }} 위 코드는 다음 이유로 지저분하다. Casting. 위 코드는 모든 Expression 에 대해 작동해야한다. public 필드와 그 필드들에 대한 두 단계에 걸친 레퍼런스. 우선, 외부에서 접근 가능한 필드 몇개를 들어내기 위해 메서드 본문을 Sum 으로 옮길 수 있다. 1234567class Bank { Money reduce(Expression source, String to) { Sum sum = (Sum) source; return sum.reduce(to); }} 1234567891011121314class Sum implements Expression { Money augend; Money addend; Sum(Money augend, Money addend) { this.augend = augend; this.addend = addend; } Money reduce(String to) { int amount = augend.amount + addend.amount; return new Money(amount, to); }} 다음 테스트를 작성하자. 123456@Testvoid testReduceMoney() { Bank bank = new Bank(); Money result = bank.reduce(Money.dollar(1), &quot;USD&quot;); assertEquals(Money.dollar(1), result);} 12345678class Bank { Money reduce(Expression source, String to) { if (source instanceof Money) return (Money) source; Sum sum = (Sum) source; return sum.reduce(to); }} 초록 막대이다. 리펙토링을 하자.클래스를 명시적으로 검사하는 코드가 있을 때에는 항상 다형성을 사용하자. Sum 은 reduce(Stirng) 을 구현하므로, Money 도 그것을 구현하게 하면 reduce 를 Expression 인터페이스에 추가할 수 있다. 12345678class Bank { Money reduce(Expression source, String to) { if (source instanceof Money) return (Money) source.reduce(to); Sum sum = (Sum) source; return sum.reduce(to); }} 1234//Moneypublic Money reduce(String to){ return this;} 이제, Expression 인터페이스에 reduce(String) 을 추가하자. 123interface Expression { Money reduce(String to);} 지저분한 캐스팅과 클래스 검사 코드를 제거할 수 있다. 123456class Bank { Money reduce(Expression source, String to) { return source.reduce(to); }} Expression 과 Bank 에 이름이 동일하지만 매개 변수 형이 다른 메서드가 있다는 것이 만족스럽지 않다. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/16/tdd-chapter-13/"},{"title":"[테스트 주도 개발] 14장_바꾸기","text":"이번에는 2프랑을 달러로 바꾸고 싶다. 1234567@Testvoid testReduceMoneyDifferentCurrency(){ Bank bank = new Bank(); bank.addRate(&quot;CHF&quot;, &quot;USD&quot;, 2); Money result = bank.reduce(Money.franc(2), &quot;USD&quot;); assertEquals(Money.dollar(1), result);} 프랑을 달러로 바꿀때 나누기 2를 하자. 다음 코드를 추가하자. 123456// Moneypublic Money reduce(String to){ int rate = (currency.equals(&quot;CHF&quot;) &amp;&amp; to.equals(&quot;USD&quot;)) ? 2 : 1; return new Money(amount / rate, to);} 환율에 대한 일은 모두 Bank 가 처리해야한다. Expression.reduce() 의 인자로 Bank 를 넘겨야할 것이다. 우선 호출하는 부분을 작성하자. 123456class Bank { Money reduce(Expression source, String to) { return source.reduce(this, to); }} 그리구 구현 부분, 123interface Expression { Money reduce(Bank bank, String to);} 1234567891011121314class Sum implements Expression { Money augend; Money addend; Sum(Money augend, Money addend) { this.augend = augend; this.addend = addend; } public Money reduce(Bank bank, String to) { int amount = augend.amount + addend.amount; return new Money(amount, to); }} 123456// Moneypublic Money reduce(Bank bank, String to){ int rate = (currency.equals(&quot;CHF&quot;) &amp;&amp; to.equals(&quot;USD&quot;)) ? 2 : 1; return new Money(amount / rate, to);} 이제 환율을 Bank 에서 계산할 수 있다. 12345678910class Bank { Money reduce(Expression source, String to) { return source.reduce(this, to); } int rate(String from, String to){ return (from.equals(&quot;CHF&quot;) &amp;&amp; to.equals(&quot;USD&quot;)) ? 2 : 1; }} 그리고 환율을 Bank 에게 물어보자. 123456//Moneypublic Money reduce(Bank bank, String to){ int rate = bank.rate(currency,to); return new Money(amount / rate, to);} 2 가 아직도 테스트 코드 두 부분에 나온다. 이를 없애기 위해서, Bank 에서 환율표를 가지고 있다가 필요할 때 찾아볼 수 있게 하자. 두 개의 통화와 환율을 매핑하는 Hash Table 을 사용할 수 있다.통화 쌍을 해쉬 테이블의 키로 쓰기 위해 배열을 사용할 수 있을까 ? Array.equlas() 가 각각의 원소에 대해 동치성 검사를 수행하나 ? 테스트 코드를 만들어보자. 1234@Testvoid testArrayEquals() { assertEquals(new Object[]{&quot;abc&quot;}, new Object[]{&quot;abc&quot;});} 테스트가 실패한다. 키를 위한 객체를 따로 만들자. 123456789class Pair { private String from; private String to; public Pair(String from, String to) { this.from = from; this.to = to; }} 우린 위 클래스를 키로 쓸거니까, equals() 와 hashCode() 를 구현해야한다. 지금은 리팩토링하는 중에 코드를 작성하는 것이기 때문에, 테스트를 작성하지 않을 것이다. 이 리팩토링을마치고 모든 테스트를 통과하면, 그 코드가 실제로 사용되었다고 생각할 수 있다. 123456789101112131415161718class Pair { private String from; private String to; public Pair(String from, String to) { this.from = from; this.to = to; } public boolean equals(Object object){ Pair pair = (Pair) object; return from.equals(pair.from) &amp;&amp; to.equals(pair.to); } public int hashCode() { return 0; }} 0은 최악의 해쉬코드이다. 하지만, 구현이 쉽고 우리가 빨리 달리수 있다. 해시 코드를 이대로 두면 해쉬 테이블에서의 검색이 선형 검색과 비슷하게 수행될 것이다. 많은 통화를 다뤄야 한다면 실제 측정 데이터를 가지고 개선하자.일단, 환율을 저장할 뭔가가 필요하다. 그리고, 환율을 설정할 수 있어야한다. 123456789101112131415class Bank { private Hashtable rates = new Hashtable(); Money reduce(Expression source, String to) { return source.reduce(this, to); } int rate(String from, String to){ return (from.equals(&quot;CHF&quot;) &amp;&amp; to.equals(&quot;USD&quot;)) ? 2 : 1; } public void addRate(String from, String to, int rate) { rates.put(new Pair(from, to), new Integer(rate)); }} 그리고, 필요할 때 환율을 얻을 수 있어야한다. 12345678910111213141516class Bank { private Hashtable rates = new Hashtable(); Money reduce(Expression source, String to) { return source.reduce(this, to); } int rate(String from, String to){ Integer rate = (Integer) rates.get(new Pair(from, to)); return rate.intValue(); } public void addRate(String from, String to, int rate) { rates.put(new Pair(from, to), new Integer(rate)); }} 빨간 막대다. USD 에서 USD 로의 환율을 요청하면, 그 값이 1이 되어야한다고 기대한다는 것을 알 수 있다. 뜻 밖의 일이므로, 발견한 내용을 나중에 코드를 읽어볼 다른 사람에게도 알려주기 위해 테스트로 만들자.이제 에러가 두개다. 다음 처럼 수정하자. 초록 막대 ~ 123456789101112131415161718class Bank { private Hashtable rates = new Hashtable(); Money reduce(Expression source, String to) { return source.reduce(this, to); } int rate(String from, String to){ if ( from.equals(to)) return 1; Integer rate = (Integer) rates.get(new Pair(from, to)); return rate.intValue(); } void addRate(String from, String to, int rate) { rates.put(new Pair(from, to), new Integer(rate)); }} 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/16/tdd-chapter-14/"},{"title":"[테스트 주도 개발] 15장_서로 다른 통화 더하기","text":"이제 드디어, “5달러 + 10프랑” 테스트할 준비가 모두 되었다.우리가 원하는 코드는, 1234567891011@Testvoid testMixedAddition() { Expression fiveBucks = Money.dollar(5); Expression tenFrancs = Money.franc(10); Bank bank = new Bank(); bank.addRate(&quot;CHF&quot;, &quot;USD&quot;, 2); Money result = bank.reduce( fiveBucks.plus(tenFrancs), &quot;USD&quot; ); assertEquals(Money.dollar(10), result);} 컴파일 에러가 많다. 천천히 해결하자. 1234567891011@Testvoid testMixedAddition() { Money fiveBucks = Money.dollar(5); Money tenFrancs = Money.franc(10); Bank bank = new Bank(); bank.addRate(&quot;CHF&quot;, &quot;USD&quot;, 2); Money result = bank.reduce( fiveBucks.plus(tenFrancs), &quot;USD&quot; ); assertEquals(Money.dollar(10), result);} 실패한다. 10 USD 대신, 15 USD 가 나왔다. Sum.reduce() 가 인자를 축약하지 않은 것으로 보인다. 다음과 같이 두 인자를 모두 축약하자. 123456789101112131415class Sum implements Expression { Money augend; Money addend; Sum(Money augend, Money addend) { this.augend = augend; this.addend = addend; } public Money reduce(Bank bank, String to) { int amount = augend.reduce(bank, to).amount + addend.reduce(bank, to).amount; return new Money(amount, to); }} 그리고, Expression 이어야하는 Money 들을 조금씩 없앨 수 있다. 123456789101112131415class Sum implements Expression { Expression augend; Expression addend; Sum(Expression augend, Expression addend) { this.augend = augend; this.addend = addend; } public Money reduce(Bank bank, String to) { int amount = augend.reduce(bank, to).amount + addend.reduce(bank, to).amount; return new Money(amount, to); }} Money 의 plus() 인자도 바꾸자. 123Expression plus(Expression addend){ return new Sum(this, addend);} 테스트 케이스에 나오는 plus() 의 인자를 다음 처럼 바꾸자. 1234567891011@Testvoid testMixedAddition() { Money fiveBucks = Money.dollar(5); Expression tenFrancs = Money.franc(10); Bank bank = new Bank(); bank.addRate(&quot;CHF&quot;, &quot;USD&quot;, 2); Money result = bank.reduce( fiveBucks.plus(tenFrancs), &quot;USD&quot; ); assertEquals(Money.dollar(10), result);} fiveBucks 를 Expression 으로 바꾸고 나면, 몇 군데 수정해야한다. 컴파일러가 할 일 목록을 제공하기 때문에 우린 계속 집중할 수 있다. 1234567891011@Testvoid testMixedAddition() { Expression fiveBucks = Money.dollar(5); Expression tenFrancs = Money.franc(10); Bank bank = new Bank(); bank.addRate(&quot;CHF&quot;, &quot;USD&quot;, 2); Money result = bank.reduce( fiveBucks.plus(tenFrancs), &quot;USD&quot; ); assertEquals(Money.dollar(10), result);} 컴파일러가 Expression 에 plus() 가 정의되어 있지 않다고 한다. 정의하자. 12345interface Expression { Money reduce(Bank bank, String to); Expression plus(Expression addend);} 이제 Money 와 Sum 에도 추가하자. Money 에서는 기존에도 있었다. public 으로 해주자. 123public Expression plus(Expression addend){ return new Sum(this, addend);} Sum 에는 스텁 구현으로 하자. 1234@Overridepublic Expression plus(Expression addend) { return null;} 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/16/tdd-chapter-15/"},{"title":"[테스트 주도 개발] 16장_드디어, 추상화","text":"Expression.plus 를 끝내려면, Sum.plus() 를 구현해야한다. 그리고, Expression.times() 를 구현하면 끝난다. 다음은 Sum.plus() 테스트다. 1234567891011@Testvoid testSumPlusMoney() { Expression fiveBucks = Money.dollar(5); Expression tenFrancs = Money.franc(10); Bank bank = new Bank(); bank.addRate(&quot;CHF&quot;, &quot;USD&quot;, 2); Expression sum = new Sum(fiveBucks, tenFrancs).plus(fiveBucks); Money result = bank.reduce(sum, &quot;USD&quot;); assertEquals(Money.dollar(15), result);} 테스트가 코드보다 더 길다. 그리고 코드는 Money 의 코드와 똑같다. 12345//Sum@Overridepublic Expression plus(Expression addend) { return new Sum(this, addend);} 일단, Sum.times() 가 작동하게 된다면, Expression.times() 를 선언하는 일은 쉽다. 테스트는, 12345678910@Testvoid testSumTimes(){ Expression fiveBucks = Money.dollar(5); Expression tenFrancs = Money.franc(10); Bank bank = new Bank(); bank.addRate(&quot;CHF&quot;, &quot;USD&quot;, 2); Expression sum = new Sum(fiveBucks, tenFrancs).times(2); Money result = bank.reduce(sum, &quot;USD&quot;); assertEquals(Money.dollar(20), result);} 123456//SumExpression times(int multiplier) { return new Sum( augend.times(multiplier), addend.times(multiplier) );} 이제 컴파일되게 만들려면, Expression 에 times() 를 선언해야한다. 1234567interface Expression { Money reduce(Bank bank, String to); Expression plus(Expression addend); Expression times(int multiplier);} 위 작업 때문에, Money.times() 와 Sum.times() 의 가시성을 높여야한다. 1234//Moneypublic Money times(int multiplier) { return new Money(amount * multiplier, currency);} 123456//Sumpublic Expression times(int multiplier) { return new Sum( augend.times(multiplier), addend.times(multiplier) );} 테스트가 통과한다. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/16/tdd-chapter-16/"},{"title":"[테스트 주도 개발] 17장_Money 회고","text":"1. 다음에 할 일은 무엇인가Sum.plus() 와 Money.plus() 사이에 중복이 남았다. Expressoin 을 인터페이스가 아니라 클래스가 바꾼다면 공통 코드를 담아낼 적절한 곳이 될 것이다.작업을 끝낸 후에 SmallLint 같은 코드 감정 프로그램을 실행해보면 좋다.“다음에 할일은 무엇인가” 에 관련된 또 다른 질문은 “어떤 테스트들이 추가로 필요할까” 이다.할일 목록이 빌 때가 그때까지 설계한 것을 검토하기에 적절한 시기이다. 말과 개념이 잘 통하는가 ? 현재의 설꼐로 제거하기 힘든 중복이 있는가 ? 2. 메타포“통화가 다른 여러 금전” 에 대해 사용한 메타포는 벡터였다. 그 전엔, MoneySum 을 사용하다가 적절하고 물리전인 MoneyBag 으로 바꿨다. 그리고 마지막에는 많은 사람에게 익숙한 Wallet 으로 바꿧다. 이 모든 메타포는 Money 의 집합이 딱 떨어지는숫자로 된다는 것을 암시하다. 즉, 같은 통화의 값은 합칠 수 있다. (2USD + 3USD + 5CHF = 5USD + 5CHF)Expression 메타포는 중복되는 통화를 합치는 세세한 일단의 문제에서 해방시켰다. 코드도 그 어느 때보다 명확하다. 3. 코드 메트릭스 코드와 테스트 사이에 대략 비슷한 양의 함수와 줄이 있다. 테스트 코드에 분기나 반복문이 없기 때문에 테스트 복잡도는 1 이다. 명시적인 흐름 제어 대신에 다형성을 사용해서 실제 코드의 복잡도 역시 낮다. 4. 프로세스TDD 의 주기는, 작은 테스트 추가 모든 테스트 실행, 실패 하는 것 확인 코드에 변화 모든 테스트 실행, 성공 하는 것 확인 중복 제거 위해 리펙토링 5. 테스트의 질TDD 의 부산불로 생기는 테스트들은 다음과 같은 종류의 테스트를 대체할 수는 없다. 성능 테스트 스트레스 테스트 사용성 테스트 이 테스트에 사용하는 지표로는 다음이 있다. 명령문 커버리지테스트의 질에 대한 충분한 평가 기준이 될수 없지만, 테스트의 시작점이다. 결함 삽입테스트의 질을 평가하는 또 다른 방법이다. 코드의 의미를 바꾼 후에 테스트가 실패하는지 보는 것이다. 수동으로 할 수 있지만, Jester 같은 툴을 사용할 수 있다. 테스트 커버리지를 향상 시키는 방법으로는, 더 많은 테스트를 작성. 테스트의 수는 그대로 두면서, 프로그램의 로직을 단순화. 리펙토링 단계가 이런 효과를 종종 가져온다. 6. 최종 검토 테스트를 확실히 돌아가게 만드는 세 가지 접근법가짜로 구현, 삼각 측량법, 명백하게 구현 설계를 주도하기 위한 방법으로 테스트 코드와 실제 코드 사이의 중복 제거하기 길이 미끄러우면 속도를 줄이고, 상황이 좋으면 속도를 높여라. 테스트 사이의 간격을 조절해라 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/17/tdd-chapter-17/"},{"title":"[테스트 주도 개발] 18장_xUnit 으로 가는 첫걸음","text":"2부는 테스트 주도 개발을 통해 테스트 프레임워크를 만들어 본다. 다음은 테스트 프레임워크에 대한 할일 목록이다. 테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 먼저, 테스트 메서드가 호출되면 true, 그렇지 않으면 false 를 반환할 작은 프로그램이 필요하다. 플래그를 가진 테스트 케이스를 만들것이다. 테스트 메서드가 실행되기 전에는 플래그가 false 이다. 실행된 이후에는 true 이다. 메서드가 실행되었는지 알려주는 테스크 케이스이므로 클래스 이름은 WasRun 으로 하자. 1234test = WasRun(&quot;testMethod&quot;)print test.wasRuntest.testMethod()print test.wasRun 위 코드는, 메서드가 실행되기 전에는 “None” 을 출력, 그 후에 “1” 을 출력할 것으로 예상된다. 하지만, 아니다. 아직 WasRun 클래스를 정의하지 않았다.WasRun 클래스 정의하자. 123class WasRun: def __init__(self, name): self.wasRun = None 이제, 실행하면 “None” 을 출력하고, testMethod 를 정의해야한다고 알려준다. 정의하자. 123456class WasRun: def __init__(self, name): self.wasRun = None def testMethod(self): self.wasRun = 1 이제 필요한 것은, 테스트 메서드를 직접 호출하는 대신 인터페이스인 run() 메서드를 이용하는 것이다. 테스트는 다음과 같이 변한다. 1234test = WasRun(&quot;testMethod&quot;)print test.wasRuntest.run()print test.wasRun run 을 추가하자. 123456789class WasRun: def __init__(self, name): self.wasRun = None def testMethod(self): self.wasRun = 1 def run(self): self.testMethod() 그리고 실행하면, 다시 올바른 값을 출력한다. 다음 단계는, testMethod() 를 동적으로 호출하는 것이다. 다음과 같다. 12345678class WasRun: def __init__(self, name): self.wasRun = None self.name = name def run(self): method = getattr(self, self.name) method() 이제 WasRun 클래스는 두 가지 일을 한다. 메서드가 호출되었는지 아닌지 기억하는 일 메서드를 동적으로 호출 이제, TestCase 상위 클래스를 만들고 WasRun 이 이것을 상속받게 하자. 123class TestCase: def __init__(self, name): self.name = name 1234class WasRun(TestCase): def __init__(self, name): self.wasRun = None TestCase.__init__(self, name) 마지막으로, run() 메서드는 상위 클래스에 있는 속성만을 사용하므로 상위 클래스로 올리자. 1234567class TestCase: def __init__(self, name): self.name = name def run(self): method = getattr(self, self.name) method() 테스트 실행 성공한다. 이제 다음과 같이 바꾸자. 12345678class TestCaseTest(TestCase): def testRunning(self): test = WasRun(&quot;testMethod&quot;) assert(not test.wasRun) test.run() assert(test.wasRun)TestCaseTest(&quot;testRunning&quot;).run() 테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/24/tdd-chapter-18/"},{"title":"[테스트 주도 개발] 19장_테이블 차리기","text":"테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 테스트 작성에는 다음 패턴이 있다. 준비 : 객체 생성 행동 : 어떤 자극 주기 확인 : 결과 검사 두, 세 번째는 항상 다르지만, 처음 단계는 여러 테스트에 걸쳐 동일한 경우가 있다.테스트 커플링을 만들지 말자.테스트 실행전에 우리는 어떤 플래그를 거짓으로 두기 원했다. 발전시키자. 12345678910class TestCaseTest(TestCase): def setUp(self): self.test = WasRun(&quot;testMethod&quot;) def testRunning(self): self.test.run() assert(self.test.wasRun) def testSetUp(self): test = WasRun(&quot;testMethod&quot;) test.run() assert(self.test.wasSetUp) wasSetUp 속성이 없으니 세팅하자. 123class WasRun(TestCase): def setUp(self): self.wasSetUp = 1 setUp 호출하는 것은 TestCase 이니 이곳을 손보자. 1234567891011class TestCase: def __init__(self, name): self.name = name def setUp(self): pass def run(self): self.setUp() method = getattr(self, self.name) method() wasRun 플래그를 setUp 에서 설정하면 WasRun 을 단순화 할 수 있다. 1234class WasRun(TestCase): def setUp(self): self.wasRun= None self.wasSetUp = 1 123456789class TestCaseTest(TestCase): def setUp(self): self.test = WasRun(&quot;testMethod&quot;) def testRunning(self): self.test.run() assert(self.test.wasRun) def testSetUp(self): self.test.run() assert(self.test.wasSetUp) 테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/24/tdd-chapter-19/"},{"title":"[테스트 주도 개발] 20장_뒷정리하기","text":"테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 WasRun 에 로그 문자열 남기기 setUp() 은 테스트 메서드 실행되기 전에 호출, tearDown() 은 테스트 메서드가 실행된 후에 호출되어야한다. 12345class WasRun(TestCase): def setUp(self): self.wasRun= None self.wasSetUp = 1 self.log = &quot;setUp&quot; 이제 testSetUp이 플래그 대신 로그를 검사하자. 1234class TestCaseTest(TestCase): def testSetUp(self): self.test.run() assert(&quot;sepUp&quot; == self.test.log) 1234class TestCaseTest(TestCase): def testSetUp(self): self.test.run() assert(&quot;sepUp testMethod&quot; == self.test.log) 이제 testSetUp 의 이름을 바꾸자. 12345class TestCaseTest(TestCase): def testTemplateMethod(self): teset = WasRun(&quot;testMethod&quot;) test.run() assert(&quot;sepUp testMethod&quot; == self.test.log) 테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 WasRun 에 로그 문자열 남기기 이제 tearDown() 을 테스트할 준비가 됐다. 12345class TestCaseTest(TestCase): def testTemplateMethod(self): teset = WasRun(&quot;testMethod&quot;) test.run() assert(&quot;sepUp testMethod tearDown&quot; == self.test.log) 123456class TestCase: def run(self): self.setUp() method = gatattr(self, self.name) method() self.tearDown() 테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 WasRun 에 로그 문자열 남기기 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/24/tdd-chapter-20/"},{"title":"[빅데이터] 5장_일괄처리 계층의 데이터 저장소 : 사례","text":"HDFS 를 사용하는 방법과, 상위 수준 API 를 사용하여 필요한 작업을 자동화하는 방법을 정리한다. 항상 그랬듯이, 도구를 비교하는 것이 아니라 상위 수준의 개념을 보강하는 것이 목적이다. 5.1 하둡 분산 파일 시스템 사용하기HDFS 의 동작 방식을 정리하면, 파일은 블록으로 쪼개져서 클러스터에 있는 여러 노드로 퍼뜨려진다. 블록은 여러 노드로 복제되어서 장비가 다운되어도 데이터는 여전히 사용 가능하다. 네임노드는 각 파일이 어떤 블록으로 구성되는지와, 그 블록이 어디에 저장되어 있는지를 추적한다. 파일과 폴더를 조작하는 HDFS API 사용법을 보자. 서버에 로그인한 정보를 모두 저장한다고 하자. 12345$ cat logins-2020-03-31.txtjko 192.168.12.125 Thu Mar 31 22:33 - 22:46jh 192.168.12.125 Thu Mar 31 21:15 - 22:42ko 192.168.12.125 Thu Mar 31 23:31 - 22:13jko 192.168.12.125 Thu Mar 31 22:33 - 22:43 이 데이터를 HDFS 에 저장하려면 데이터 집합 저장용 디렉토리를 우선 만들고 올리면 된다. 파일을 올리면 자동으로 블록으로 쪼개져서 여러 데이터 노드 사이에 분산된다. 12$ haddop fs -mkdir /logins$ haddop fs -put logins-2020-03-31.txt /logins 5.1.1 작은 파일 문제하둡은 데이터가 HDFS 상의 여러 작은 파일에 저장되어있을 때는, 계산 성능이 떨어지는 특성이 있다.그 원인은, 맵리듀스 작업이 입력 데이터 집합의 각 블록마다 테스크를 하나씩 실행하기 때문이다. 각 테스크는 실행을 계획하고 조정하는 오버헤드를 소모하는데, 각각의 작은 파일은 독립적인 테스크에서 실행되어야하므로, 그 비용은 반복적으로 발생한다. 5.1.2 상위 수준 추상화를 향하여솔루션이란, 확장성 있고 내결함성을 지니며 성능이 좋아야하며 우아해야한다. ( = 관심 있는 계산을 간결하게 표현할 수 있는 부분이 있어야한다. ) 지난 장에서, 마스터 데이터 집합을 조작할 때, 다음 두 중요한 연산을 살펴봤다. 새로운 데이터를 데이터 집합에 추가하기 데이터 집합에 수직 분할을 적용하고 기존의 분할이 깨지는 것을 방지하기 이제 여기에, HDFS 의 요구사항을 추가하자. 작은 파일을 효율적으로 큰 파일로 통합할 수 있어야 한다는 것이다.앞 장에서 봤듯이, 파일과 폴더를 직접 다루어서 작업을 하기에는 불편하고 오류가 발생하기 쉽다. 우아한 방식의 Pail 이란 라이브러리 살펴보자. Pail 을 사용하면, 코드 한 줄로 폴더를 추가하거나 작은 파일들을 통합 할 수 있다. [잠깐 뒤돌아 보기] 큰 관점으로 살펴보자. 마스터 데이터 집합은 람다 아키텍쳐에서 모든 정보의 원천이다. 일괄 처리 계층은 거대하고 꾸준히 증가하는 데이터 집합을 문제없이 처리해야한다. 실제 질의에 응답하기 위해서, 데이터를 일괄 처리 뷰로 변환하는 쉽고 효율적인 수단이 있어야한다. 5.2 페일을 사용하여 일괄처리 계층에 데이터를 저장하기페일은 dfs-datasource 라이브러리에 포함된 것으로, 파일과 폴더를 얇게 추상화한것이다. 이 추상화를 통해 일괄처리에 사용할 레코드 집합을 관리하기가 쉬워진다. 페일의 목적은, 우리가 신경써야 할 연산 ( 데이터 집합에 새로운 데이터 추가하기, 수직 분할, 파일 통합 ) 을 안전하고 쉽고 성능 기준에 맞게 수행할 수 있도록 해준다.내부적으로 페일은, 표준 하둡 API 를 사용하는 자바 라이브러리일 뿐이다. 하위 수준 파일 시스템 상호 작용을 처리하며 하둡 내부 구조의 복잡성을 감추는 API 를 제공한다.페일을 살펴볼 때는, 어떻게 HDFS 의 장점을 보존하면서 데이터에 대한 연산을 간소화하는지를 기억해두어야한다. 빅데이터, 람다 아키텍처로 알아보는 실시간 빅데이터 구축의 핵심 원리와 기법 &lt;네이선 마츠, 제임스 워렌&gt;","link":"/2020/03/31/bigdata-chapter-05/"},{"title":"[테스트 주도 개발] 21장_셈하기","text":"테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 WasRun 에 로그 문자열 남기기 테스트 메서드에에서 예외가 발생하건 말건 tearDown() 이 호출되도록 구현했다. 하지만,테스트가 작동하기 위해선 예외를 작아야한다.여러 테스트를 실행하고 그 결과를 다음과 같이 보길 원한다.“5개 테스트가 실행됨. 2개 실패. TestCaseTest.testFooBar-ZeroDivide Exception, MoneyTest.testNegation-AssertionError”TestCase.run()이 테스트 하나의 실행 결과를 기록하는 TestResult 객체를 반환하게 만들자. 12345// TestCaseTestdef test_result(self): test = WasRun(&quot;testMethod&quot;) result = test.run() assert(&quot;1 run, 0 failed&quot; == result.summary()) 가짜 구현하자. 123class TestResult: def summary(self): return &quot;1 run, 0 failed&quot; 이제 TestCase.run() 이 TestResult 를 결과로 반환한다. 1234567// TestCasedef run(self): self.setUp() method = getattr(self, self.name) method() self.tearDown() return TestResult() 이제 테스트가 실행된다. 이제 summary()의 구현을 실체화하자. 우선 실행된 테스트의 수를 상수로 만들자. 12345// TestResuldef __init__(self): self.runCount = 1def summary(self): return &quot;%d run, 0 failed&quot; % self.runCount runCount를 0으로 초기화하고 테스트가 실행될 때마다 1씩 증가하도록 만들 수 있다. 1234567// TestResultdef __init__(self): self.runCount = 0def testStarted(self): self.runCount = self.runCount + 1def summary(self): return &quot;%d run, 0 failed&quot; % self.runCount 이제, 새 메서드를 실제로 호출하게 하자. 123456789// TestCasedef run(self): result = TestResult() result.testStarted() self.setUp() method = getattr(self, self.name) method() self.tearDown() return result 실패하는 테스트의 수를 나타내는 문자열 상수 ‘0’을 runCount 를 실체화했을 때와 마찬가지의 방법을 통해 변수로 만들 수는 있겠다.하지만, 이 작업을 하게끔 만들어주는 테스트가 없다. 그러니 또 다른 테스트를 하나 작성하자. 123456789// TestCaseTest classdef testFailedResult(self): test = WasRun(&quot;testBrokenMethod&quot;) result = test.run() assert (&quot;1 run, 1 failed&quot; == result.summary())// WasRun classdef testBrokenMethod(self): raise Exception 테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 WasRun 에 로그 문자열 남기기 실패한 테스트 보고하기 우리가 관심을 가져야 할 사항은, WasRun.testBrokenMethod에서 던진 예외를 처리하지 않았다는 것이다. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/31/tdd-chapter-21/"},{"title":"[테스트 주도 개발] 22장_실패 처리하기","text":"테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 WasRun 에 로그 문자열 남기기 실패한 테스트 보고하기 실패한 테스트를 발견하면, 세밀한 단위의 테스트를 작성해서 올바른 결과를 출력해보자. 123456// TestCaseTestdef testFailedResultFormatting(self): result = TestResult() result.testStarted() result.testFailed() assert (&quot;1 run, 1 failed&quot; == result.summary()) 실패 횟수를 세어보자. 123456// TestResultdef __init__(self): self.runCount = 0 self.failureCount = 0def testFailed(self): self.failureCount = self.failureCount + 1 이제 출력하자. 123// TestResultdef summary(self): return &quot;%d run, %d failed&quot; % (self.runCount, self.failureCount) 이제 테스트 메서드에서 예외를 잡으면, testFailed() 를 호출하자. 12345678910111213// TestCasedef run(self): result = TestResult() result.testStarted() self.setUp() try: method = getattr(self, self.name) method() except: result.testFailed() self.tearDown() return result run() 에는 문제가 있다. 바로 setUp()에서 문제가 발생한 경우에는 예외가 잡히지 않는다는 것이다. todo list 에 넣어두자. 테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 WasRun 에 로그 문자열 남기기 실패한 테스트 보고하기 setUp 에러 잡아서 보고하기 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/31/tdd-chapter-22/"},{"title":"[테스트 주도 개발] 23장_얼마나 달콤한지","text":"테스트 메서드 호출하기 먼저 setUp 호출하기 나중에 tearDown 호출하기 테스트 메서드가 실패해도 tearDown 호출하기 여러 개의 테스트 실행하기 수집된 결과를 출력하기 WasRun 에 로그 문자열 남기기 실패한 테스트 보고하기 setUp 에러 잡아서 보고하기 테스트들을 모두 모아서 한 번에 실행하고 싶다. TestSuite 가 필요하다. 1234567// TestCaseTestdef testSuite(self): suite = TestSuite() suite.add(WasRun(&quot;testMethod&quot;)) suite.add(WasRun(&quot;testBrokenMethod&quot;)) result = suite.run() assert (&quot;2 run, 1 failed&quot; == result.summary()) add() 메서드를 구현은, 테스트들을 리스트에 추가하는 것으로 된다. 123456class TestSuite: def __init__(self): self.tests = [] def add(self, test): self.tests.append(test) run() 메서드는, 하나의 TestResult가 모든 테스트에 대해 쓰이길 바라기 때문에 다음과 같이 작성해야 한다. 123456// TestSuitedef run(self): result = TestResult() for test in self.tests: test.run(result) return result 만약 TestCase.run() 에 매개변수를 추가하면, TestSuite.run() 에도 똑같은 매개 변수를 추가해야 한다. 123456789// TestCaseTestdef testSuite(self): suite = TestSuite() suite.add(WasRun(&quot;testMethod&quot;)) suite.add(WasRun(&quot;testBrokenMethod&quot;)) result = TestResult() suite.run(result) assert (&quot;2 run, 1 failed&quot; == result.summary()) 이 방법은, run() 이 무언가를 명시적으로 반환하지 않아도 된다는 장점이 있다. 12345678910111213141516// TestSuite classdef run(self, result): for test in self.tests: test.run(result)// TestCase classdef run(self, result): result.testStarted() self.setUp() try: method = getattr(self, self.name) method() except: result.testFailed() self.tear_down() 123456789suite = TestSuite()suite.add(TestCaseTest(&quot;testTemplateMethod&quot;))suite.add(TestCaseTest(&quot;testResult&quot;))suite.add(TestCaseTest(&quot;testFailedResultFormatting&quot;))suite.add(TestCaseTest(&quot;testFailedResult&quot;))result = TestResult()suite.run(result)print(result.summary()) 우선, 실패하는 테스트 3 개를 고치자. 123456789101112131415161718// TestCaseTest classdef testTemplateMethod(self): test = WasRun(&quot;testMethod&quot;) result = TestResult() test.run(result) assert &quot;setUp testMethod tearDown &quot; == test.logdef testResult(self): test = WasRun(&quot;testMethod&quot;) result = TestResult() test.run(result) assert &quot;1 run, 0 failed&quot; == result.summary()def test_failed_result(self): test = WasRun(&quot;TestBrokenMethod&quot;) result = TestResult() test.run(result) assert &quot;1 run, 1 failed&quot; == result.summary() 각 테스트들이 TestResult 를 할당하고 있다는 것을 주목하자.이제, TestResult 를 setUp 에서 생성하면 만들면 테스트를 단순화된다. 123456789101112131415161718192021222324252627282930// TestCaseTestdef setUp(self): self.result = TestResult()def testTemplateMethod(self): test = WasRun(&quot;testMethod&quot;) test.run(self.result) assert &quot;setUp testMethod tearDown &quot; == test.logdef testResult(self): test = WasRun(&quot;testMethod&quot;) test.run(self.result) assert &quot;1 run, 0 failed&quot; == self.result.summary()def testFailedResult(self): test = WasRun(&quot;testBrokenMethod&quot;) test.run(self.result) assert &quot;1 run, 1 failed&quot; == self.result.summary()def testFailedResultFormatting(self): self.result.testStarted() self.result.testFailed() assert &quot;1 run, 1 failed&quot; == self.result.summary()def testSuite(self): suite = TestSuite() suite.add(WasRun(&quot;testMethod&quot;)) suite.add(WasRun(&quot;testBrokenMethod&quot;)) suite.run(self.result) assert &quot;2 run, 1 failed&quot; == self.result.summary() 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/31/tdd-chapter-23/"},{"title":"[테스트 주도 개발] 24장_xUnit 회고","text":"xUnit을 사용하다 보면 assertion 의 실패와 나머지 종류의 에러 사이에 큰 차이점을 알게된다. 일반적으로 assertion failure가 디버깅 시간을 더 많이 잡아먹는다.JUnit은 간단한 Test Interface 를 선언하는데 TestCase와 TestSuite 모두 이를 상속받는다. 만약 JUnit 도구가 테스트를 실행하게 만들고 싶으면, Test 인터페이스만 구현하면 된다. 1234public interface Test { public abstract int countTestCases(); public abstract void run(TestResult result);} 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/03/31/tdd-chapter-24/"},{"title":"[테스트 주도 개발] 25장_테스트 주도 개발 패턴","text":"어떻게 테스트할 것인지에 대해 이야기하기 전에, 다음 질문들을 정리해보자. 테스트한다는 것은 무엇을 뜻하는가 ? 테스트를 언제 해야하는가 ? 테스트할 로직을 어떻게 고를 것인가 ? 테스트할 데이터를 어떻게 고를 것인가? 격리된 테스트테스트는 전체 애플리케이션을 대상으로 하는 것 보다, 작은 스케일로 하는게 좋다.각각의 테스트는 다른 테스트와 독립적이어야한다. 즉, 문제가 하나면 테스트도 하나만 실패해야하고 둘이면 두개만 실패해야한다.격리된 테스트가 내포하는 특징은, 테스트가 실행 순서에 독립적이게 된다는 것이다. 테스트를 격리하기 위한 작업은, 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다. 테스트 목록뭘 테스트 해야하나 ? 시작하기 전에 작석해야할 테스트 목록을 모두 적어둬라.우선 구현할 필요가 있는 모든 오퍼레이션의 사용 예들을 적어라. 그 다음, 이미 존재하지 않는 오퍼레이션에 대해서는 해당 오퍼레이션의 null 버젼 (아무 일도 하지 않는 버젼) 을 리스트에 적어라. 마지막으로 깔끔한 코드를 얻기 위해 이번 작업을 끝내기 전에 반드시 해야할 리펙토링 목록을 적어라. 테스트 우선테스트는 언제 작성하는 것이 좋은가 ? 테스트 대상이 되는 코드를 작성하기 직전에 작성해라. assertion 우선테스트 작성할 때 단언은 언제쯤 쓸까 ? 단언를 먼저 쓰고 시작하라.단언을 먼저 작성하면 작업을 단순하게 만들 수 있다. 소켓을 통해 다른 시스템과 통신하려고 한다고 해보자. 통신을 마친 후 소켓은 닫혀 있고, 소켓에서 문자열 abc 를 읽어와야한다고 하자. 12345@Testpublic void testCompleteTransaction(){ assertTrue(reader.isClosed()); assertEquals(&quot;abc&quot;, reply.contents());} 다음으로, reply 는 어디에서 오나? socket 이다. 123456@Testvoid testCompleteTransaction() { Buffer reply = reader.contents(); assertTrue(reader.isClosed()); assertEquals(&quot;abc&quot;, reply.contents());} 다음으로, 소켓은 어디에서 나오나 ? 다음 같이, 서버 접속할 때 생성된다. 1234567@Testvoid testCompleteTransaction() { Socket reader = new Socket(&quot;localhost&quot;, defaultPort()); Buffer reply = reader.contents(); assertTrue(reader.isClosed()); assertEquals(&quot;abc&quot;, reply.contents());} 물론 다음 처럼, 서버를 먼저 열어야한다. 12345678@Testvoid testCompleteTransaction() { Server writer = new Server(defaultPort(), &quot;abc&quot;); Socket reader = new Socket(&quot;localhost&quot;, defaultPort()); Buffer reply = reader.contents(); assertTrue(reader.isClosed()); assertEquals(&quot;abc&quot;, reply.contents());} 테스트 데이터테스트할 때 어떤 데이터를 사용해야하는가 ? 테스트를 읽을 때 쉽고 따라하기 좋은 데이터를 사용해라.만역, plus() 메서드를 구현한다면 2+2 대신에, 2+3 을 써라. 명백한 데이터데이터의 의도를 어떻게 표현하나 ? 테스트 자체에 예상되는 값과 실제 값을 포함하고, 이 둘 사이의 관계를 드러내기 위해 노력해라.입력으로 사용된 숫자와 예상되는 결과 사이의 관계를 드러내라. 프로그래밍이 쉬워지고 단언 부분에 수식을 써놓으면 다음에 무엇을 할지 쉽게 알게 된다. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/04/06/tdd-chapter-25/"},{"title":"[테스트 주도 개발] 26장_빨간 막대 패턴","text":"이 패턴들은 테스트를 언제 어디서 작성할 건지, 테스트 작성을 언제 멈출지에 대한 것이다. 한 단계 테스트목록에서 다음 테스트를 고를 때 무엇을 기준으로 골라야 할까? 새로운 무언가를 가르쳐 줄 수 있고, 구현할 수 있는 확신이 드는 테스트를 골라라. 시작 테스트어떤 테스트부터 시작하는게 좋을까? 오퍼레이션이 아무 일도 하지 않는 경우를 먼저 테스트해라. 설명 테스트자동화된 테스트가 널리 쓰이게 하려면 어떻게 해야할까? 테스트로 설명을 요청하고 테스트로 설명해라.예를 들어, 누군가 시퀀스 다이엄드램을 설명하라고 하면, 시퀀스 다이어그램의 모든 요소를 포함하는 테스트케이스를 작성해라. 학습 테스트외부에서 만든 소프트웨어에 대한 테스트를 작성해야 할 때도 있나? 패키지의 새로운 기능을 처음 사용해보기 전에 할 수 있다.자바의 모바일 정보 기기 프로파일 라이브러리르 기반으로 뭔가를 만든다고 하자. 그냥 바로 사용하는 대신 API 가 우리 예상대로 실행된다는 것을 확인해줄만한 테스트를 먼저 만들어라. 만약, 테스트가 통과하지 않으면 애플리케이션 역시 실행되지 않을것이므로 애플리케이션을 실행해볼 필요도 없다. 또 다른 테스트어떻게 하면 주제에서 벗어나지 않고 기술적인 논의를 계속할 수 있나 ? 주제와 무관한 아이디어가 떠오르면 이에 대한 테스트를 할일 목록에 적어놓고 다시 주제로 돌아가라. 회괴 테스트시스템 장애가 보고될 때 무슨 일을 해야하는가 ? 그 장애로 인해 실패하는 테스트, 그리고 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 가장 간단하게 작성해라.회귀 테스트를 작성할 때는 이 테스트를 작성해야한다는 사실을 어떻게 하면 애초에 알 수 있었을지 생각해봐라. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/04/06/tdd-chapter-26/"},{"title":"[테스트 주도 개발] 27장_테스팅 패턴","text":"이 패턴들은 더 상세한 테스트 작성법에 대한 것이다. 자식 테스트지나치게 큰 테스트 케이스를 어떻게 돌아갈 수 있을까 ? 원래 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트 케이스를 작성하고 그 작은 테스트케이스가 실행되도록 해라. 그 후에 다시 원래의 큰 테스트 케이스를 추가해라. Mock Object비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면 어떻게 해야할까 ? 상수를 반환하게끔 만든 속임수 버젼의 리소스를 만들면 된다.예를 들어, 데이터베이스는 시작 시간이 오래 걸린고 깨끗한 상태를 유지하기 어렵다. 그리고 만약 데이터베이스가 원격 서버에 있다면 테스트 성공 여부가 네트워크 상의 물리적인 영향을 받게 된다. 또, 데이터베이스는 개발 중 많은 오류의 원인이다. 해법은, 진짜 데이터베이스를 사용하지 않는 것이다.모의 객체를 사용하면 성능과 견고함 이외에, 가독성이 좋아진다. 또한, 가시성에 대해 고민하도록 격려해서 설계에서 커플링이 감소하도록 한다.하지만 모의 객체를 사용하면, 프로젝트에 위험 요소가 추가된다. 모의 객체가 진짜 객체와 동일하게 동작하지 않으면 어떻게 될까 ? 모의 객체용 테스트 집합을 진짜 객체가 사용 가능해질때 그대로 적용해서 이 위험을 줄일 수 있다. Crash Test Dummy호출되지 않을 것 같은 에러코드를 어떻게 테스트할 것인가 ? 실제 작업을 수행하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어서 호출한다.파일 시스템에 여유 공간이 없을 경우 발생할 문제에 대해 테스트를 해보자. 자바의 익명 내부 클래스는 테스트하기 원하는 메서드만이 오류를 발생하게끔 하기 위해 유용하다. 123456789101112131415@Testvoid testFileSystemError(){ File file = new File(&quot;foo&quot;) { public boolean createNeweFile() throws IOException { throw new IOException(); } }; try { saveAs(file); fail(); } catch (IOException e){ }} 깨진 테스트혼자서 프로그래밍할 때 프로그래밍 세션을 어떤 상태로 끝내는게 좋을까 ? 마지막 테스트가 깨진 상태로 끝내라.나중에 다시 코딩할 때, 어느 작업부터 시작할 것인지 명백히 알 수 있다. 전에 하고 있던 생각에 대한 명확하고 구체적인 책갈피를 가지는 것이다. 깨끗한 체크인팀 프로그래밍을 할 때 프로그래밍 세션을 어떤 상태로 끝내는게 좋을까 ? 모든 테스트가 성공항 상태로 끝내라.팀 프로젝트에서 프로그래밍 세션을 시작하는 경우면, 자신이 마지막으로 코딩한 다음부터 지금까지 무슨 일이 일이 있었는지 세밀하게 알 수 없다. 안심이 되고 확신이 있는 상태에서 시작할 필요가 있다. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/04/06/tdd-chapter-27/"},{"title":"[테스트 주도 개발] 28장_초록 막대 패턴","text":"코드가 테스트를 통과하게 만들기 위해 이 패턴들을 사용해라. 가짜로 구현하기 ( 진짜로 만들기 전까지만 )실패하는 테스트를 만든 후 첫 번째 구현은 어떻게 하는게 좋을까? 상수를 반환하게 하라. 일단 테스트가 통과하면 단계적으로 상수를 변수를 사용하는 수식으로 변형한다. 삼각 측량오로지 예가 두개 이상일 때만 추상화를 해라.두 정수 합을 반환하는 함수를 예로 보자. 1234@Testvoid testSum(){ assertEquals(4, plus(3,1));} 123private int plus(int augend, int addend) { return 4;} 삼각 층량을 사용해서 바른 설계로 간다면, 다음과 같이 작성해야한다. 12345@Testvoid testSum(){ assertEquals(4, plus(3,1)); assertEquals(7, plus(3,4));} 그러면, 우리는 plus 의 구현을 추상화 할 수 있다. 123private int plus(int augend, int addend) { return augend + addend;} 어떤 계산을 어떻게 해야 올바르게 추상화할 것인지에 대해 감잡기 어려울 때만, 삼각측량을 사용해라. 그 이외는, 명백한 구현이나 가짜로 구현하기에 의존해라. 명백한 구현단순한 연산들은 그냥 구현해라. 하나에서 여럿으로객체 collection 을 다루는 연산은 어떻게 구현하나 ? 일단은 collection 없이 구현하고 그 다음에 collection 을 사용해라. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/04/06/tdd-chapter-28/"},{"title":"[빅데이터] 6장_일괄처리 계층","text":"데이터 시스템의 목적은, 데이터에 관한 임의의 질문에 응답하는 것이다. 데이터 집합 전체를 입력으로 받는 함수는 실행 시간이 매우 오래 걸리므로, 질의의 빠르게 응답할 수 있는 다른 전략이 필요하다.람다 아키텍쳐에서 일괄처리 계층은, 마스터 데이터 집합으로부터 일괄처리 뷰를 사전 계산해서 질의가 빠르게 처리될 수 있도록 한다. 6.1 일괄 처리 구실로 좋은 예제각 예제는 마스터 데이터 집합 전체를 입력 받는 함수로, 질의를 어떻게 실행하는지 보여준다. 이 예제는 질의 요청이 들어올 때 즉석으로 실행하는 대신, 사전 계산을 사용하도록 구현이 변경될 것이다. 6.1.1 시간대별 페이지뷰지정한 시간대에서 발생한 특정 URL 에 대한 페이지뷰 수의 총계를 구하는 것. 6.1.2 성별 추로이름 데이터 집합 레코드를 사용해서 개인의 성별 추론. 6.1.3 영향력 지수소셜 네트워크에서 개인의 영향력 지수를 구함. 6.2 일괄 처리 계층에서 계산을 수행하기 일괄 처리 계층은, 마스터 데이터 집합에 대한 함수를 실행해서 일괄 처리 뷰라고 불리는 중간 결과를 사전 계산한다. 일괄 처리 뷰는 서빙 계층에 로딩되고, 서빙 계층은 데이터에 빨리 접근할 수 있도록 이것에 대한 색인을 만들어둔다. 속도 계층은 일괄 처리 계층의 지연시간이 높은 것을 보완한다. 아직 일괄처리 뷰료 사전 계산 되지 않은 데이터에 대해 지연 시간이 낮은 갱신을 실행하는 것이다. 질의는 서빙 계층 뷰와 속도 계층 뷰의 처리 결과를 합쳐서 완료된다. 람다 아키텍쳐의 핵심은, 어떤 질의의 대해서도 일괄 처리 계층에서 데이터를 사전계산하여 서빙 계층에서 신속하게 처리할 수 있도록 할 수 있다는 것이다.모든 질의를 사전계산할 수는 없다. 그 대신, 다음 그림처럼 중간 결과를 사전 계산하고 그 결과들을 사용해서 질의를 즉석으로 처리할 수 있다. 시간대별 페이지뷰 질의 예제에 대해 중관 결과를 사전 계산한다면, URL 개개마다 모든 시각에 대한 페이지뷰를 사전계산 해두는 것이다. 질의 처리를 완료하려면 색인에서 지정한 범위에 속하는 모든 시각에 대한 페이지뷰 수를 얻어서 그 결과를 합치면 된다. 빅데이터, 람다 아키텍처로 알아보는 실시간 빅데이터 구축의 핵심 원리와 기법 &lt;네이선 마츠, 제임스 워렌&gt;","link":"/2020/04/07/bigdata-chapter-06/"},{"title":"[테스트 주도 개발] 29장_xUnit 패턴","text":"xUnit 계열의 테스트 프레임워크를 위한 패턴을 정리한다. assertion테스트가 어떻게 잘 작동하는지 테스트 할 것인가?boolean 수식을 이용해서, 프로그램이 코드가 동작하는지 자동으로 판단하도록 해라. fixture여러 테스트에서 공통으로 사용하는 객체들을 생성할 때 어떻게 하면 좋을까?각 테스트 코드의 지역 변수를 인스턴스 변수로 바꾸고 setUp() 메서드에 재정의해라. 그리고, setUp() 메서드에서 인스턴스 변수들을 초기화하도록 해라. 외부 fixture픽스처 중에 외부 자원이 있을 경우에 어떻게 해제할 것인가?tearDown() 메서드를 재정의해라. 그리고, teaDown() 메서드에서 자원을 해제하라. 테스트 메서드테스트 케이스 하나를 어떻게 표현하나?‘test’ 로 시작하는 이름의 메서드로 읽기 쉽도록 표현해라. 예외 테스트예외가 발생하는 것이 정상인 경우에 대한 테스트는 어떻게 작성하나?예상되는 예외를 잡아서 무시하고, 예외가 발생하지 않은 경우에 대해서는 테스트를 실패하게 만들어라. fail() 은 테스트가 실패했음을 알려주는 xUnit 메서드이다. 전체 테스트모든 테스트를 한번에 실행하려면 어떻게 하나?모든 테스트 슈트에 대한 모음을 작성해라. 123456789101112131415public class AllTests { public static void main(String[] args) { junit.swingui.TestRunner.run(AllTests.class); } public static Test suite(){ TestSuite result = new TestSuite(&quot;TFD tests&quot;); result.addTestSuite(MoneyTest.class); result.addTestSuite(ExchagneTest.class); result.addTestSuite(IdentityRateTest.class); return result; }} 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/04/19/tdd-chapter-29/"},{"title":"[테스트 주도 개발] 30장_디자인 패턴","text":"TDD 에서 쓰일 수 있는 디자인 패턴들을 정리한다. 커맨트 패턴간단한 메서드 호출보다 복잡한 형태의 계산 작업에 대한 호출이 필요하다면 어떻게 할까?계산 작업에 대한 객체를 생성해서 이를 호출하면 된다. Runnable 인터페이스가 대표적인 예이다. 값 객체공유되어야 하지만, identity (동일성) 은 중요하지 않을 때 겍체를 어떤식으로 설계할까?객체가 생성될 때 객체의 상태를 설정한다. 그리고, 이 상태가 절대 변할 수 없도록 해라. 이 객체에 대해 수행되는 연산은 언제나 새로운 객체를 반환하게 만들어라.별칭 문제란, 두 객체가 제 삼의 다른 객체에 대한 참조를 공유하는데, 한 객체가 공유 객체의 상태를 변화시키면, 다른 객체가 영향을 받는 문제이다. 해결하기 위한 방법으로, 의존하는 객체애 대한 참조를 외부로 알리지 않는 방법이다. 그 대신 객체에 대한 복사본을 제공한다. 이 방법의 문제는, 수행 시간이나 메모리 공간 측면에서 비효율적이다. 또한, 공유 객체의 상태 변화를 공유할 수 없다. 옵저버 패턴. 의존하는 객체에 자기를 등록해 놓고, 객체의 상태가 변하면 통지를 받는다. 이 방법의 문제는, 제어 흐름이 어렵고 의존성을 설정하고 제거하기 위한 로직이 지저분해진다. 객체를 덜 객체답게 취급. 객체는 시간의 흐름에 따라 변할 수 있는 상태를 가진다. 그런데, 이러한 특징을 제거해버려라. 이것이 값 객체이다. 모든 값 객체는 동등성을 구현해야한다. 만약, 계약을 표현하는 객체가 두 개가 있는데, 둘이 서로 같은 객체가 아니면 이 둘은 동등한것이 아니라 다른것이다. 하지만, 5프랑 짜리 동전 두개가 있는데, 이 동전들이 동일한 (identity) 동전인지는 중요하지 않다. 5프랑은 5프랑이다. 이들은 동등해야한다.(equality) 널 객체객체의 특별한 상황은 어떻게 표현하나? 그 상황을 표현하는 새로운 객체를 만들어라. Java.io.File 에는 getSesurityManager() 의 반환값이 null 인지 항상 검사를 한다. 다른 방법은 새로운 클래스를 만드는 것이다. 123public static SecurityManager getSecurityManager(){ return security == null ? new LaxSecurity() : security;} 템플릿 메서드작업 순서는 변하지 않지만, 각 작업 단위에 대한 미래의 개선 가능성을 열어두고 싶으면?다른 메서드들을 호출하는 내용으로만 이루어진 메서드를 만들어라. 플러거블 객체변이를 어떻게 표현?명시적인 조건을 사용해라. 다음은 중복 조건문들이 정의된 코드이다. 12345678910111213141516171819202122232425public class SelectionTool { Figure selected; public void mouseDown() { selected = findFigure(); if (selected != null) { select(selected); } } public void mouseMove() { if (selected != null) { move(selected); } else { moveSelectionRectangle(); } } public void mouseUp() { if (selected == null) { selectAll(); } }} 해법으로, 다음과 같이 플러거블 객체인 SelectionMode 를 만들어라. 123456789101112131415161718192021public class SelectionTool { SelectionMode mode; // 플러거블 객체 public void mouseDown() { selected = findFigure(); if (selected != null) { mode = new SingleSelection(selected); // 구현체 } else { mode = MultipleSelection(); // 구현체 } } public void mouseMove() { mode.mouseMove(); } public void mouseUp() { mode.mouseUp(); }} 플러거블 셀렉터인스턴스 별로 서로 다른 메서드가 동적으로 호출하게 하려면?메서드의 이름을 저장하고 있다가 그 이름에 해당하는 메서드를 동적으로 호출해라. 다음과 같이 새로운 종류 출력문을 추가할 때마다 switch 문을 변경할 것인가. 12345678910void print() { switch (printMessage) { case &quot;printHTML&quot;: printHtml(); break; case &quot;printXML&quot;: printXML(); break; }} 플러거블 셀렉터는, 리플랙션을 이용해서 동적으로 메서드를 호출한다. 1234void print() { Method method = getClass().getMethod(printMessage, null); method.invoke(this, new CLass[0]);} 메서드를 달랑 한개만 가지는 하위 클래스들이 여러 개 있을 때, 확실히 직관적인 상황에서 코드 정리 목적으로 사용해라. 팩토리 메서드다음 메서드가, 팩토리 메서드이다. 객체를 생성하기 때문이다. 123static Dollar dollar(int amount) { return new Dollar(amount);} 클라이언트는 다음과 같이 사용한다. 1Dollar five = Money.dollar(5); 팩토리 메서드의 단점은, indirection 이다. 메서드가 생성자처럼 생기지 않았지만, 이 안에서 객체를 생성한다는 사실을 기억해야한다. 유연함이 필요 없다면, 생성자를 써라. 사칭 사기꾼기존의 코드에 새로운 변이를 도입하려면?기존의 객체와 같은 프로토콜(인터페이스) 를 갖지만 구현은 다른 새로운 객체를 추가해라.예를 들면, 널 객체 : 데이터가 없는 상태를, 데이터가 있는 상태와 동일하게 취급 가능 컴포지트 : 객체의 집합을 단일 객체 처럼 취급 가능. 컴포지트하나의 객체가 다른 객체 목록의 행위를 조합한 것처럼 행동하게 하려면?객체 집합을 나타내는 객체를 단일 객체에 대한 임포스터로 구현해라. ( Folder 는 Folder 를 포함한다. ) 수집 매개변수여러 객체에 걸쳐 있는 오퍼레이션의 결과를 수집하라면?결과가 수집될 객체를 각 오퍼레이션의 매개 변수로 추가해라. 12345678910111213String toString() { IndentingStream writer = new IndentingStream(); toString(writer); return writer.contents();}void toString(IndentingStream writer) { writer.println(&quot;+&quot;); writer.index(); augend.toString(writer); ...} 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/04/19/tdd-chapter-30/"},{"title":"[테스트 주도 개발] 31장_리팩토링","text":"시스템의 설계를 작은 단계를 통해 변화시키는 방법들을 정리한다. 차이점 일치시키기비슷해 보이는 두 코드 조각을 합리려면?두 코드를 단계적으로 닮아가게 수정한다. 완전히 동일해지면 둘을 합쳐라. 변화 격리하기객체나 메서드의 일부만 바꾸려면?일단 바꿔야할 부분을 격리해라. 격리 방법으로는, 메서드 추출 객체 추출 메서드 객체 메서드 추출하기길고 복잡한 메서드를 읽기 쉽게 만들려면?긴 메서드의 일부분을 별도의 메서드로 분리하고 이를 호출해라. 복잡한 코드를 이해하기 쉽고, 중복을 제거하기도 좋다. 메서드 인라인제어 흐름이 너무 산재되어 있으면?메서드 호출하는 부분을 호출될 메서드의 본문으로 교체해라. 인터페이스 추출하기자바 오퍼레이션에 대한 두 번째 구현을 추가하려면?공통되는 오퍼레이션을 담고 있는 인터페이스를 만들어라. 메서드 옮기기메서드를 원래 있어야할 장소로 옮기려면?적절한 클래스에 메서드를 추가하고, 이를 호출하게 해라. 다음과 같이, 한 메서드에서 다른 객체에 하나 이상의 메세지를 보내면 의심해봐라. 123int width = bounds.right() - bounds.left();int height = bounds.bottom - bounds.top();int area = width * height; 다음과 같이 수정할 수 있다. 12345public class Shape { ... int area = bounds.area(); ...} 123456789public class Rectangle { public int area() { int width = this.right() - this.left(); int height = this.bottom() - this.pop(); return width * height; }} 메서드 객체여러 개의 매개 변수와 직역 변수를 갖는 복잡한 메서드는 어떻게 표현?메서드를 꺼내서 객체로 만들어라. 매개 변수 추가메서드에 매개 변수를 어떻게 추가?메서드가 인터페이스에 선언되어 있으면 인터페이스에 매개 변수를 추가해라. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/04/19/tdd-chapter-31/"},{"title":"[테스트 주도 개발] 32장_TDD 마스터하기","text":"좋은 테스트인지는 어덯게 알 수 있나?다음은 설계에 문제가 있음을 알려준다. 긴 setUp 코드 setUp 중복 실행 시간이 오래 걸리는 테스트 깨지기 쉬운 테스트 테스트를 지워야할 때는? 테스트를 삭제하고 자신감이 줄어들 것 같으면 삭제하지마라. 두 테스트 코드가 동일한 부분을 실행해도, 서로 다른 시나리오를 말한다면 그대로 남겨둬라. 프로젝트 중반에 TDD 를 도입하려면? 우선, 변경의 범위를 제한해라. 극적으로 단순화 될 수 있지만 지금 당장 변할 필요가 없으면 그냥 그대로 둬라. 그리고나서, 테스트와 리팩토링 사이의 교착 상태를 풀어줘라. 파트너와 같이 작업을 하거나, 아주 조심스럽게 작업을 할 수 있다. 시간이 지나면, 시스템에서 늘 변화하는 부분들은 테스트 주도로 된 것 처럼 보이게 될 것이다. TDD 와 패턴의 관계는?단순히 시스템에서 무슨 일을 할지 생각하고, 나중에 설계가 알아서 정해지도록 해라. 테스트 주도 개발 &lt;켄트 벡&gt;","link":"/2020/04/19/tdd-chapter-32/"},{"title":"Spring MVC 요청 처리 과정","text":"Spring MVC 는 어떻게 Client 의 요청을 처리하는지에 대해 정리한다. DispatcherServletDispatchServlet 은 Client 의 요청에 대해 실제 처리하는 메서드를 호출해주는 Front Controller 역할을 하는 클래스이다.계층 구조는 다음과 같다. 이제, DispatchServlet 이 Client 의 요청을 받은 뒤에, 어떻게 요청을 처리할 Controller 를 찾고 응답하는지 알아보자. Client 요청 처리 흐름전체 흐름은 다음과 같다. Application 이 구동될 때, Spring Boot Auto Configure 로 Spring MVC 의 Bean 들이 자동 등록된다. 사용자의 요청이 들어오면, DispatcherServlet 의 doService() 가 실행된다. doService() 에서 여러 설정을 한 뒤, doDispatch() 가 실행이 된다. HandlerMapping 이 요청을 처리할 Handler 를 찾는다. 등록되어 있는 HandlerAdapter 중에 해당 Handler 를 실행할 Adapter 를 찾는다. HandlerAdapter 는 Handler 의 응답을 처리한다. 최종적으로 응답을 보낸다. 디버거를 이용해서, 위 흐름을 코드로 상세히 살펴보자. Client 가 GET 요청을 하면, FrameworkServlet 의 doGet() 이 실행된다. processRequest() 의 doService() 에 들어가자. DispatcherServlet 의 doService 메서드임을 알 수 있다.여기서, handlerMappings 나 hadnlerAdapterts 클래스들은 아래와 같이 주입된 것이 확인된다. 이 클래스들은, Spring Boot Auto Configure 로 인해서, WebMvcAutoConfiguration 에서 Bean 으로 등록된다.다음과 같이 WebMvcAutoConfiguration 에서 여러 Bean 들이 등록되는 것을 알 수 있다. 이제 다시, doSerivce() 에서 doDispatch() 에 들어가보자. 다음과 같이, 요청을 처리할 핸들러를 찾고 (by HandlerMappings) 해당 핸드러를 실행할 수 있는 HandlerAdapter 를 찾는다. 찾아낸 HandlerAdapter 를 이용해서 handle 한다.","link":"/2020/05/22/spring-mvc/"},{"title":"Sync&#x2F;Async, Blocking&#x2F;Non-Blocking","text":"Sync 와 Async 의 차이, Blocking 과 Non-Blocking 의 차이를 정리한다. Sync 와 Async메서드의 결과를 제공하는 Server 를 기준으로 생각해야한다.Sync 는 다음 그림과 같이, 메서드의 결과과 결정되고 나서야 반환을 한다. Async 는 다음 그림과 같이, 메서드의 결과가 결정되기 전에 반환을 한다. Blocking 과 Non-Blocking메서드를 호출하는 Client 를 기준으로 생각해야한다.Blocking 은 다음 그림과 같이, 메서드를 호출하고 메서드의 결과를 return 받을 때 까지 다른 작업을 못한다. Non-Blocking 은 메서드를 호출하고 다른 작업을 할 수 있다. 이는 call-back 을 통해 가능하다. 즉, 메서드의 결과를 제공하는 서버에서 결과가 완성되면 클라이언트에게 call-back 을 하는 것이다. 다음 그림과 같다.","link":"/2020/06/10/java-sync-async/"},{"title":"Bean","text":"Bean 이 무엇이고, Spring Boot 는 어떤 과정으로 Bean 을 등록되는지 정리한다. Bean 이란IoC (Inversion of Control) Container 가 관리하는 객체이다.IoC Container 는 객체의 생성을 책임지고 의존성을 관리한다. Spring 에서는 ApplicaitonContext 가 IoC Container 역할을 한다. ApplicaitonContext 는 BeanFactory 를 확장한다. Bean 등록 순서다음 순으로 Bean 이 등록된다. @ComponentScan최상위 패키지 이하의 모든 패키지에 있는 클래스에, @Component 가 붙어있으면 Bean 으로 등록한다.예를 들어, 다음과 같이 repository package 와 service package 에 각각 @Repository, @Service 가 붙은 클래스는 Bean 으로 등록된다. @Repository, @Service 도 결국 @Component 가 붙어있기 때문이다.( Bean 등록 대상은, IDE 에서 클래스 옆에 콩 모양의 이미지를 보여준다. ) @EnableAutoConfigurationspring-boot-autoconfigure 프로젝트의 META-INF 에 spring.factories 라는 파일이 있다.이 파일 안의 key 값 중에 EnableAutoConfiguratoin 이라는 키가 있는데, 이 키에 여러 Configuration 클래스가 정의되어있다. 그리고 각 Configuration 클래스에는 @Configuration 이 붙어있다.예를 들어, WebMvcAutoConfigurration 를 따라가보면 결국에는 @Component 가 붙어 있기 때문에 Bean 으로 등록된다.","link":"/2020/06/11/spring-bean/"},{"title":"Rebase","text":"브랜치 간 병합하는 방법으로 merge 와 rebase 가 있다.이번 포스팅에서는 rebase 가 어떤 원리로 수행되는지 정리한다. 동작 순서 첫 번째 브랜치에서 c1, c2, c3 커밋을 한다. 그리고, 두 번째 브랜치로 checkout 을 한뒤에 c4, c5 커밋을 한다. 그리고, 다시 첫 번째 브랜치로 checkout 을 하여 c6 커밋을 한다. 이 때, conflict 가 발생하도록 공통 부분을 수정하자. 여기까지의 상황을 그림으로 표현하면 다음과 같다. 이 상황에서, 두 번째 브랜치를 첫 번째 브랜치로 ‘re’base 시도하면 어떤 일이 발생할까 ?conflict 가 발생한다. 위의 3번에서 공통 부분을 수정하였기 때문이다. 그래서, 개발자가 직접 conflict 발생 부분을 수정해줘야 병합을 계속 진행할 수 있다. 이것이 핵심이다. rebase 는 순차적으로 병합을 시도한다. 다음과 같이, c4 를 c6 까지의 결과에 병합을 시도하고, 이 병합된 결과에 c5 를 병합 시도한다. 예제위와 같은 상황을 실제로 재현하여 직접 rebase 테스트를 해보자. 브랜치는 다음 두 개로 한다 : master, jko master 에서 test.txt 파일을 생성하고, “commit 1 by master” 내용을 기입하고 commit 한다. “commit 2 by master” 내용을 기입하고 commit 한다. “commit 3 by master” 내용을 기입하고 commit 한다. 지금까지의 상황을 확인해보자. 이제 jko 브랜치로 checkout 한다. head 는 jko 를 가리키고 있다. “commit 4 by jko” 내용을 기입하고 commit 한다. “commit 5 by jko” 내용을 기입하고 commit 한다. 지금까지의 상황을 확인해보자. 이제 conflict 를 발생시킬 것이다. master branch 로 checkout 를 하자. 파일에는 jko branch 에서 추가한 두 커밋 내용이 당연히 없다. “commit 3 by master” 을 ‘’will be conflict” 로 변경하고 커밋하자. master 와 jko 브랜치의 test.txt 파일 내용은 각각 다음과 같다. 이제 jko 브랜치로 checkout 하자. master 로 rebase 해보자. 다음과 같이 conflict 를 해결하고 rebase continue 를 진행하라고 나온다. 여기가 핵심이다. test.txt 파일을 열어보자. conflict 지점이 master 에서 ‘“will be conflict” 로 수정한 지점이다. 그런데 왜, jko branch 에서 커밋한 “commit 5 by jko” 내용이 없을까 ? 앞서 강조하였듯이, rebase 는 순차적으로 진행하기 때문이다. “commit 4 by jko” 까지의 내용을 master 브랜치로 병합하고 있기 때문에, 현재 conflict 가 발생한 파일에는 “commit 5 by jko” 내용이 없는것이다.이제, 빨간 박스 부분을 지우고, rebase 를 계속 진행하자. ![](/image/git-rebase-10.png) ![](/image/git-rebase-11.png) 최종 병합된 결과의 log history 와 최종 결과 파일은 다음과 같다.","link":"/2020/06/21/rebase/"},{"title":"[실용주의 단위 테스트] 4장_테스트 조직","text":"이번 장은 다음 주제를 다룬다. 준비-실행-단언을 사용해 테스트를 가시적이고 일관성 있게 만드는 방법 메서드를 테스트하는 것이 아니라, 동작을 테스트 테스트 이름의 중요성 @Before, @After 1. AAA 로 테스트 일관성 유지AAA 는 다음과 같다. Arrange : 준비. 테스트 코드를 실행하기 전에 시스템에 적절한 상태에 있는지 확인 Act: 실행. 테스트 코드 실행 Assert : 단언. 실행한 코드가 기대한 대로 동작하는지 확인 예를 들면, 12345678910@Testpublic void answerArithmeticMeanOfTwoNumbers() { ScoreCollection collection = new ScoreCollection(); collection.add(() -&gt; 5); collection.add(() -&gt; 7); int actualResult = collection.arithmeticMean(); assertThat(actualResult, equalTo(6));} 2. 동작 테스트 vs 메서드 테스트단위 테스트를 작성할 때는, 개별 메서드를 테스트 하는 것이 아니라 클래스의 종합적인 동작을 테스트해야한다. 3. 테스트와 프로덕션 코드의 관계테스트 코드는 프로덕션 시스템 코드에 의존하지만, 프로덕션 코드는 테스트 코드의 존재를 모른다. 4. 집중적인 단일 목적 테스트의 가치다수의 케이스를 별도의 테스트 메서드로 분리하면 다음과 같은 장점이 있다. 단언이 실패했을 때 실패한 테스트의 이름이 표시되기 때문에, 어느 동작에서 문제가 있는지 빠르게 파악 가능 JUnit 은 각 테스트를 별도의 인스턴스로 실행하기 때문에, 실패한 테스트에 대해 다른 테스트의 영향을 제거 모든 케이스가 실행되었을 보장할 수 있음. 단언이 실패하면 현재 테스트 메서드는 중단 5. 문서로서의 테스트단위 테스트는 우리가 만드는 클래스에 대한 지속적이고 믿을 수 있는 문서 역할을 한다.어느 형식이든 일관성 있는 이름으로 테스트를 문서화하는 것이 중요하다.목표는, 테스트 코드를 다른 사람이 봤을 때 의미있게 만드는 것이다.형식은 다음과 같은 것들이 있다. doingSomeOperationGeneratesSomeResult someResultOccursUnderSomeCondition givenSomeContextWhenDoingSomeBehaviorThenSomeReulstOccurs (BDD) whenDoingSomeBehaviorThenSomeReulstOccurs 6. @Before 와 @After@Before 메서드를 사용해서 여러 테스트 메서드에 있는 중복된 초기화 코드를 제거할 수 있다.@Before 메서드는 매번 테스트 메서드 실행에 앞서 실행된다. 예를 들어 다음 세 메서드가 있을 때, @Before 메서드 A 테스트 메서드 B 테스트 메서드 다음 순으로 실행된다. (B 테스트 메서드가 먼저 실행될 수 있음) @Before 메서드 -&gt; A 테스트 메서드 -&gt; @Before 메서드 -&gt; B 테스트 메서드 @After 메서드는 클래스에 있는 각 테스트를 실행한 후에 실행된다. 테스트가 실패해도 실행된다.@BeforeClass 는 클래스에 있는 어떤 테스트를 실행하기 전에 최초 한 번만 실행된다. 자바와 JUnit 을 활용한 실용주의 단위 테스트 &lt;제프 랭어, 앤디 헌트, 데이브 토마스&gt;","link":"/2020/06/22/unit-test-ch-04/"},{"title":"[실용주의 단위 테스트] 5장_좋은 테스트의 FIRST 속성","text":"의미있는 테스트를 만드는데 도움을 주는 핵심 개념을 정리한다.좋은 테스트 조건 : FIRST ( Fast / Isolated / Repeatable / Self-validating / Timely ) 1. Fast테스트를 빠르게 유지해라. 단위 테스트를 하루에 서너 번 실행하기도 버겁다면 잘못된 것이다. 예를 들면, 모든 테스트 코드가 데이터베이스를 호출하면 전체 테스트 역시 느릴 것이다. 2. Isolated좋은 단위 테스트는, 검증하려는 작은 양의 코드에 집중한다. ‘단위’ 라고 말하는 정의와 부합한다. 다른 단위 테스트에 의존하지 않는다. 만약, 여러 테스트가 값 비싸게 생성된 데이터를 재사용 하는 방식으로 테스트 순서를 조작해서 전체 테스트의 실행 속도를 높이려 할 수도 있다. 하지만, 이것은 의존성의 악순환만 발생시킨다. 테스트 실패시, 무엇이 원인인지 알아내느라 오래 걸릴 수 있다. 객체 지향 설계에서 SRP 는 클래스를 변경해야할 이유가 하나민 있어야한다고 말한다. 테스트 메서드도 마찬가지다. 테스트 메서드가 하나 이상의 이유로 깨지면 테스트를 분할해라.그리고, 테스트에 두 번째 단언을 추가할 때 다음을 먼저 고민해보자. 이 단언이 단일 동작을 검증하도록 돕나 ? 아니면, 새로운 테스트 이름으로 기술할 수 잇는 어떤 동작인가 ? 3. Repeatble좋은 테스트는, 실행할 때마다 결과가 같아야한다. 이러기 위해서는, 직접 통제할 수 없는 외부 환경과 격리시켜야한다. 4. Self-validating테스트는 기대하는게 무엇인지 단언을 항상 해야한다. 테스트 결과를 수동으로 검증하는 것은 리스크가 크다.조금 더 확장된 개념으로, 테스트를 수동으로 실행하는 것을 넘어 언제 어떻게 실행할지도 자동화할 수 있다. Jenkins 나 Teamcity 같은 지속적 통합 도구를 사용하면, 소스 저장소를 관찰하여 변화를 감지하고 빌드와 테스트 절차를 시작한다. 5. Timely적절한 순간에 단위 테스트를 작성해라. 단위 테스트로 코드를 검증하는 것을 미루면 미룰수록, 결함이 늘어날 수 있다. 자바와 JUnit 을 활용한 실용주의 단위 테스트 &lt;제프 랭어, 앤디 헌트, 데이브 토마스&gt;","link":"/2020/06/24/unit-test-ch-05/"},{"title":"[전문가를 위한 스프링 5] 3장_Spring IoC 와 DI","text":"1. IoC 종류IoC (Inversion of Control ) 은 두 가지로 나뉜다 : DI, DLDI 는 IoC 컨테이너가 컴포넌트에 의존성을 주입시켜 준다. 반면, DL 은 컴포넌트 스스로 의존성 참조를 가져온다. DI (Dependency Injection) 생성자 주입 : IoC 컨테이너는 해당 컴포넌트를 초기화할 때, 컴포넌트에 필요한 의존성을 전달 123public ConstructorInjection(Dependency dp){ this.dp = dp;} 세터 주입 : setter method 를 호출해서, 의존성을 나중에 제공 가능 123public void setDependecy(Dependency dp){ this.dp = dp;} 필드 주입 : 스프링 컨테이너가 reflection 을 이용해 필요한 의존성을 주입 12345@Servicepublic class Singer { @Autowired private Inspiration inspirationBean; ... DL (Dependency Lookup) Depenency Pull : 중앙 registry 에서 의존성을 직접 가져오는 방식 ( register -&gt; container ) 1context.getbean(); Contextualized Dependency Lookup : 특정 중앙 registry 에서 의존성을 가져오는 것이 아니라, 자원을 관리하는 컨테이너에서 의존성을 가져오는 방식 123publicv void lookup(Container ct){ this.dp = (Dependency) ct.getDependency(&quot;myDependency&quot;);} 그렇다면, 의존성 주입 vs 의존성 룩업 ? 의존성 주입을 사용해라. 주입을 이용하면, 사용자 클래스는 IoC 컨테이너와 완전리 분리된다. 직접 테스트용 의존성을 주입하기 쉬우므로 테스트 하기 쉽니다. 그렇다면, 생성자 주입 vs 세터 주입 vs 필드 주입? 상황에 따라 선택해라. 생성자 주입 : 컴포넌트에 의존성 주입을 보장해야할 때 세터 주입 : 새로운 객체를 생성하지 않고 의존성을 교체할 때 필드 주입 : 다음 이유로, 권장하지 않는다. 클래스가 비대해지는 상황을 생성자 주입이나 수정자 주입에서는 쉽게 알아 챌 수 있지만, 필드 주입은 아니다. 클래스는 public interface 의 메서드나 생성자로 필요한 의존성 타입을 명확히 전달해야하는데, 필드 주입을 이용하면 어떤 타입의 의존성이 필요한지 명확하지 않다. final 필드에 사용할 수 없다. 의존성을 수동으로 주입해야하므로, 테스트 코드 작성이 어렵다. 2. BeanFactory, ApplicationContext Bean : 컨테이너가 관리하는 모든 컴포넌트 BeanFactory interface : 컴포넌트의 라이프사이클과 의존성을 관리 ApplicationContext interface (extends BeanFactory) : DI 외에도, 트랜잭션, AOP, 애플리케이션 이벤트 처리 기능 제공 3. Application Context 구성 Component 선언AppliceionContext 를 부트스트랩할 때, 컴포넌트를 찾아서 빈 인스턴스를 생성한다. 1234@Component(&quot;provider&quot;)public class HelloWorldMessageProvider implements MessageProvider { ...} 123456789101112@Service(&quot;renderer&quot;)public class StandardOutMessageRenderer implements MessageRenderer { private MessageProvider messageProvider; @Override @Autowired public void setMessageProvider(MessageProvider provider) { this.messageProvider = provider; } ...} Java ConfigurationConfiguration 클래스에는, IoC 컨테이너가 빈 인스턴스를 만들 때 호출하는 @Bean 어노테이션이 적용된 메서드가 있다. 123456789@Configurationpublic class HelloWorldConfiguration { @Bean public MessageProvider provider() { return new HelloWorldMessageProvider(); }}... 4. 주입 인자스프링은 다른 컴포넌트나 단순 값 이외에 자바 컬렉션, 외부에 정의된 프로퍼티를 주입할 수 있도록 주입 인자에 많은 옵션을 지원한다. 단순 값 주입 12345678910111213@Servicepublic class InjectSimple { @Value(&quot;John Mayer&quot;) private String name; @Value(&quot;40&quot;) private int age; @Value(&quot;1.92&quot;) private float height; @Value(&quot;false&quot;) private boolean programmer; @Value(&quot;1241401112&quot;) private Long ageInSeconds; ... SpEL (Spring Expression Language) 1234567891011121314151617@Servicepublic class InjectSimpleSpel { @Value(&quot;#{injectSimpleConfig.name}&quot;) private String name; @Value(&quot;#{injectSimpleConfig.age + 1}&quot;) private int age; @Value(&quot;#{injectSimpleConfig.height}&quot;) private float height; @Value(&quot;#{injectSimpleConfig.programmer}&quot;) private boolean programmer; @Value(&quot;#{injectSimpleConfig.ageInSeconds}&quot;) private Long ageInSeconds; ... 12345678@Component(&quot;injectSimpleConfig&quot;)public class InjectSimpleConfig { private String name = &quot;John Mayer&quot;; private int age = 40; private float height = 1.92f; private boolean programmer = false; private Long ageInSeconds = 1_241_401_112L; ... 컬렉션 주입 123456789101112131415161718@Servicepublic class CollectionInjection { /** * @Resource(name=&quot;map&quot;) is equivalent with @Autowired @Qualifier(&quot;map&quot;) */ @Autowired @Qualifier(&quot;map&quot;) private Map&lt;String, Object&gt; map; @Resource(name=&quot;props&quot;) private Properties props; @Resource(name=&quot;set&quot;) private Set set; @Resource(name=&quot;list&quot;) private List list; 5. 빈 명명 규칙모든 빈은 ApplicationContext 내에서 고유한 하나 이상의 이름을 가져야한다.id 나 이름이 없는 같은 타입의 빈이 여러개 선언되면, 스프링은 ApplicationContext 를 초기화하는 과정에서 빈을 주입할 때 예외 (NoSuchBeanDefinitionException) 를 던진다.다음 Singer 클래스의 경우, 클래스명 자체로 빈을 명명한다 : singer 1234@Componentpublic class Singer { ...} 다음 Singer 클래스의 경우, @Component 어노테이션의 인수가 빈의 이름이다 : johnMayer 1234@Component(&quot;johnMayer&quot;)public class Singer { ...} 별칭을 선언하려면 ? @Bean 의 name attribute 를 사용한다. 첫 번째 값이 id, 다른 값이 별칭. 즉, johnMayer 가 id 12345678@Configurationstatic class AliasBeanConfig { @Bean(name = {&quot;johnMayer&quot;, &quot;john&quot;, &quot;jonathan&quot;, &quot;johnny&quot;}) public Singer singer() { return new Singer(); }} 6. 빈 생성 방식기본적으로 스프링의 모든 빈은 싱글톤이다. 즉, 스프링은 빈의 단일 인스턴스를 유지하고 관리한다. ApplicationContext.getBean() 에 대한 모든 호출은 동일한 인스턴스를 반환한다.빈의 인스턴스를 가져올 때마다 새로운 빈 인스턴스를 가져오려면 ? 다음과 같이, prototype 으로 변경해라. 12345678910111213@Component(&quot;nonSingleton&quot;)@Scope(&quot;prototype&quot;)public class Singer { private String name = &quot;unknown&quot;; public Singer(@Value(&quot;John Mayer&quot;) String name) { this.name = name; } @Override public String toString() { return name; }} 7. Autowiring스프링이 Autowiring 을 수행하는 다섯 가지 방식이 있다. byName : ApplicationContext 에서 각 프로퍼티와 이름이 같은 빈을 찾아서 연결 시도 byType : ApplicationContext 에서 동일한 타입의 빈을 대상 빈의 각 프로퍼티에 연결 시도 Constructor : 주입이 수정자가 아닌 생성자를 이용해서 이루어진다는 점을 제외하면 byType 과 동일 default : 빈에 기본 생성자가 있으면 byType 방식, 없으면 Constructor 방식 no : 기본값 어노테이션을 이용해서 구성할 때, 기본 Autowiring 방식은 byType 이다.이름을 기반으로 Autowiring 을 하기 위해서는 @Autowired 와 주입되어야 하는 빈의 이름을 인자로 전달하는 @Qualifier 을 적용해라.다음 코드로 예를 들어보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component@Lazy // 처음 접근이 일어날 때 인스턴스가 생상될 빈을 정의public class TrickyTarget { Foo fooOne; Foo fooTwo; Bar bar; public TrickyTarget() { System.out.println(&quot;Target.constructor()&quot;); } public TrickyTarget(Foo fooOne) { System.out.println(&quot;Target(Foo) 호출&quot;); } public TrickyTarget(Foo fooOne, Bar bar) { System.out.println(&quot;Target(Foo, Bar) 호출&quot;); } @Autowired public void setFooOne(Foo fooOne) { this.fooOne = fooOne; System.out.println(&quot;프로퍼티 fooOne 설정&quot;); } @Autowired public void setFooTwo(Foo foo) { this.fooTwo = foo; System.out.println(&quot;프로퍼티 fooTwo 설정&quot;); } @Autowired public void setBar(Bar bar) { this.bar = bar; System.out.println(&quot;프로퍼티 bar 설정&quot;); } public static void main(String... args) { GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(); ctx.load(&quot;classpath:spring/app-context-05.xml&quot;); ctx.refresh(); TrickyTarget t = ctx.getBean(TrickyTarget.class); ctx.close(); }} 1234@Componentpublic class Foo {} 1234@Componentpublic class Bar {} 그리고, TrickyTarget 클래스를 실행하면 다음과 같이 출력된다. 1234Target.constructor()프로퍼티 fooOne 설정프로퍼티 fooTwo 설정프로퍼티 bar 설정 그런데 만약에, 빈 타입들이 서로 연관되면 상황이 복잡해진다. Foo 를 인터페이스로 변경하고 이 인터페이스를 구현하는 빈 타입 두개를 선언해보자. 123public interface Foo {} 1234@Componentpublic class FooImplOne implements Foo {} 1234@Componentpublic class FooImplTwo implements Foo{} 그리고 다시 TrickyTarget 클래스를 실행하면, UnsatisfiedDependencyExpcetion 이 발생한다.이 메세지는 스프링이 setFoo 메서드를 사용해서 주입해야하는 빈이 어떤 빈인지 알지 못한다는 것이다.이를 해결 하는 두 가지 방법이 있다 : @Primary, @Qualifier @Primary타입을 기반으로 Autowiring 할 때, 스프링에게 자신의 우선순위를 높게 지정한다.@Primary 는 정확히 두 개의 관련 빈 타입이 있을 경우에 유용하다. 12345@Component@Primarypublic class FooImplOne implements Foo {} 다시 TrickyTarget 클래스를 실행하면, 결과는 다음과 같다. 1234Target.constructor()프로퍼티 fooOne 설정프로퍼티 fooTwo 설정프로퍼티 bar 설정 @Qualifier모호한 setter 였던 setFooOne() 과 setFooTwo() 에 @Autowired 와 함께 적용한다. 12345678910111213141516171819202122232425@Component@Lazypublic class TrickyTarget { Foo fooOne; Foo fooTwo; Bar bar; ... @Autowired @Qualifier(&quot;fooImplOne&quot;) public void setFooOne(Foo fooOne) { this.fooOne = fooOne; System.out.println(&quot;프로퍼티 fooOne 설정&quot;); } @Autowired @Qualifier(&quot;fooImplTwo&quot;) public void setFooTwo(Foo foo) { this.fooTwo = foo; System.out.println(&quot;프로퍼티 fooTwo 설정&quot;); } ... 다시 TrickyTarget 클래스를 실행하면, 결과는 다음과 같다. 1234Target.constructor()프로퍼티 fooOne 설정프로퍼티 fooTwo 설정프로퍼티 bar 설정 전문가를 위한 스프링 5 &lt;율리아나 코스미스&gt;","link":"/2020/06/27/spring-expert-ch-03/"},{"title":"Logback","text":"Logback 이 무엇이고, 어떻게 사용하는지 정리한다. 1. SLF4J (Simple Logging Facade for Java)우선 SLF4J 가 무엇인지 알아보자.공식 문서 (http://www.slf4j.org/manual.html) 에 따르면, SLF4J 는 java.util.logging, logback 및 log4j 와 같은 다양한 Logging Framework 에 대한 Facade 또는 추상화 역할을 한다.그래서, SLF4J 는 개발자가 원하는 Logging Framework 를 plug-in 할 수 있도록 지원한다. 예를 들면, SLF4J Facade 덕분에 log4j 구현체를 사용하다가 logback 구현체로 변경하여도 일관된 방식으로 logging 이 가능하다. 2. Logbacklogback 은 log4j 의 후속 프로젝트이다. 왜 log4j 대신에 logback 를 사용해야하는지는 공식 문서 (http://logback.qos.ch/reasonsToSwitch.html) 를 참고하자.이제 실제 프로젝트에 적용을 해보자. 3. 의존성 확인의존 관계 tree 를 명확히 확인하기 위해 maven 기반으로 프로젝트를 생성하였다.pom.xml 에는 다음과 같이 spring-boot-starter 가 포함되어 있다. 그리고, spring-boot-starter 를 따라가면, 다음과 같이 spring-boot-starter-logging 이 포함되어 있다. 그리고, spring-boot-starter-logging 을 따라가면, 다음과 같이 logback 이 포함되어 있다. External Libraries 에도 의존성이 추가 된것을 알 수 있다. 따라서, Logback 에 대한 의존성을 따로 내가 추가할 필요 없이 바로 사용할 수 있다. 4. 적용logback-spring.xml 파일을 천천히 보자. 변수를 지정하는 부분이다. 해당 변수의 값이 필요한 곳에 가져다 쓰면 된다. appdender 를 정의한다. ROLLING 이라는 이름을 부여한 appdender 는 ERROR Level 에 해당하는 로그만 필터링해서 남긴다. Rolling Policy 가 적용되어 있어서, 해당 위치의 파일에 시간 단위로 파일을 생성해서 로깅을 한다. maxHistory 는 5 로 최근 5시간의 파일만 유지하고 나머지는 자동으로 지운다. 환경에 따라, appender 를 다르게 지정할 수 있다. active profile = local 인 경우에는, STDOUT appender 와 ROLLING appender 가 모두 적용된다. 5. 결과다음과 같이 코드를 작성하고 Application 을 구동해보자. Console Log 부터 확인해보자. “this is TRACE Level” 은 logging 되지 않은 것을 확인할 수 있다. 왜일까?active profile=local 로 실행되었을 때 root level 이 DEBUG 로 설정되어 있기 때문이다. 그래서 DEBUG Level 이상의 로그만 찍힌 것이다.이제 file log 를 확인해보자. 해당 위치에 file 이 생성되었다. 해당 File 을 열어보면, ERROR log 만 남았다. 왜일까 ? ROLLING appender 에서 ERROR 로그만 Filtering 하고 있기 때문이다. 6. Source Code위에서 테스트한 Source Code 는 여기서 확인할 수 있다 : https://github.com/KoJunHee/demo-logback","link":"/2020/06/28/logback/"},{"title":"[실용주의 단위 테스트] 6장_무엇을 테스트할 것인가?","text":"무엇을 테스트해야하는지 정리한다.이것으로 쉽게 요약할 수 있다 : Right-BICEP Right : 결과가 올바른가 ? B : Boundary. 경계 조건은 맞는가 ? I : Inverse relationship. 역관계를 검사할 수 있나 ? C : Cross check. 다른 수단을 활용해서 교차 검사 가능한가 ? E : Error. 오류를 강제로 발생시킬 수 있는가 ? P : Performance. 성능 조건은 기준에 부합하나 ? 1. Right테스트 코드는 무엇보다도 먼저, 기대한 결과를 산출하는지 검증 해야한다.다음 코드의 ScoreCollection 에 더 많은 숫자나 더 큰 수를 넣어서 테스트를 강화할 수 있다. 하지만 이러한 테스트는 행복 경로 테스트의 영역일 뿐이다. 123456789101112public class ScoreCollectionTest { @Test public void answersArithmeticMeanOfTwoNumbers() { ScoreCollection collection = new ScoreCollection(); collection.add(() -&gt; 5); collection.add(() -&gt; 7); int actualResult = collection.arithmeticMean(); assertThat(actualResult, equalTo(6)); }} 2. Boundary대부분의 결함은 Corner Case 이다. 테스트로 이것들을 처리해야한다. 다음과 같은 경계 조건이 있다. 모호하고 일관성 없는 입력 값. ex) 특수문자가 포함된 파일 이름 잘못된 양식의 데이터 Overflow 를 일으키는 계산 비거나 빠진 값. ex) 0, “”, null 이성적인 기대 값을 벗어나는 값. ex) 200 세의 나이 중복을 허용해서는 안되는 목록에 중복 값이 있는 경우 정렬이 안된 정렬 리스트 혹은 그 반대 시간 순이 맞지 않는 경우. ex) HTTP Server 가 OPTIONS 메서드의 결과를 POST 메서드 보다 나중에 반환 다음 클래스를 기준으로 테스트해보자. 123456789101112public class ScoreCollection { private List&lt;Scoreable&gt; scores = new ArrayList&lt;&gt;(); public void add(Scoreable scoreable) { scores.add(scoreable); } public int arithmeticMean() { int total = scores.stream().mapToInt(Scoreable::getScore).sum(); return total / scores.size(); }} Scoreable 인스턴스는 null 일 수 있다. 다음 테스트 코드로 확인 가능하다. 1234@Test(expected=IllegalArgumentException.class)public void throwsExceptionWhenAddingNull() { collection.add(null);} add() 에 Guard Clause 를 넣어 입력 범위를 다음과 같이 분명하게 하자. 1234public void add(Scoreable scoreable) { if (scoreable == null) throw new IllegalArgumentException(); scores.add(scoreable);} 또한, ScoreCollection 객체에 Scoreable 인스턴스가 없을 수도 있다. ArithmeticExeptoin 이 발생할 수 있다. 1234@Testpublic void answersZeroWhenNoElementsAdded() { assertThat(collection.arithmeticMean(), equalTo(0));} 다음과 같이 조건문을 추가하자. 1234567public int arithmeticMean() { if (scores.size() == 0) return 0; // ... long total = scores.stream().mapToLong(Scoreable::getScore).sum(); return (int)(total / scores.size());} 또한, 큰 정수 입력을 다루면 숫자들의 합이 Integer.MAX_VALUE (2147483647) 를 초과할 수 있다. 1234567@Testpublic void dealsWithIntegerOverflow() { collection.add(() -&gt; Integer.MAX_VALUE); collection.add(() -&gt; 1); assertThat(collection.arithmeticMean(), equalTo(1073741824));} 다음과 같이 long type 을 사용하면 된다. 1234567public int arithmeticMean() { if (scores.size() == 0) return 0; // ... long total = scores.stream().mapToLong(Scoreable::getScore).sum(); return (int)(total / scores.size());} 3. Inverse relationship종종 논리적인 역관계를 적용해서 행동을 검사할 수 있다. 수학 계산에서 많이 사용한다.다음 클래스의 메서드는, 어떤 수의 제곱근을 구하는 기능을 한다. 1234567891011public class NewtonTest { static class Newton { private static final double TOLERANCE = 1E-16; public static double squareRoot(double n) { double approx = n; while (abs(approx - n / approx) &gt; TOLERANCE * approx) approx = (n / approx + approx) / 2.0; return approx; } } 다음 테스트 코드에서는, 250의 제곱근을 유도하고, 그 결과를 제곱하면 다시 250이 나오도록 테스트한다.즉, 역관계를 이용해서 테스트하는 것이다. 12345@Testpublic void squareRoot() { double result = Newton.squareRoot(250.0); assertThat(result * result, closeTo(250.0, Newton.TOLERANCE));} 4. Cross check다른 수단을 활용해서 테스트할 수 있다.위의 제곱근을 테스트하는 경우에, 자바 라이브러리 중에 제곱근을 구하는 라이브러리를 사용할 수 있다. 12345@Testpublic void squareRootVerifiedUsingLibrary() { assertThat(Newton.squareRoot(1969.0), closeTo(Math.sqrt(1969.0), Newton.TOLERANCE));} 5. Error코드를 테스트하기 위해 도입할 수 있는 오류의 종류나 환경적인 제약들에는 다음과 같은 것들이 있다. 메모리가 가득 찰 때 디스크가 가득 찰 때 네트워크 가용성 및 오류들 시스템 로드 … 6. Performance최적화를 하기 전에 먼저, 기준점을 잡기 위해 현재 경과 시간 (elapsed time) 을 측정해라. 이것을 몇 번 해보고 평균을 계산해라. 그리고, 코드를 변경하고 성과 테스트를 다시 실행해 결과를 비교해라.단위 테스트 뿐만 아니라, JMeter 와 같은 도구를 사용할 수도 있다. 자바와 JUnit 을 활용한 실용주의 단위 테스트 &lt;제프 랭어, 앤디 헌트, 데이브 토마스&gt;","link":"/2020/06/29/unit-test-ch-06/"},{"title":"[실용주의 단위 테스트] 7장_경계 조건","text":"경계 조건과 관련된 결함을 방지할 수 있는 방법들을 정리한다. 약어로, CORRECT. 1. Conformance기대하는 구조에 입력 데이터가 맞는지 확인해라.예를 들면, 이메일 주소의 경우에 @ 기호가 없는 경우나 @ 의 앞부분이 비어있는 경우에 대처해야한다. 2. Ordering데이터의 순서나 Collection 에 있는 데이터의 위치가 코드를 잘못되게 할 수 있다. 3. Range기본형의 과도한 사용에 의한 code smell 을 Primitive Obsession 이라고 한다. 객체 지향 언어를 사용하면, 사용자 정의 추상화로 이 문제를 해결할 수 있다.예를 들면, 원은 360 도 이다. 이동 방향을 자바 기본형으로 저장하기 보다 Bearing 클래스로 범위를 제약하는 로직을 캡슐화 할 수 있다.다음 테스트 코드는, 유효하지 않은 값으로 Bearing 을 생성할 때 어떤 일이 발생하는지 보여준다. 123456789101112131415161718192021222324252627public class BearingTest { @Test(expected=BearingOutOfRangeException.class) public void throwsOnNegativeNumber() { new Bearing(-1); } @Test(expected=BearingOutOfRangeException.class) public void throwsWhenBearingTooLarge() { new Bearing(Bearing.MAX + 1); } @Test public void answersValidBearing() { assertThat(new Bearing(Bearing.MAX).value(), equalTo(Bearing.MAX)); } @Test public void answersAngleBetweenItAndAnotherBearing() { assertThat(new Bearing(15).angleBetween(new Bearing(12)), equalTo(3)); } @Test public void angleBetweenIsNegativeWhenThisBearingSmaller() { assertThat(new Bearing(12).angleBetween(new Bearing(15)), equalTo(-3)); }} 제약 사항은 생성자에 있다. 12345678910111213public class Bearing { public static final int MAX = 359; private int value; public Bearing(int value) { if (value &lt; 0 || value &gt; MAX) throw new BearingOutOfRangeException(); this.value = value; } public int value() { return value; } public int angleBetween(Bearing bearing) { return value - bearing.value; }} 또 다른 예로, 점 두 개를 x, y 정수로 유지하는 클래스가 있다고 하자. 범위에 대한 제약은, 각 변이 100 이하이다. 좌표에 영향을 주는 동작에 대하여 범위를 단언해보자. @After 메서드로 테스트가 완료될 때마다 확인할 수 있다. 1234567891011121314151617181920212223public class RectangleTest { private Rectangle rectangle; @After public void ensureInvariant() { assertThat(rectangle, constrainsSidesTo(100)); // constrainsSidesTo : 사용자 정의 햄크레스트 매처 (코드 생략) } @Test public void answersArea() { rectangle = new Rectangle(new Point(5, 5), new Point (15, 10)); assertThat(rectangle.area(), equalTo(50)); } @Ignore @ExpectToFail @Test public void allowsDynamicallyChangingSize() { rectangle = new Rectangle(new Point(5, 5)); rectangle.setOppositeCorner(new Point(130, 130)); assertThat(rectangle.area(), equalTo(15625)); }} 4. Reference어떤 상태를 가정할 때는, 그 가정이 맞지 않으면 코드가 합리적으로 동작하는지 테스트해야한다.예를 들어, 차량이 이동중일 때와 아닐 때 변속기 동작이 어떻게 달라지는지 테스트해보자. 시나리오는 다음 세가지이다. 가속 이후에 변속기를 주행으로 유지하나 주행 중에 주차로 바꾸는 요청을 무시하나 차량이 움직이지 않으면 주차로 변속기 변경을 허용하나 위 세 시나리오를 각각 테스트 메서드로 표현하면 다음과 같다. 1234567891011121314151617181920212223242526272829303132333435363738public class TransmissionTest { private Transmission transmission; private Car car; @Before public void create() { car = new Car(); transmission = new Transmission(car); } @Test public void remainsInDriveAfterAcceleration() { transmission.shift(Gear.DRIVE); car.accelerateTo(35); assertThat(transmission.getGear(), equalTo(Gear.DRIVE)); } @Test public void ignoresShiftToParkWhileInDrive() { transmission.shift(Gear.DRIVE); car.accelerateTo(30); transmission.shift(Gear.PARK); assertThat(transmission.getGear(), equalTo(Gear.DRIVE)); } @Test public void allowsShiftToParkWhenNotMoving() { transmission.shift(Gear.DRIVE); car.accelerateTo(30); car.brakeToStop(); transmission.shift(Gear.PARK); assertThat(transmission.getGear(), equalTo(Gear.PARK)); }} 5. Existence주어진 값이 존재하는지 테스트해라. 값이 null 이나 0 이나 비어 있는 경우라면 어떤 일이 일어날지 생각해라. 6. Cardinality0-1-n 법칙을 고려해라. 즉, 어떤 것이 없거나, 한 개만 있거나, 여러 개가 있는 경우를 고려해라. 7. Time 메서드의 호출 순서가 맞지 않을 때는 어떤 상황이 발생하는지 고려해라. Timeout 을 고려하여 무한 대기에 빠지지 않도록 고려해라. 같은 객체를 동시에 다수의 스레드가 접근하면 어떤 일이 발생할지 고려해라. 자바와 JUnit 을 활용한 실용주의 단위 테스트 &lt;제프 랭어, 앤디 헌트, 데이브 토마스&gt;","link":"/2020/07/08/unit-test-ch-07/"},{"title":"[실용주의 단위 테스트] 10장_Mock","text":"Mock 객체를 사용해서 의존성을 끊는 방법을 정리한다. 1. 테스트 도전 과제다음 클래스의 메서드는, 좌표를 기반으로 Address 객체를 생성해서 반환한다. retrieve() 메서드의 테스트를 작성해보자.주의할점은, HttpImpl 클래스가 REST 호출을 실행한다는 것이다. 1234567891011121314151617181920212223242526public class AddressRetriever { public Address retrieve(double latitude, double longitude) throws IOException, ParseException { String parms = String.format(&quot;lat=%.6flon=%.6f&quot;, latitude, longitude); String response = new HttpImpl().get( &quot;http://open.mapquestapi.com/nominatim/v1/reverse?format=json&amp;&quot; + parms); JSONObject obj = (JSONObject)new JSONParser().parse(response); JSONObject address = (JSONObject)obj.get(&quot;address&quot;); String country = (String)address.get(&quot;country_code&quot;); if (!country.equals(&quot;us&quot;)) throw new UnsupportedOperationException( &quot;cannot support non-US addresses at this time&quot;); String houseNumber = (String)address.get(&quot;house_number&quot;); String road = (String)address.get(&quot;road&quot;); String city = (String)address.get(&quot;city&quot;); String state = (String)address.get(&quot;state&quot;); String zip = (String)address.get(&quot;postcode&quot;); return new Address(houseNumber, road, city, state, zip); }} HttpImp 클래스는 다음과 같다. 123456789101112131415161718public class HttpImpl implements Http { public String get(String url) throws IOException { CloseableHttpClient client = HttpClients.createDefault(); HttpGet request = new HttpGet(url); CloseableHttpResponse response = client.execute(request); try { HttpEntity entity = response.getEntity(); return EntityUtils.toString(entity); } finally { response.close(); } }}public interface Http { String get(String url) throws IOException;} HTTP 호출을 실행하면 다음 두 문제가 있다. 실제 호출에 대한 테스트는, 다른 빠른 테스트들에 비해 느리다. HTTP API 가 항상 가용한지는 보장할 수 없다. 즉, 우리의 통제 밖이다. 2. 번거로운 동작을 Stub 으로 대체HTTP 호출에서 반환되는 JSON 응답을 이용해서 Address 객체를 생성하는 로직을 검증해보자.그러기 위해, HttpImpl 클래스의 get() 메서드 동작을 변경해보자. 단지, 테스트를 위해 하드 코딩한 JSON 문자열을 반환하도록 하자.이렇게, 테스트 용도로 하드 코딩한 값을 반환하는 구현체를 Stub 이라고 한다. 123456789Http http = (String url) -&gt; &quot;{\\&quot;address\\&quot;:{&quot; + &quot;\\&quot;house_number\\&quot;:\\&quot;324\\&quot;,&quot; + &quot;\\&quot;road\\&quot;:\\&quot;North Tejon Street\\&quot;,&quot; + &quot;\\&quot;city\\&quot;:\\&quot;Colorado Springs\\&quot;,&quot; + &quot;\\&quot;state\\&quot;:\\&quot;Colorado\\&quot;,&quot; + &quot;\\&quot;postcode\\&quot;:\\&quot;80903\\&quot;,&quot; + &quot;\\&quot;country_code\\&quot;:\\&quot;us\\&quot;}&quot; + &quot;}&quot;; 위와 같이 Stub 을 작성하고, HttpImpl 클래스에 있는 프로덕션 구현 대신에 Stub 을 사용할 것이라고 AddressRetriever 클래스에 알려줘야 한다.즉, 스텁을 인스턴스로 전달하거나 주입을 해야한다. 다음과 같이 생성자 주입을 사용할 수 있다. 123456789101112131415161718public class AddressRetriever { private Http http; public AddressRetriever(Http http) { this.http = http; } public Address retrieve(double latitude, double longitude) throws IOException, ParseException { String parms = String.format(&quot;lat=%.6flon=%.6f&quot;, latitude, longitude); String response = http.get( &quot;http://open.mapquestapi.com/nominatim/v1/reverse?format=json&amp;&quot; + parms); JSONObject obj = (JSONObject)new JSONParser().parse(response); // ... }} 이를 기반으로 테스트를 작성할 수 있다. 12345678910111213141516171819202122232425public class AddressRetrieverTest { @Test public void answersAppropriateAddressForValidCoordinates() throws IOException, ParseException { Http http = (String url) -&gt; &quot;{\\&quot;address\\&quot;:{&quot; + &quot;\\&quot;house_number\\&quot;:\\&quot;324\\&quot;,&quot; + &quot;\\&quot;road\\&quot;:\\&quot;North Tejon Street\\&quot;,&quot; + &quot;\\&quot;city\\&quot;:\\&quot;Colorado Springs\\&quot;,&quot; + &quot;\\&quot;state\\&quot;:\\&quot;Colorado\\&quot;,&quot; + &quot;\\&quot;postcode\\&quot;:\\&quot;80903\\&quot;,&quot; + &quot;\\&quot;country_code\\&quot;:\\&quot;us\\&quot;}&quot; + &quot;}&quot;; AddressRetriever retriever = new AddressRetriever(http); Address address = retriever.retrieve(38.0,-104.0); assertThat(address.houseNumber, equalTo(&quot;324&quot;)); assertThat(address.road, equalTo(&quot;North Tejon Street&quot;)); assertThat(address.city, equalTo(&quot;Colorado Springs&quot;)); assertThat(address.state, equalTo(&quot;Colorado&quot;)); assertThat(address.zip, equalTo(&quot;80903&quot;)); }} 3. 설계 변경처음에, Http 인스턴스는 retrieve() 메서드에서 생성이 되었다. 즉, AddressRetriever 클래스의 세부사항이었다.그런데 이제, AddressRetriever 클래스와 상호 작용하는 클아이언트가 다음과 같이 적절한 Http 인스턴스를 생성해서 넘겨줘야 한다. 1AddressRetriever retriever = new AddressRetriever(new HttpImpl()); 설계가 더 나아졌다. Http 객체애 대한 의존성이 깔끔한 방식으로 선언되었다. 인터페이스에 대한 의존성은 결합도를 느슨하게 한다. 4. 인자 검증스텁에 Http 클래스의 get() 메서드에 전달되는 URL 을 검증하는 보호절을 추가할 수 있다.기대하는 인자 문자열이 포함되지 않으면 그 시점에 명시적으로 테스트를 실패 처리하는 것이다.이것이 Mock 이다. Mock 은 의도적으로 흉내 낸 동작을 제공하고, 수신한 인자가 모두 정상인지 여부를 검증하는 테스트 구조물이다. 123456789101112131415161718192021public class AddressRetrieverTest { @Test public void answersAppropriateAddressForValidCoordinates() throws IOException, ParseException { Http http = (String url) -&gt; { if (!url.contains(&quot;lat=38.000000&amp;lon=-104.000000&quot;)) fail(&quot;url &quot; + url + &quot; does not contain correct parms&quot;); return &quot;{\\&quot;address\\&quot;:{&quot; + &quot;\\&quot;house_number\\&quot;:\\&quot;324\\&quot;,&quot; + &quot;\\&quot;road\\&quot;:\\&quot;North Tejon Street\\&quot;,&quot; + &quot;\\&quot;city\\&quot;:\\&quot;Colorado Springs\\&quot;,&quot; + &quot;\\&quot;state\\&quot;:\\&quot;Colorado\\&quot;,&quot; + &quot;\\&quot;postcode\\&quot;:\\&quot;80903\\&quot;,&quot; + &quot;\\&quot;country_code\\&quot;:\\&quot;us\\&quot;}&quot; + &quot;}&quot;; }; AddressRetriever retriever = new AddressRetriever(http); // ... }} 5. Mock 을 사용해서 테스트 단순화mockito 를 사용해보자. 기대사항을 충족하면 mock 은 지정된 값을 반환한다. 1234567891011121314151617181920212223public class AddressRetrieverTest { @Test public void answersAppropriateAddressForValidCoordinates() throws IOException, ParseException { Http http = mock(Http.class); when(http.get(contains(&quot;lat=38.000000&amp;lon=-104.000000&quot;))).thenReturn( &quot;{\\&quot;address\\&quot;:{&quot; + &quot;\\&quot;house_number\\&quot;:\\&quot;324\\&quot;,&quot; // ... + &quot;\\&quot;road\\&quot;:\\&quot;North Tejon Street\\&quot;,&quot; + &quot;\\&quot;city\\&quot;:\\&quot;Colorado Springs\\&quot;,&quot; + &quot;\\&quot;state\\&quot;:\\&quot;Colorado\\&quot;,&quot; + &quot;\\&quot;postcode\\&quot;:\\&quot;80903\\&quot;,&quot; + &quot;\\&quot;country_code\\&quot;:\\&quot;us\\&quot;}&quot; + &quot;}&quot;); AddressRetriever retriever = new AddressRetriever(http); Address address = retriever.retrieve(38.0,-104.0); assertThat(address.houseNumber, equalTo(&quot;324&quot;)); // ... }} 6. 주입 도구mockito 의 내장 DI 기능을 사용해보자.MockitoAnnotations.initMocks(this) 는 다음과 같이 실행된다. 테스트 클래스에서 @Mock 이 붙은 필드를 가져와서 각각에 대해 Mock 인스턴스를 합성한다. mock(Http.class) 를 직접 호출한 것과 동일하다. 그 다음에, @InjectMocks 가 가 붙은 필드를 가져와서 Mock 객체들을 거기에 주입한다. 123456789101112131415161718192021222324252627282930313233public class AddressRetrieverTest { @Mock private Http http; @InjectMocks private AddressRetriever retriever; @Before public void createRetriever() { retriever = new AddressRetriever(); MockitoAnnotations.initMocks(this); } @Test public void answersAppropriateAddressForValidCoordinates() throws IOException, ParseException { when(http.get(contains(&quot;lat=38.000000&amp;lon=-104.000000&quot;))) .thenReturn(&quot;{\\&quot;address\\&quot;:{&quot; + &quot;\\&quot;house_number\\&quot;:\\&quot;324\\&quot;,&quot; // ... + &quot;\\&quot;road\\&quot;:\\&quot;North Tejon Street\\&quot;,&quot; + &quot;\\&quot;city\\&quot;:\\&quot;Colorado Springs\\&quot;,&quot; + &quot;\\&quot;state\\&quot;:\\&quot;Colorado\\&quot;,&quot; + &quot;\\&quot;postcode\\&quot;:\\&quot;80903\\&quot;,&quot; + &quot;\\&quot;country_code\\&quot;:\\&quot;us\\&quot;}&quot; + &quot;}&quot;); Address address = retriever.retrieve(38.0,-104.0); assertThat(address.houseNumber, equalTo(&quot;324&quot;)); assertThat(address.road, equalTo(&quot;North Tejon Street&quot;)); assertThat(address.city, equalTo(&quot;Colorado Springs&quot;)); assertThat(address.state, equalTo(&quot;Colorado&quot;)); assertThat(address.zip, equalTo(&quot;80903&quot;)); }} Mock 객체를 주입하려고 mockito 는 가장 먼저 적절한 생성자를 탐색한다. 없으면, 적절한 setter 메서드를 탐색한다. 없으면, 필드 타입과 매칭되는 적잘한 필드를 찾는다.이러한 기능때문에, AddressRetriever 클래스의 생성자를 제거할 수 있다. 12345public class AddressRetriever { private Http http = new HttpImpl(); public Address retrieve(double latitude, double longitude) { ... Mock 을 사용하면 테스트 커버리지에서 간극이 형성된다. 프로덕션 코드를 직접 테스트하고 있지 않기 때문이다. 그래서, 실제 클래스의 종단 간 사용성을 보여주는 적절한 통합 테스트가 필요하다. 자바와 JUnit 을 활용한 실용주의 단위 테스트 &lt;제프 랭어, 앤디 헌트, 데이브 토마스&gt;","link":"/2020/07/13/unit-test-ch-10/"},{"title":"[전문가를 위한 스프링 5] 4장_스프링 구성 상세와 스프링 부트","text":"1. Bean Life CycleIoC 컨테이너가 제공하는 주요 기능 중 하나는, 빈의 생성이나 소멸 같은 라이프 사이클의 특정 시점에 통지를 받을 수 있도록 빈을 생성하는 것이다.일반적으로 두 가지 라이프사이클 이벤트가 있다. post-initialization event : 스프링이 개발자가 구성한 대로 빈에 모든 프로퍼티 값을 설정하고 의존성 점검을 마치자 마자 발생 pre-destruction event : 스프링이 빈 인스턴스를 소멸시키기 바로 전에 발생 요청을 받을 때 마다 스프링 컨테이너가 매번 빈을 생성하는 Prototype 빈에는, 스프링이 소멸 전 이벤트를 통지하지 않는다. 빈이 이런 라이프사이클 이벤트를 받을 수 있는 메너니즘은 세 가지가 있다. inteface 기반 method 기반 annotation 기반 2. 빈 생성 시점에 통지 받기 빈 생성 시 메서드 실행초기화 메서드로 제대로 빈이 구성되었는지 확인할 수 있다.다음은, xml 파일에 default-init-method 애트리뷰트에 초기화 메서드를 지정하였다. 12345678910111213141516171819202122232425262728public class Singer { private static final String DEFAULT_NAME = &quot;Eric Clapton&quot;; private String name; private int age = Integer.MIN_VALUE; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } private void init() { System.out.println(&quot;빈 초기화&quot;); if (name == null) { System.out.println(&quot;기본 이름 사용&quot;); name = DEFAULT_NAME; } if (age == Integer.MIN_VALUE) { throw new IllegalArgumentException( Singer.class +&quot; 빈 타입에는 반드시 age 프로퍼티를 설정해야 합니다.&quot;); } }} 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-lazy-init=&quot;true&quot; default-init-method=&quot;init&quot;&gt; &lt;bean id=&quot;singerOne&quot; class=&quot;com.apress.prospring5.ch4.Singer&quot; p:name=&quot;John Mayer&quot; p:age=&quot;39&quot;/&gt; &lt;bean id=&quot;singerTwo&quot; class=&quot;com.apress.prospring5.ch4.Singer&quot; p:age=&quot;72&quot;/&gt; &lt;bean id=&quot;singerThree&quot; class=&quot;com.apress.prospring5.ch4.Singer&quot; p:name=&quot;John Butler&quot;/&gt;&lt;/beans&gt; InitializingBean 인터페이스 구현하기위 코드의 init() 메서드와 같은 역할을 하는 afterPropertiesSet() 메서드를 정의한다. 1234567891011121314151617181920212223242526272829public class SingerWithInterface implements InitializingBean { private static final String DEFAULT_NAME = &quot;Eric Clapton&quot;; private String name; private int age = Integer.MIN_VALUE; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void afterPropertiesSet() throws Exception { System.out.println(&quot;빈 초기화&quot;); if (name == null) { System.out.println(&quot;기본 가수 이름 설정&quot;); name = DEFAULT_NAME; } if (age == Integer.MIN_VALUE) { throw new IllegalArgumentException( SingerWithInterface.class +&quot; 빈 타입에는 반드시 age 프로퍼티를 설정해야 합니다.&quot;); } }} JSR-250 @PostConstruct 어노테이션 사용하기빈 클래스 내에서 스프링이 호출할 메서드를 지정한다. 123456789101112131415161718192021222324252627282930public class SingerWithJSR250 { private static final String DEFAULT_NAME = &quot;Eric Clapton&quot;; private String name; private int age = Integer.MIN_VALUE; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @PostConstruct private void init() throws Exception { System.out.println(&quot;빈 초기화&quot;); if (name == null) { System.out.println(&quot;기본 가수 이름 설정&quot;); name = DEFAULT_NAME; } if (age == Integer.MIN_VALUE) { throw new IllegalArgumentException( SingerWithJSR250.class +&quot; 빈 타입에는 반드시 age 프로퍼티를 설정해야 합니다.&quot;); } }} @Bean 으로 초기화 메서드 선언하기자바 구성 클래스에서 빈을 선언할 때 사용한다. @Lazy 는 xml 의 default-lazy-init=”true” 와 동일하다. 123456789101112131415161718192021222324252627282930public class SingerConfigDemo { @Configuration static class SingerConfig { @Lazy @Bean(initMethod = &quot;init&quot;) Singer singerOne() { Singer singerOne = new Singer(); singerOne.setName(&quot;John Mayer&quot;); singerOne.setAge(39); return singerOne; } @Lazy @Bean(initMethod = &quot;init&quot;) Singer singerTwo() { Singer singerTwo = new Singer(); singerTwo.setAge(72); return singerTwo; } @Lazy @Bean(initMethod = &quot;init&quot;) Singer singerThree() { Singer singerThree = new Singer(); singerThree.setName(&quot;John Butler&quot;); return singerThree; } }} 빈 생성은 다음과 같은 단계를 거친다. 빈 생성 위해 생성자 호출 의존성 주입 (수정자 호출) 사전 초기화 담당하는 BeanPostProcessor 기반 빈들에게 호출해야하는 메서드 있는지 확인 요청한다. 여기서 BeanPostProcessor 는 빈이 생성된 이후에 빈 조작을 수행하는 스프링에 특화된 인터페이스다. @PostContruct 어노테이션은 CommonAnnotationBeanPostProcessor 빈에 등록되므로, CommonAnnotationBeanPostProcessor 빈이 @PostContruct 어노테이션이 적용된 메서드 호출 InitializingBean 의 afterPropertiesSet 메서드 실행 init-method 애트리뷰트로 지정한 빈의 실제 초기화 메서드를 마지막에 실행 3. 빈 소멸 시점에 통지 받기 빈이 소멸될 때 메서드를 실행다음은, xml 파일에 destroty-method 애트리뷰트에 소멸 콜백 메서드를 지정하였다. 12345678910111213141516171819202122232425262728public class DestructiveBean { private File file; private String filePath; public void afterPropertiesSet() throws Exception { System.out.println(&quot;빈을 초기화합니다.&quot;); if (filePath == null) { throw new IllegalArgumentException( DestructiveBean.class + &quot;에 filePath 프로퍼티를 지정해야 합니다.&quot;); } this.file = new File(filePath); this.file.createNewFile(); System.out.println(&quot;파일 존재여부: &quot; + file.exists()); } public void destroy() { System.out.println(&quot;빈을 소멸합니다.&quot;); if(!file.delete()) { System.err.println(&quot;에러: 파일 삭제에 실패했습니다.&quot;); } System.out.println(&quot;파일 존재여부: &quot; + file.exists()); }} 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;destructiveBean&quot; class=&quot;com.apress.prospring5.ch4.DestructiveBean&quot; destroy-method=&quot;destroy&quot; init-method=&quot;afterPropertiesSet&quot; p:filePath= &quot;#{systemProperties['java.io.tmpdir']}#{systemProperties['file.separator']}test.txt&quot;/&gt;&lt;/beans&gt; DisposableBean 인터페이스 구현하기destroy() 메서드를 정의한다. 빈 소멸 직전에 호출된다. 12345678910111213141516171819202122232425262728293031public class DestructiveBeanWithInterface implements InitializingBean, DisposableBean { private File file; private String filePath; @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;빈을 초기화합니다.&quot;); if (filePath == null) { throw new IllegalArgumentException( DestructiveBeanWithInterface.class + &quot;에 filePath 프로퍼티를 지정해야 합니다.&quot;); } this.file = new File(filePath); this.file.createNewFile(); System.out.println(&quot;파일 존재 여부: &quot; + file.exists()); } @Override public void destroy() { System.out.println(&quot;빈을 소멸합니다.&quot;); if(!file.delete()) { System.err.println(&quot;에러: 파일 삭제에 실패했습니다.&quot;); } System.out.println(&quot;파일 존재 여부: &quot; + file.exists()); }} JSR-250 @PreDestroy 어노테이션 사용 123456789101112131415161718192021222324252627282930public class DestructiveBeanWithJSR250 { private File file; private String filePath; @PostConstruct public void afterPropertiesSet() throws Exception { System.out.println(&quot;빈을 초기화합니다.&quot;); if (filePath == null) { throw new IllegalArgumentException( DestructiveBeanWithJSR250.class + &quot;에 filePath 프로퍼티를 지정해야 합니다.&quot;); } this.file = new File(filePath); this.file.createNewFile(); System.out.println(&quot;파일 존재 여부: &quot; + file.exists()); } @PreDestroy public void destroy() { System.out.println(&quot;빈을 소멸합니다.&quot;); if(!file.delete()) { System.err.println(&quot;에러: 파일 삭제에 실패했습니다.&quot;); } System.out.println(&quot;파일 존재 여부: &quot; + file.exists()); }} @Bean 을 사용해 소멸 메서드 정의하기자바 구성 클래스에서 빈을 선언할 때 사용한다. 123456789101112131415public class DestructiveBeanConfigDemo { @Configuration static class DestructiveBeanConfig { @Lazy @Bean(initMethod = &quot;afterPropertiesSet&quot;, destroyMethod = &quot;destroy&quot;) DestructiveBeanWithJSR250 destructiveBean() { DestructiveBeanWithJSR250 destructiveBean = new DestructiveBeanWithJSR250(); destructiveBean.setFilePath(System.getProperty(&quot;java.io.tmpdir&quot;) + System.getProperty(&quot;file.separator&quot;) + &quot;test.txt&quot;); return destructiveBean; } }} 4. 빈이 스프링을 알게하기 (Spring Aware) BeanNameAware 인터페이스 사용하기자신에게 부여된 이름을 알고자 하는 빈이 구현해야할 BeanNameAware 인터페이스는 setBeanName() 메서드를 가지고 있다.스프링은 빈 구성을 마친 뒤 라이프사이클 콜백 (초기화 or 소멸) 을 호출하기 전에 setBeanName() 메서드를 호출한다. 123456789101112public class NamedSinger implements BeanNameAware { private String name; /** @Implements {@link BeanNameAware#setBeanName(String)} */ public void setBeanName(String beanName) { this.name = beanName; } public void sing() { System.out.println(&quot;Singer [&quot; + name + &quot;] - sing()&quot;); }} ApplicatoinContextAware 인터페이스 사용하기빈은 자신을 관리하는 ApplicatoinContext 인스턴스의 참조를 얻을 수 있다. 123456789101112public class ShutdownHookBean implements ApplicationContextAware { private ApplicationContext ctx; /** @Implements {@link ApplicationContextAware#setApplicationContext(ApplicationContext)} }*/ public void setApplicationContext(ApplicationContext ctx) throws BeansException { if (ctx instanceof GenericApplicationContext) { ((GenericApplicationContext) ctx).registerShutdownHook(); } }} 전문가를 위한 스프링 5 &lt;율리아나 코스미스&gt;","link":"/2020/07/22/spring-expert-ch-04/"},{"title":"[실용주의 단위 테스트] 11장_테스트 리팩토링","text":"프로덕션 시스템을 리팩토링하는 것 처럼, 테스트를 리팩토링해야한다. 1. 이해 검색이해하기 힘든 다음 테스트 코드를 리팩토링 할 것이다. Test Smell 을 찾으며 리팩토링 해보자. 1234567891011121314151617181920212223242526272829303132333435363738394041public class SearchTest { @Test public void testSearch() { try { String pageContent = &quot;There are certain queer times and occasions &quot; + &quot;in this strange mixed affair we call life when a man &quot; + &quot;takes this whole universe for a vast practical joke, &quot; + &quot;though the wit thereof he but dimly discerns, and more &quot; + &quot;than suspects that the joke is at nobody's expense but &quot; + &quot;his own.&quot;; byte[] bytes = pageContent.getBytes(); ByteArrayInputStream stream = new ByteArrayInputStream(bytes); // search Search search = new Search(stream, &quot;practical joke&quot;, &quot;1&quot;); Search.LOGGER.setLevel(Level.OFF); search.setSurroundingCharacterCount(10); search.execute(); assertFalse(search.errored()); List&lt;Match&gt; matches = search.getMatches(); assertThat(matches, is(notNullValue())); assertTrue(matches.size() &gt;= 1); Match match = matches.get(0); assertThat(match.searchString, equalTo(&quot;practical joke&quot;)); assertThat(match.surroundingContext, equalTo(&quot;or a vast practical joke, though t&quot;)); stream.close(); // negative URLConnection connection = new URL(&quot;http://bit.ly/15sYPA7&quot;).openConnection(); InputStream inputStream = connection.getInputStream(); search = new Search(inputStream, &quot;smelt&quot;, &quot;http://bit.ly/15sYPA7&quot;); search.execute(); assertThat(search.getMatches().size(), equalTo(0)); stream.close(); } catch (Exception e) { e.printStackTrace(); fail(&quot;exception thrown in test&quot; + e.getMessage()); } }} 2. 테스트 냄새 : 불필요한 테스트 코드테스트 메서드에서 try/catch 의 가치는 없다. try/catch 블록을 제거하고 IOException 을 던지도록 변경하자. 12345public class SearchTest { @Test public void testSearch() throws IOException { String pageContent = ... 그리고, 아래 코드에서 not-null 단언이 필요할까 ? 123List&lt;Match&gt; matches = search.getMatches();assertThat(matches, is(notNullValue()));assertTrue(matches.size() &gt;= 1); matches.size() 에서 matches 가 null 을 참조한다면 예외를 던질 것이다.따라서 다음과 같이 수정하자. 12List&lt;Match&gt; matches = search.getMatches();assertTrue(matches.size() &gt;= 1); 3. 테스트 냄새 : 추상화 누락잘 구성된 테스트 시스템은 다음 세 가지 관점으로 구성된다. 데이터 준비 시스템과 동작 결과 단언 각 단계를 위해 자세한 코드가 필요할 수 있지만, 세부 사항을 추상화하여 이해하기 쉽게 만들 수 있다.아래 코드는, 매칭된 목록이 특정 검색 문자열과 주변 맥락을 포함하는 단일 항목을 포함하고 있는지 테스트한다. 12345List&lt;Match&gt; matches = search.getMatches();assertTrue(matches.size() &gt;= 1);Match match = matches.get(0);assertThat(match.searchString, equalTo(&quot;practical joke&quot;));assertThat(match.surroundingContext, equalTo(&quot;or a vast practical joke, though t&quot;)); 이는, 사용자 정의 단언문으로 수정할 수 있다.아래 코드의, containsMatches 는 ContainMatchers 사용자 정의 클래스의 static method 이다. (코드는 생략) 123456789public class SearchTest { @Test public void testSearch() throws IOException { ... assertThat(search.getMatches(), containsMatches(new Match[] { new Match(&quot;1&quot;, &quot;practical joke&quot;, &quot;or a vast practical joke, though t&quot;) })); }} 또, 다음 코드는 결과 크기가 0 인지 단언하는 코드이다. 1assertThat(search.getMatches().size(), equalTo(0)); 다음과 같이 변경할 수 있다. 1assertTrue(search.getMatches().isEmpty()); 4. 테스트 냄새 : 부적절한 정보다음 코드들은 불분명한 매릭 리터럴 (상수로 선언되지 않은 숫자 리터럴) 를 포함하고 있다.문자열 “1” 이 무엇을 의미하는지 확신할 수 없다. 1Search search = new Search(stream, &quot;practical joke&quot;, &quot;1&quot;); 123assertThat(search.getMatches(), containsMatches(new Match[] { new Match(&quot;1&quot;, &quot;practical joke&quot;, &quot;or a vast practical joke, though t&quot;) })); 다음처럼, 의미 있는 이름을 가진 상수를 도입해서 의미를 바로 파악할 수 있도록 하자. 123456789public class SearchTest { private static final String A_TITLE = &quot;1&quot;; @Test public void testSearch() throws IOException { ... Search search = new Search(stream, &quot;practical joke&quot;, A_TITLE); ... }} 5. 테스트 냄새 : 부푼 생성12345678910111213public class SearchTest { private static final String A_TITLE = &quot;1&quot;; @Test public void testSearch() throws IOException { String pageContent = &quot;There are certain queer times and occasions &quot; + &quot;in this strange mixed affair we call life when a man &quot; + &quot;takes this whole universe for a vast practical joke, &quot; + &quot;though the wit thereof he but dimly discerns, and more &quot; + &quot;than suspects that the joke is at nobody's expense but &quot; + &quot;his own.&quot;; byte[] bytes = pageContent.getBytes(); ByteArrayInputStream stream = new ByteArrayInputStream(bytes); ... 위 코드는 다음과 같이 도우미 메서드를 통해, 세부 사항을 숨길 수 있다. 12345678910111213141516171819public class SearchTest { private static final String A_TITLE = &quot;1&quot;; @Test public void testSearch() throws IOException { InputStream stream = streamOn(&quot;There are certain queer times and occasions &quot; + &quot;in this strange mixed affair we call life when a man &quot; + &quot;takes this whole universe for a vast practical joke, &quot; + &quot;though the wit thereof he but dimly discerns, and more &quot; + &quot;than suspects that the joke is at nobody's expense but &quot; + &quot;his own.&quot;); ... } private InputStream streamOn(String pageContent) { return new ByteArrayInputStream(pageContent.getBytes()); }} 6. 테스트 냄새 : 다수의 단언여러 개의 단언이 있다는 것은 테스트 케이스를 여러 개 포함하고 있다는 증거이다.테스트를 분할해라.테스트마다 단언이 한개이면 테스트 메서드명을 깔끔하게 만들 수 있다. 123456789101112131415public class SearchTest { private static final String A_TITLE = &quot;1&quot;; @Test public void returnsMatchesShowingContextWhenSearchStringInContent() throws IOException { ... } @Test public void noMatchesReturnedWhenSearchStringNotInContent() throws MalformedURLException, IOException { ... }} 7. 테스트 냄새 : 테스트와 무관한 세부 사항들군더더기들은 @Before 와 @After 메서드로 이동해라. 테스트를 이해하는데 필요한 유용한 정보는 옮기지 말아라 1234567891011121314public class SearchTest { private static final String A_TITLE = &quot;1&quot;; private InputStream stream; @Before public void turnOffLogging() { Search.LOGGER.setLevel(Level.OFF); } @After public void closeResources() throws IOException { stream.close(); }} 자바와 JUnit 을 활용한 실용주의 단위 테스트 &lt;제프 랭어, 앤디 헌트, 데이브 토마스&gt;","link":"/2020/08/06/unit-test-ch-11/"},{"title":"Redis 운영 관리","text":"Redis 주요 특성 Key-Value Store : 단순 스트링에 대한 key/Value 구조를 지원 컬렉션 지원 : List, Set, Sorted Set, Hash 등의 자료구조를 지원 Pub/Sub 지원 : 서버간에 통지가 필요할 때 유용 디스크 저장 : 현재의 메모리 상태를 디스크에 저장 가능 복제 : 다른 노드에서 해당 내용을 복제할 수 있는 master/slave 구조 지원 빠른 속도 : 초당 50,000 ~ 60,000 QPS 이상의 처리 속도 지원 Single ThreadRedis 는 싱글 스레드이다. 그래서,시간이 오래 걸리는 Redis 명령을 호출하면, 명령을 처리하는 동안 다른 client 의 요청을 처리할 수 없다.이런 특성 때문에 주의해야하는 경우가 몇 가지 있다. 서버에서 keys 명령을 사용하지 마라.keys 명령은 서버에 저장된 key 목록을 볼 수 있는 명령이다.모든 key 를 대상으로 검색한다. 작업하는 동안 다른 client 의 요청을 처리할 수 없다. flushall/flushdb 명령을 주의해라.redis 는 db 라는 가상의 공간을 분리할 수 있는 개념이 있는데, select 명령으로 이동할 수 있다.그래서, 같은 key 이름이라도 db 개수에 따라 여러 개 만들 수 있다. 예를 들면, 1234567select 0set jko &quot;1234&quot;select 1set jko &quot;5678&quot;get jko --&gt; 결과 : 5678select 0get jko --&gt; 결과 : 1234 flushdb 는 하나의 db 를 선택해서 지우고, flushall 은 데이터 전체 내용을 지운다.flushall 의 경우 실제 존재하는 모든 데이터를 일일이 삭제하는데, 속도가 O(n) 이기때문에 데이터 양에 영향을 받는다.작업하는 동안 다른 client 의 요청을 처리할 수 없다. Persistent : RDB/AOFRedis 는 데이터를 디스크로 저장할 수 있는 Persistent 기능을 제공한다.Redis 에서 제공하는 RDB 와 AOF 기능을 정리해보자. RDB'RDBMS' 가 아니라, 단순히 Redis 의 메모리 스냅샷을 파일로 저장한 파일 확장자이다.Redis 는 지속적인 서비스와 RDB 저장을 위해, fork 를 통해 자식 프로세스를 생성한다.이 RDB 저장을 위한 명령으로 SAVE 와 BGSAVE 가 있다.SAVE는, 모든 작업을 멈추고 현재 메모리 상태에 대한 RDB 파일을 생성한다.BGSAVE는, 자식 프로세스에서 RDB 파일을 생성한다. AOF (Append Only File)클라이언트가 Redis 에 업데이트 관련 명령을 요청하면, Redis 는 해당 명령을 AOF 에 저장한다.그리고, 실제로 해당 명령을 실행해서 메모리 내용을 변경한다. RDB 를 저장할 때 fork 를 사용하여 문제가 되는 경우이전에는 OS 가 자식 프로세스를 생성하면, 부모 프로세스의 메모리를 모두 자식 프로세스에 복사해야했다.예를 들면, 부모 프로세스가 10 GB 메모리를 사용 중이라면, 자식 프로세스를 생성할 때 10 GB 메모리가 필요했다.그런데 OS 가 발전하면서, COW (Copy On Write) 기술이 개발되었다. 그래서,최초에 fork 로 자식 프로세스가 생성되면 부모 프로세스와 자식 프로세스는 같은 메모리를 공유한다.그리고, 자식 프로세스에 write 가 발생할 때마다, 공유하는 해당 데이터는 자식 프로세스에 복사된다.write 작업이 많아지면 부모 페이지에 있는 모든 페이지가 자식 프로세스에 복사되어 사용 메모리 양이 결국 두 배가 된다. Read 는 가능한데 Write 만 실패하는 경우Redis 기본 설정상, RDB 저장이 실패하면 해당 장비에 이상이 있다고 판단하여 write 명령을 처리하지 않고, 데이터가 변경되지 않도록 관리한다.즉, read 가능하지만 write 가 불가능한 경우이다.그렇다면, RDB 생성이 실패하는 경우는 언제가 있을까 ? RDB 저장할 수 있는 정도의 디스크 여유가 없는 경우 실제 디스크 고장 메모리 부족으로 자식 프로세스를 생성하지 못한 경우 강제적으로 자식 프로세스를 종료시킨 경우 Redis 복제 : master/slaveredis 복제 모델은 master/slave 구조이다. 주의할점은, 하나의 slave 는 오직 하나의 master 만 가질 수 있다.복제 과정은 다음과 같다. slave 에서 slaveof 명령을 통해, master 서버를 설정 master 는 복제를 위해 RDB 생성 후에, 슬레이브에 전송 슬레이브는 RDB 를 로드하고 나머지 차이에 대한 명령을 마스터에서 전달받아 복제 완료 master 장애시, slave 모든 내용이 사라지는 경우 slave 는 master 의 상태를 지속적으로 체크한다. master 와의 연결 상태 이상을 slave 가 감지한다. slave 에서 master 와의 연결 상태가 복원된 것을 확인한다. 이제, slave 는 master 의 모든 내용을 가져온다. 그런데, 마스터에 장애가 발생해서 master 에 데이터가 하나도 없으면 slave 의 모든 내용은 사라진다. 왜 모든 내용이 사라질까 ?왜냐하면, 슬레이브는 마스터와 동일한 데이터를 유지하기 위해 RDB 를 읽어들이기 전에 현재 자신의 데이터를 모두 삭제하고 마스터와 싱크를 맞추기 때문이다.그래서, 마스터에 장애가 발생하면 슬레이브에 slaveof no one 명령을 줘서더 이상 슬레이브로 동작하지 않도록 하여, 현재까지의 모든 데이터를 보존할 수 있다. 복제 시, RDB 는 무조건 백그라운드로 생성복제를 하면, 사용자 설정과 무관하게 슬레이브에 전달할 RDB 를 만들기 위해 fork 를 해서 RDB 를 생성한다.따라서, 하나의 프로세스가 너무 많은 메모리를 사용하지 않도록 나눌 필요가 있다. Redis HA, Sentinelmaster/slave 형태로 서비스 하기 위해서는, 다음과 같은 기능이 필요하다. 마스터 장애 판별 슬레이브를 마스터로 승격 해당 작업 내용을 클라이언트에게 통지 위와 같은 기능을 Sentinel 이라는 데몬을 이용해 처리할 수 있다.다만, 3번 같은 경우 Sentinel 에서 이미 장애 발생한 마스터에 접속한 클라이언트를 알 수 없으므로, 해당 알림을 원하는 클라이언트는 Redis Pub/Sub 으로 Sentinel 에 등록해야한다.즉, 마스터에 장애가 발생하면 처리 순서는 다음과 같다. Sentinel 은 슬레이브 중에 한대를 선택해서 마스터로 승격 Sentinel 은 클라이언트에 Pub/Sub 으로 통지 클라이언트가 connection 을 승격된 마스터로 변경 Redis 운영 관리 &lt;강대명&gt;","link":"/2020/08/14/redis/"},{"title":"Shallow Copy, Deep Copy","text":"CloneObject 클래스에는 인스턴스 복사를 위한 clone 메서드가 정의되어 있다.이 메서드가 호출되면, 호출된 인스턴스의 복사본이 생성되고 이 복사본의 참조값이 반환된다. 다음과 같이 Point 클래스가 있다고 하자. Cloneable 인터페이스를 구현하고 있다. 123456789101112131415161718public class Point implements Cloneable { private int x; private int y; public Point(int x, int y) { this.x = x; this.y = y; } public void showPositions() { System.out.println(x + &quot; &quot; + y); } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); }} clone 메서드는 다음과 같이 호출해서 사용한다. 123456789101112@Testpublic void test_clone() { Point origin = new Point(1, 2); try { Point copy = (Point) origin.clone(); origin.showPositions(); copy.showPositions(); } catch (CloneNotSupportedException e) { e.printStackTrace(); }} 결과는 다음과 같다. 지금까지의 상황을 그림으로 그려 보면 다음과 같다. Shallow Copy이번에는 Point 클래스에 changePosition 메서드를 추가해보자. 1234567891011121314151617181920212223public class Point implements Cloneable { private int x; private int y; public Point(int x, int y) { this.x = x; this.y = y; } public void showPositions() { System.out.println(x + &quot;, &quot; + y); } public void changePosition(int x, int y){ this.x = x; this.y = y; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); }} 그리고, 위 Point 클래스를 인스턴스 변수로 가지는 Rectangle 클래스를 추가해보자. 1234567891011121314151617181920212223242526272829public class Rectangle implements Cloneable { private Point upperLeft; private Point lowerRight; public Rectangle(int x1, int y1, int x2, int y2) { this.upperLeft = new Point(x1, y1); this.lowerRight = new Point(x2, y2); } public void showPosition() { System.out.print(&quot;upperLeft : &quot;); upperLeft.showPositions(); System.out.print(&quot;lowerRight : &quot;); lowerRight.showPositions(); System.out.println(); } public void changePosition(int x1, int y1, int x2, int y2) { upperLeft.changePosition(x1, y1); lowerRight.changePosition(x2, y2); } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); }} 다음과 같이 clone 을 호출하는 clinet code 를 작성해서 실행해보자. 123456789101112131415@Testpublic void test_shallow_copy() { Rectangle origin = new Rectangle(1, 1, 10, 10); Rectangle copy; try { copy = (Rectangle) origin.clone(); origin.changePosition(2, 2, 8, 8); origin.showPosition(); copy.showPosition(); } catch (CloneNotSupportedException e) { e.printStackTrace(); }} 결과는 다음과 같다. origin 의 position 만 변경하였는데도, copy 의 position 까지 변경된것을 알 수 있다. 어떻게 이런 결과가 나왔는지 정리해보자. 우선, clone 을 통해서 다음과 같이 Rectangle instance 를 복사하였다. 하지만, Object 클래스의 clone 메서드는 인스턴스의 변수에 저장되어 있는 값을 복사할 뿐, 참조하는 대상 자체를 복사하지는 않는다.즉, upperLeft 와 lowerRight 의 참조값이 복사된 것이지 참조변수가 가리키는 인스턴스 자체가 복사된 것은 아니다. 이것이 얕은 복사, Shallow Copy 이다. Deep Copy그렇다면, 참조변수가 가리키는 인스턴스 자체를 복사하기 위해서는 어떻게 해야할까 ?이를 위한 문법은 지원하지 않는다. 직접 코드 구현을 해야한다.Point 클래스는 위 shallow copy 와 동일하다. 1234567891011121314151617181920212223public class Point implements Cloneable { private int x; private int y; public Point(int x, int y) { this.x = x; this.y = y; } public void showPositions() { System.out.println(x + &quot;, &quot; + y); } public void changePosition(int x, int y){ this.x = x; this.y = y; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); }} Rectangle 클래스의 clone 메서드를 수정해보자. 1234567891011121314151617181920212223242526272829303132333435public class Rectangle implements Cloneable { private Point upperLeft; private Point lowerRight; public Rectangle(int x1, int y1, int x2, int y2) { this.upperLeft = new Point(x1, y1); this.lowerRight = new Point(x2, y2); } public void showPosition() { System.out.print(&quot;upperLeft : &quot;); upperLeft.showPositions(); System.out.print(&quot;lowerRight : &quot;); lowerRight.showPositions(); System.out.println(); } public void changePosition(int x1, int y1, int x2, int y2) { upperLeft.changePosition(x1, y1); lowerRight.changePosition(x2, y2); } @Override protected Object clone() throws CloneNotSupportedException { // ------------- HERE Rectangle copy = (Rectangle) super.clone(); copy.upperLeft = (Point) upperLeft.clone(); copy.lowerRight = (Point) lowerRight.clone(); // ------------- HERE return copy; }} 그리고 이제 client code 에서 실행해보자. 123456789101112131415@Testpublic void test_deep_copy() { Rectangle origin = new Rectangle(1, 1, 10, 10); Rectangle copy; try { copy = (Rectangle) origin.clone(); origin.changePosition(2, 2, 8, 8); origin.showPosition(); copy.showPosition(); } catch (CloneNotSupportedException e) { e.printStackTrace(); }} 결과는 다음과 같다. shallow copy 와 다르게, origin 의 position 을 변경하였지만, copy 에는 영향이 없다. 지금까지의 상황을 정리하면 다음과 같다. 이것이 깊은 복사, Deep Copy 이다. String Copy인스턴스 변수가 String 인 경우를 고려해보자. 우선 다음 코드를 보자.다음과 같이 Person 클래스가 있다. 123456789101112131415161718192021222324public class Person implements Cloneable { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public void changeName(String name){ this.name = name; } public void showPerson(){ System.out.println(&quot;name : &quot; + name); System.out.println(&quot;age : &quot; + age); System.out.println(); } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); }} 그리고, 위 Person 을 복사하는 다음 코드가 있다. 1234567891011121314151617@Testpublic void test_string_copy() { Person jko = new Person(&quot;jko&quot;, 29); try { Person junhee = (Person) jko.clone(); junhee.changeName(&quot;junhee&quot;); Person ko = (Person) junhee.clone(); ko.changeName(&quot;ko&quot;); jko.showPerson(); junhee.showPerson(); ko.showPerson(); } catch (CloneNotSupportedException e) { e.printStackTrace(); }} 실행 결과는, deep copy 와 같이 서로 영향이 없다. 어떻게 이렇게 되었는지 확인해보자. 우선, 처음에 junhee 를 clone 하였을 때 상황은 다음과 같다. 그리고, ko 가 참조하는 인스턴스의 문자열을 변경시킨다. 그러면 결과는 다음과 같다. 난 정말 JAVA 를 공부한적이 없다구요 &lt;윤성우&gt;","link":"/2020/08/23/shallow-deep-copy/"},{"title":"Collection Framework - List","text":"Java Collection Framework 의 List 를 정리한다. 1. Collection Framework우선, Collection Framework 가 무엇일까.공식 문서 (https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html)에 따르면 다음과 같이 정의되어 있다. 컬렉션 프레임 워크는 컬렉션을 표현하고 조작하기위한 통합 아키텍처로, 구현 세부 사항과 독립적으로 컬렉션을 조작 할 수 있습니다. 컬렉션 프레임워크를 사용하면, 내부 구현을 몰라도 컬렉션을 일관된 방식으로 조작할 수 있다는 것을 알 수 있다.그렇다면, 컬렉션이란 무엇일까 ? 공식 문서에 따르면, 컬렉션은 객체 그룹 (예 : 클래식 Vector 클래스)을 나타내는 객체입니다. 조금 더 구체적으로 정리하면, 컬렉션은 자료구조 (데이터 저장) 와 알고리즘 (데이터 연산) 을 클래스로 구현해 놓은 것이다. 2. Architecture컬랙션 프레임워크의 인터페이스 구조는 아래와 같다.List, Set, Queue 인터페이스가 Collection 인터페이스를 상속하고 있다. 각각의 인터페이스를 앞으로 정리할 예정이다. 2. List 위와 같이, List 인터페이스를 구현하는 구체 클래스로는 ArrayList 와 LinkedList 가 이 있다. 이 둘의 공통점은, 동일한 인스턴스의 중복 저장 허용 인스턴스 저장 순서 유지 그렇다면 이 둘의 차이점은 무엇일까 ?가장 큰 차이는, 내부적으로 인스턴스를 저장하는 방식에 차이가 있다.각각의 특징을 파악하며 이해해보자. 3. ArrayListArrayList 는 내부적으로 배열을 이용해서 인스턴스의 참조 값을 저장한다.ArrayList 의 add 연산을 보면, 아래와 같이 size+1 인덱스에 저장하는 것을 알 수 있다. 12345public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} 이러한 특징을 기반으로 장단점을 다음과 같이 정리할 수 있다. 장점데이터의 참조가 용이해서 빠른 참조 가능 : 배열 기반이기 때문에 인덱스 값을 알면 바로 접근이 가능하기 때문. 단점저장소 용량을 늘리는 과정이 복잡 : 배열은 한 번 생성되면 길이를 변경시킬 수 없어서, 용량을 늘리면 배열 인스턴스를 생성해야하고 기존 데이터를 복사해야하기 때문.데이터 삭제 연산 과정이 복잡 : 특정 위치의 데이터를 지울 때, 그 뒤에 저장된 데이터들을 한 칸씩 앞으로 이동해야하기 때문. 4. LinkedList LinkedList 는 위와 같이 노드 간에 서로 연결하는 방식으로 데이터를 저장한다.LinkedList 의 add 연산을 보면, 마지막 노드에 새로운 노드를 연결하는 것을 알 수 있다. 1234public boolean add(E e) { linkLast(e); return true;} 1234567891011void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;} 이러한 특징을 기반으로 장단점을 다음과 같이 정리할 수 있다. 장점저장소 용량을 늘리는 과정이 간단데이터 삭제 연산 과정이 간단 단점데이터 참조가 불편 : 연결되어 있는 노드들을 순회해야하기 때문 난 정말 JAVA 를 공부한적이 없다구요 &lt;윤성우&gt;","link":"/2020/08/29/collection-framework-list/"},{"title":"Collection Framework - Iterable","text":"Collection 인터페이스는 아래과 같이 Iterable 인터페이스를 상속하고 있다. Iterable 인터페이스가 무엇인지 정리해보자. 1. IteratorIterable 인터페이스에는 다음 세개의 메서드가 정의되어 있다. 여기서 iterator 메서드가 정의되어 있는데, Iterator 인터페이스를 반환한다.즉, iterator 메서드를 호출하면 Iterator 인터페이스를 구현한 클래스의 인스턴스 참조 값을 반환한다.그리고 Iterator 인터페이스에는 다음 네 개의 메서드가 정의되어 있다. Iterator 의 사용법은 아래와 같다. 12345678910111213141516public class IteratorExample { public static void main(String[] args) { LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) { Integer currentInteger = iterator.next(); System.out.println(currentInteger); } }} LinkedList 의 iterator() 를 호출하면,LinkedList 가 상속하고 있는 추상 클래스인 AbstractSequentialList 의 iterator() 가 호출이 된다. 2. 필요성그런데, Collection 인터페이스가 Iterable 인터페이스를 상속하고 있는 이유가 뭘까 ?컬렉션 클래스의 종류에 상관없이 일관된 형태의 데이터 참조방식을 지원하기 위해서이다.예를들면,List 인터페이스를 구현하고 있는 LinkedList 나, Set 인터페이스를 구현하는 HashSet 이나 모두 동일한 방식으로 데이터 참조가 가능하다. 난 정말 JAVA 를 공부한적이 없다구요 &lt;윤성우&gt;","link":"/2020/08/30/collection-framework-iterator/"},{"title":"Collection Framework - HashSet","text":"Collection Framework 의 인터페이스 구조는 다음과 같다. 여기서, Set 인터페이스를 구현하는 클래스로는 HashSet, TreeSet 이 있다.HashSet 클래스를 정리해보자. 1. Set 인터페이스Set 인터페이스를 구현하는 클래스는 다음 특징을 가진다. 데이터 저장 순서를 유지하지 않음 데이터의 중복 저장을 허용하지 않음 2. HashSet - 예시 01HashSet 은 다음과 같이 사용할 수 있다. 1234567891011121314@Testpublic void test_hash_set() { HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(&quot;E&quot;); hashSet.add(&quot;C&quot;); hashSet.add(&quot;B&quot;); hashSet.add(&quot;A&quot;); hashSet.add(&quot;E&quot;); Iterator&lt;String&gt; iterator = hashSet.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }} 출려 결과는 다음과 같다. 1234ABCE 출력 결과를 보면, 데이터 저장 순서를 유지하지 않았고, 데이터 중복을 허용하지 않았다. 그런데, 어떻게 데이터 중복을 허용하지 않은걸까 ? 어떻게 동일한 데이터인지 아닌지를 구분한걸까 ? 3. HashSet - 예시 02다음과 같이, int 형 변수 num 을 하나 가지는 클래스가 있다고 하자. 12345678public class MyNumber { int num; public MyNumber(int num) { this.num = num; }} 그리고 다음과 같이 테스트해보자. 123456789@Testpublic void test_hash_set_same_number(){ HashSet&lt;MyNumber&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(new MyNumber(1)); hashSet.add(new MyNumber(2)); hashSet.add(new MyNumber(2)); assertEquals(3, hashSet.size());} 위와 같이, new MyNumber(2) 를 두 번 저장하지만, 위 테스트 코드는 통과한다.데이터 중복을 허용하지 않는 HashSet 인데 왜 중복을 허용한걸까? 왜냐하면, MyNumber(2) 를 서로 다른 인스턴스로 간주했기 때문이다.어떻게 서로 다른 인스턴스로 간주한걸까 ?HashSet 은 해쉬 알고리즘을 적용해서 데이터를 저장하고 검색한다. 해쉬 알고리즘이 무엇인지 정리해보자. 3. Hash다음과 같은 해쉬 알고리즘이 있다. 1num % 3 어떤 숫자를 3 으로 나눈 나머지가, 숫자 분류의 기준이 되는 것이다. (이 기준 값을 해쉬 값이라고 한다.)예를 들어, 다음과 같이 6 개의 숫자고 있다고 하자. 13 5 7 10 1 2 위 숫자들에 해쉬 알고리즘을 적용하면 세 그룹으로 묶을 수 있다. 나머지 결과 == 0 –&gt; 3 나머지 결과 == 1 –&gt; 7, 10, 1 나머지 결과 == 2 -&gt; 5, 2 이 때, 5 가 6 개 의 숫자 리스트에 존재하는지 어떻게 확인 할 수 있을까 ? 5 를 3 으로 나눈 나머지를 구한다. 2 이다. 그리고, 나머지 결과 == 2 인 그룹에서 5 가 존재하는지 찾는다. 위와 같은 순으로 5 가 존재하는지 찾으면, 검색의 대상이 줄어드는 것을 알 수 있다. 따라서, 검색 속도가 굉장히 빠르다.위와 같은 해쉬 알고리즘을 적용하는 HashSet 은 다음과 같이 중복 데이터 여부를 확인한다. Object 클래스의 hashCode 메서드 반환 값으로 해쉬 값 결정 Object 클래스의 equals 메서드 반환 값으로 내용 비교 위 두 메서드를 오버라이딩 하지 않으면, 기본적으로 hashCode 메서드는, 인스턴스가 다르면 내용에 상관 없이 다른 해쉬 값을 반환하고 equals 메서드는, 내용 비교가 아니라 참조 값 비교만 하도록 정의되어 있다. 3. 결과String 을 저장한 예시 01 에서는, String 클래스가 위 두 메서드를 오버라이딩하고 있기 때문에, 중복 데이터인 여부를 판단할 수 있었던 것이다.MyNumber 를 저장한 예시 02 에서는 위 두 메서드를 오버라이딩하지 않았다. 그래서, new MyNumber(2) 를 각각 서로 다른 인스턴스로 보고 서로 다른 해쉬 값을 반환했고, 내용인 2를 비교한 것이 아니라, 참조 값 비교만 한 것이다. 그래서, new MyNumber(2) 를 동일한 데이터로 간주하기 위해 오버라이딩 해보자. 12345678910111213141516171819202122public class MyNumber { int num; public MyNumber(int num) { this.num = num; } @Override public int hashCode() { return this.num % 3; } @Override public boolean equals(Object obj) { MyNumber myNumber = (MyNumber) obj; if (myNumber.num == this.num) { return true; } else { return false; } }} 그러면, 아래 테스트 코드는 성공한다. 123456789@Testpublic void test_hash_set_same_number(){ HashSet&lt;MyNumber&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(new MyNumber(1)); hashSet.add(new MyNumber(2)); hashSet.add(new MyNumber(2)); assertEquals(2, hashSet.size());} 난 정말 JAVA 를 공부한적이 없다구요 &lt;윤성우&gt;","link":"/2020/08/31/collection-framework-set/"},{"title":"Collection Framework - TreeSet","text":"Collection Framework 의 인터페이스 구조는 다음과 같다. 여기서, Set 인터페이스를 구현하는 클래스로는 HashSet, TreeSet 이 있다.TreeSet 클래스를 정리해보자. 1. Set 인터페이스Set 인터페이스를 구현하는 클래스는 다음 특징을 가진다. 데이터 저장 순서를 유지하지 않음 데이터의 중복 저장을 허용하지 않음 2. TreeSet - 예시 01TreeSet 은 Set 의 위 두 가지 특성을 모두 만족한다. 그리고, 다음 특성도 만족한다.3. 데이터를 정렬된 상태로 유지다음 코드로, 확인해보자. 123456789101112131415@Testvoid tree_set() { TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;(); treeSet.add(30); treeSet.add(20); treeSet.add(30); treeSet.add(10); treeSet.add(40); Iterator&lt;Integer&gt; iterator = treeSet.iterator(); while (iterator.hasNext()){ Integer currentInteger = iterator.next(); System.out.println(currentInteger); }} 출력 결과는 아래와 같이, 30 을 중복으로 저장하지 않고 정렬 상태를 유지한다. 123410203040 3. TreeSet - 예시 02그런데, 다음과 같이 정의된 클래스의 인스턴스가 TreeSet 에 저장하는 대상이라면정렬 기준은 뭘까 ? 123456789public class IamPerson { private String name; private Integer age; public IamPerson(String name, Integer age) { this.name = name; this.age = age; }} 정렬 기준을 알 수 없다.왜냐하면 name 으로 할 것인지 age 로 할 것인지, 정렬 기준을 정하지 않았기 때문이다. 4. Comparable그래서, 위의 IamPerson 클래스는 Comparable 인터페이스를 구현해서 정렬 기준을 명시해야한다. 1234567891011121314151617181920public class IamPerson implements Comparable&lt;IamPerson&gt; { private String name; private Integer age; public IamPerson(String name, Integer age) { this.name = name; this.age = age; } @Override public int compareTo(IamPerson person) { if (this.age &gt; person.age) { return 1; } else if (this.age &lt; person.age) { return -1; } else { return 0; } }} 그리고, 아래와 같이 테스트 코드를 실행하면, 12345678910111213@Testvoid tree_set_comparable() { TreeSet&lt;IamPerson&gt; treeSet = new TreeSet&lt;&gt;(); treeSet.add(new IamPerson(&quot;junee&quot;, 29)); treeSet.add(new IamPerson(&quot;jko&quot;, 13)); treeSet.add(new IamPerson(&quot;ko&quot;, 35)); Iterator&lt;IamPerson&gt; iterator = treeSet.iterator(); while (iterator.hasNext()) { IamPerson next = iterator.next(); next.show(); }} 다음과 같이 나이순으로 오름차순 출력이 되는 것을 알 수 있다. 123jko 13junee 29ko 35 5. Comparator정렬 기준을 제시하는 두 번째 방법으로,Comparator 인터페이스를 구현한 구체 클래스를 TreeSet 의 생성자에 전달할 수 있다.TreeSet 클래스에, Comparator 를 인자로 받을 수 있는 생성자가 다음과 같이 정의되어 있다. 이제, 아래 코드와 같이 Comparator 인터페이스를 구현해보자. 12345678910111213public class IamComparator implements Comparator&lt;String&gt; { @Override public int compare(String o1, String o2) { if (o1.length() &gt; o2.length()) { return 1; } else if (o1.length() &lt; o2.length()) { return -1; } else { return 0; } }} 그리고, 아래와 같이 테스트 코드를 실행해보면, 12345678910111213141516@Testvoid test_comparator() { IamComparator iamComparator = new IamComparator(); TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;(iamComparator); treeSet.add(&quot;A&quot;); treeSet.add(&quot;AAAAAA&quot;); treeSet.add(&quot;AA&quot;); treeSet.add(&quot;AAAA&quot;); treeSet.add(&quot;AAAAAAAA&quot;); Iterator&lt;String&gt; iterator = treeSet.iterator(); while (iterator.hasNext()){ String currentString = iterator.next(); System.out.println(currentString); }} 문자열 순서대로 출력이 되는 것을 알 수 있다. 12345AAAAAAAAAAAAAAAAAAAAA 난 정말 JAVA 를 공부한적이 없다구요 &lt;윤성우&gt;","link":"/2020/09/01/collection-framework-tree-set/"},{"title":"[도커&#x2F;쿠버네티스] 1장_도커란?","text":"가상 머신과 도커 컨테이너 가상 머신기존의 가상화 기술은, 하이퍼바이저를 이용해 여러 개의 운영체제 (= Guest OS) 를 하나의 호스트에서 생성해 사용하는 방식이었다. 각 Guest OS 는 다른 Guest OS 와 완전히 독립된 공간과 시스템 자원을 할당받아 사용한다.시스템 자원 가상화하고 독립된 공간 생성 작업은 항상 하이퍼바이저를 거치기 때문에 일반 호스트에 비해 성능 손실이 발생한다.그리고, Guest OS 를 사용하기 위한 라이브러리, 커널 등을 전부 포함하여 가상 머신을 배포하기 위한 이미지를 만들었을 때 크기가 크다. 도커 컨테이너도커 컨테이너는, 가상화된 공간을 생성하기 위해 리눅스의 자체 기능은 chroot, namespace, cgroup 을 사용하여 프로세스 단위로 격리된 환경을 만든다.컨테이너에 필요한 커널은 호스트의 커널을 공유해 사용하고, 컨테이너 안에는 애플리케이셔을 구동하기 위한 라이브러리 및 실행파일만 존재하여 이미지로 만들었을 때 크기가 작다. 도커의 장점 애플리케이션의 개발과 배포가 편해진다.독립된 개발환경도커 컨테이너는 호스트 OS 위에서 실행되는 격리된 공간이기 때문에, 컨테이너 내부에서 수많은 소프트웨어를 설치하고 설정 파일을 수정해도 호스트 OS 에는 영향을 끼치지 않는다.개발/운영환경의 통합컨테이너 내부에서 작업을 마친 뒤 운영 환경에 배포하려고 하면, 해당 컨테이너를 ‘도커 이미지’ 라는 패키지로 만들어 운영서버어 전달만 하면 된다.빠른 배포도커 이미지는 가상 머신의 이미지와 다르게 커널을 포함하고 있지 않기 때문에 이미지 크기가 작다. 여러 애플리케이션의 독립성과 확장성이 높아진다.마이크로서비스에 적합컨테이너는 수 초 내로 생성과 시작이 가능하고 여러 모듈에 독립된 환경을 동시에 제공하기 때문에. 시작하세요! 도커/쿠버네티스 &lt;용찬호&gt;","link":"/2020/12/04/what-is-docker/"},{"title":"[도커&#x2F;쿠버네티스] 2장_도커 엔진","text":"도커 이미지와 컨테이너 도커 이미지여러 개의 계층으로 된 바이너리 파일로 존재하고, 컨테이너를 생성하고 실행할 때 읽기 전용으로 사용된다.이미지 이름은, 다음과 같은 형태로 구성된다 : [저장소 이름]/[이미지 이름]:[태그]ex) jko/ubuntu:14.04 도커 컨테이너이미지로 컨테이너를 생성하면, 이미지 목적에 맞는 파일이 들어 있는 파일 시스템과, 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간이 생성된다.이것이 도커 컨테이너이다.컨테이너는 이미지를 읽기 전용으로 사용하되 이미지에서 변경된 사항만 컨테이너 계층에 저장하기때문에, 컨테이너에 무엇을 하든지 원래 이미지는 영향을 받지 않는다.또한, 컨테이너는 호스트와 분리되어있기 때문에, 어떤 애플리케이션을 설치하거나 삭제해도 다른 컨테이너와 호스트는 변화가 없다. 도커 컨테이너 다루기 컨테이너 생성 1docker run -i -t ubuntu:14.04 docker run 명령어는 컨테이너를 생성하고 실행한다.-i -t 는 컨테이너와 interactive 입출력을 가능하게 한다. 컨테이너 목록 확인 1docker ps 컨테이너 삭제 1docker rm mycentos 컨테이너의 이름은 생성한 컨테이너의 이름에 맞게. 컨테이너를 외부에 노출 1docker run -i -t --name mywebserver -p 80:80 ubuntu:14.04 컨테이너는 가상 머신처럼, 가상 IP 주소를 할당 받는다.-p 옵션은 컨테이너의 포트를 호스트의 포트와 바인딩한다. ( 호스트의 포트:컨테이너의 포트 ) 컨테이너 애플리케이션 구축여러 애플리케이션을 한 컨테이너에 설치할 수 있다.하지만, 컨테이너에 애플리케이션을 하나만 동작시키면 컨테이너 간 독립성을 보장하고 애플리케이션의 버전 관리와 소스 코드 모듈화가 쉬워진다. 도커 볼륨 123456docker run -d \\--name testvolume \\--e MYSQL_PWD=password \\--e MYSQL_DATABASE=db \\-v /home/test_db:/var/lib/mysql \\mysql:5.7 mysql 컨테이너를 삭제하면, 컨테이너 계층에 저장되어 있던 DB 정보도 삭제된다.이를 방지하기 위해, 컨테이너의 데이터를 영속적으로 활용할 수 있는 방법이 볼륨을 활용하는 것이다.위 명령어는, 호스트의 /home/test_db 디렉터리와 컨테이너의 /var/lib/mysql 디렉토리를 공유한다는 의미이다. 도커 이미지도커는 Docker Hub 이라는 중앙 이미지 저장소에서 이미지를 내려받는다.대부분의 이미지는 도커 허브에서 공식적으로 제공하거나 (ex. ubuntu:14.04, centos:7) 다른 사람이 도커 허브에 올려놓은 경우가 대부분이다.도커 허브에서 어떤 이미지가 있는지 확인하기 위해, 도커 허브 사이트를 직접 접속해서 찾아보거나 아래와 같이 도커 엔진에서 찾을 수 있다. 1docker search ubuntu 이미지 생성다음 명령어로 이미지로 만들 컨테이너를 생성하고, 기존의 이미지로부터 변경 사항을 만들자. 12docker run -i -i --name commit_test ubuntu:14.04echo test_first!! &gt;&gt; first 그리고, 호스트로 빠져나와 아래 명령어로 컨테이너를 이미지로 만들자.commit_test 라는 컨테이너를 commit_test:first 라는 이름의 이미지로 생성한다. 1234docker commit \\-a 'test_author' -m 'commit_message' \\commit_test \\commit_test:first 이미지 구조이미지를 커밋할 때, 컨테이너에서 변경된 사항만 새로운 레이어로 저장하고, 그 레이어를 새로운 이미지로 생성한다. 이미지 추출 1docker save -o ubuntu_14.04.tar ubuntu:14.04 도커 이미지를 별도로 저장하거나 옮기는 등 필요에 따라 이미지를 단일 바이너리 파일로 저장해야할 때 필요하다.-o 옵션에는 추출될 파일명을 입력한다. Dockerfile개발한 애플리케이션을 컨테이너화 하려면, 아무것도 존재하지 않는 이미지 (ubuntu, centos..) 로 컨테이너 생성 애플리케이션을 위한 환경 설치하고, 소스코드 복사해서 정상 동작 확인 컨테이너를 이미지로 commit 위 방법은, 애플리케이션이 동작하는 환경을 일일이 설치하고 소스코드를 git 에서 복제해야한다.도커는 위와 같은 일련의 과정을 손쉽게 수행할 수 있도록 build 명령어를 제공한다.이미지 생성을 위해 컨테이너에서 설치해야하는 패키지 추가해야하는 소스코드 실행해야하는 명령어 를 하나의 파일(= Dockerfile) 에 기록해두면, 도커는 이 파일을 읽어 컨테이너에 작업을 수행한뒤 이미지로 만든다. Dockerfile 작성 12345678910FROM ubuntu:14.04 # 생성할 이미지의 베이스가 될 이미지MAINTAINER jko # 이미지 생성한 개발자의 정보LABEL &quot;perpose&quot;=&quot;practice&quot; # 이미지의 메타데이터RUN apt-get update # 이미지 만들기 위해 컨테이너 내부에서 명령어 실행RUN apt-get install apache2 -yADD test.html /var/www/html # Dockerfile 이 위치한 디렉토리에서 test.html 파일을 이미지의 /var/www/html 디렉토리에 추가WORKDIR /var/www/html # == cd 명령어RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello &gt;&gt; test2.html&quot;]EXPOSE 80 # 이미지에서 노출할 포트CMD apachectl -DFOREGROUND # 컨테이너가 시작될 때마다 실행할 명렁어 Dockerfile 빌드 1docker build -t mybuild:0.0 ./ -t 옵션은 생성될 이미지의 이름이고 끝에는 Dockerfile 이 저장된 경로를 입력한다.Dockerfile 에서 명령어 한줄이 실행될 때마다, 이전 step 에서 생성된 이미지에 의해 새로운 컨테이너가 생성된다.그래서, 이미지의 빌드가 완료되면 Dockerfile 의 명령어 수 만큼 레이어가 존재하며, 중간에 컨테이너도 같은 수만큼 생성되고 삭제된다. 도커 데몬도커의 구조는 두 가지로 나뉜다. 클라이언트로서의 도커도커 데몬은 API 입력을 받아 도커 엔진의 기능을 수행하는데, 이 API 를 사용할수 있도록 CLI 를 제공한다. 서버로서의 도커실제로 컨테이너를 생성하고 이미지를 관리하는 주체이다. dockerd 프로세스로 동작한다. 따라서, 터미널에서 도커가 설치된 호스트에 접속해서 docker 명령어를 입력하면 아래와 같은 과정으로 도커가 제어된다. 사용자가 docker ps 같은 명령어 입력 /usr/bin/docker 는 /var/run/docker.sock 유닉스 소켓을 사용해서 도커 데몬에게 명령어 전달 도커 데몬은 이 명령어를 파싱하고 명령어에 해당하는 작업 수행 수행 결과를 도커 클라이언트게 반환하고 사용자에게 결과 출력 시작하세요! 도커/쿠버네티스 &lt;용찬호&gt;","link":"/2020/12/05/docker-engine/"},{"title":"[도커&#x2F;쿠버네티스] 4장_도커 컴포즈","text":"도커 컴포즈 사용 이유여러 개의 컨테이너로 구성된 웹 애플리케이션을 테스트하기 위해,아래처럼 웹 서버 컨테이너와 데이터베이스 컨테이너를 각각 생성해야한다. 12345docker run --name mysql -d jko/composetest:mysql mysqlddocker run -d -p 80:80 \\--link mysql:db --name web \\jko/composetest:web apachectl -DFOREGROUND 여러 개의 컨테이너를 하나의 서비스로 정의해 컨테이너 묶음으로 관리하면 편리할 것이다.그래서, Docker Compose 가 필요하다. 도커 컴포즈 사용도커 컴포즈는 컨테이너의 설정이 정의된 YAML 파일을 읽어 도커 엔진을 통해 컨테이너를 생성한다.그래서, YAML 파일을 아래처럼 작성해야한다. 123456789101112version: '3.0'services: # 생성될 컨테이너를 묶어놓은 단위 web: image: jko/composetest:web ports: - &quot;80:80&quot; links: - mysql:db command: apachectl -DFOREGROUND mysql: image: jko/composetest:mysql command: mysqld 그리고 아래 명령어로, 컨테이너를 생성한다. 1docker-comose up -d 도커 컴포즈 구성 단위 도커 컴포즈는, 컨테이너를 프로젝트 및 서비스 단위로 구분한다.프로젝트 이름은 기본적으로, docke-compose.yml 파일이 위치한 디렉토리 이름이다.현재 디렉토리 이름으로 된 프로젝트를 제어하는데,-p 옵션에 프로젝트 이름을 사용해 프로젝트 이름을 명시해서 제어할 수 있다. 1docker-compose -p myproject up -d 시작하세요! 도커/쿠버네티스 &lt;용찬호&gt;","link":"/2020/12/09/docker-compose/"},{"title":"[도커&#x2F;쿠버네티스] 6장_쿠버네티스 시작하기","text":"Pod / Replica Set / Service / Deployment 오브젝트를 정리한다. 쿠버네티스의 고유 특징 모든 리소스는 오브젝트 형태로 관리된다.컨테이너의 집합 (Pods), 컨테이너의 집합을 관리하는 컨트롤러 (Replica Set), 사용자 (Service Account), 노드 (Node) … 등 하나의 오브젝트로 관리된다.쿠버네티스에서 사용할 수 있는 오브젝트는 아래 명령어로 확인 가능하다. 1kubectl api-resources 명령어를 사용할 수 있지만, YAML 파일을 더 많이 사용한다.kubectl 이라는 명령어로 쿠버네티스를 사용할 수 있지만,YAML 파일로 컨테이너 뿐만 아니라 모든 리소스 오브젝트를 사용할 수 있다. 여러 개의 컴포넌트로 구성되어 있다.쿠버네티스 노드는 마스터 노드와 워커 노드로 나뉘어 있다.마스터 노드는 클러스터를 관리하는 역할을 하고, 워커 노드에는 애플리케이션 컨테이너가 생성된다.쿠버네티스는 도커를 포함한 많은 컴포넌트들이 도커 컨테이너로서 실행된다. 예를 들어,마스터 노드에는 kube-apiserver, kube-controller-manager, kube-schueduler, coreDNS 등이 실행된다. Pod 포드는 한 개이상의 컨테이너로 구성된 컨테이너의 집합이다.Nginx 컨테이너로 구성된 Pod 를 생성하기 위해, nginx-pod.yaml 을 작성해보자. 1234567891011apiVersion: v1kind: Podmetadata: name: my-nginx-podspec: containers: - name: my-nginx-container image: nginx:latest ports: - containerPort: 80 protocol: TCP 위 YAML 파일은 아래 명령어로 쿠버네티스에 생성할 수 있다. 1kubectl apply -f nginx-pod.yaml 생성된 포드의 IP 는 외부에서 접근할 수 없기 때문에, 클러스터 내부에서만 접근할 수 있다.그래서, 클러스터의 노드 중 하나에 접속해서 Nginx 포드의 IP 로 HTTP 요청을 전송하면, Nginx 포드가 정상 실행중인 것을 알 수 있다. Pod, Docker Container 쿠버네티스는 도커 컨테이너가 아니라 왜 굳이 포드라는 새로운 개념을 사용하는걸까 ?여러 리눅스 namespace 를 공유하는 여러 컨테이너들을 추상화된 집합으로 사용하기 위해서이다.예를 들어, 포드 내의 컨테이너들은 리눅스 namespace 의 하나인, 네트워크 namespace 를 공유해서 사용하기 때문에 우분투 컨테이너에서 Nginx 서버를 실행하고 있지 않음에도 불구하고우분투 컨테이너의 로컬호스트에서 Nginx 서버로 접근이 가능하다. 하나의 Pod 는 하나의 완전한 애플리케이션Nginx 는 이 자체로 하나의 애플리케이션이다.그런데, 프로스나 로그를 수집해주는 프로세르가 Nginx 컨테이너와 함께 실행되어야 하는 경우가 있다.이렇게 포드에 정의된 부가적인 컨테이너를 Sidecar 컨테이너라고 한다.이 컨테이너는 포드 내의 다른 컨테이너와 네트워크 환경 등을 공유한다.그래서, 포드에 포함된 컨테이너들은 모두 같은 워커 노드에서 함께 실행된다. Replica Set레플리카셋은 일정 개수의 포드를 유지하는 컨트롤러이다.그렇다면, 왜 레플리카셋을 사용하는 걸까 ? 정해진 수의 동일한 포드가 항상 실행되도록 관리를 해주기 때문 노드 장애 등의 이유로, 포드를 사용할 수 없다면 다른 노드에서 포드를 다시 생성해 주기 때문 예를 들면, 동인한 Nginx 포드를 안정적으로 여러개 실행할 수 있고, 워커 노드에 장애가 생기더라도 정해진 개수의 포드를 유지할 수 있다. Replica Set 사용Nginx 포드를 생성하는 래플리카셋을 만들기 위해, replicaset-nginx.yaml 파일을 작성하자. 1234567891011121314151617181920apiVersion: apps/v1kind: ReplicaSetmetadata: name: replicaset-nginx # 이 레플리카셋의 고유 이름spec: replicas: 3 # 동일 포드를 몇 개로 유지할지 selector: matchLabels: app: my-nginx-pods-label # 여기까지가 레플리카셋의 정의 template: # 여기서부터, 포드 정의 metadata: name: my-nginx-pod labels: app: my-nginx-pods-label # 라벨 spec: containers: - name: nginx image: nginx:latest ports: - containerPort: 80 그리고, 아래 명령어로 레플리카셋을 생성한다. 1kubectl apply -f replicaset-nginx.yaml 만약에, 레플리카셋에 정의된 포드 개수를 4 개로 늘리고 싶으면,이미 생성된 레플리카셋을 삭제하고 다시 생성할 필요가 없다.왜냐하면, 쿠버네티스에는 이미 생성된 리소스의 속성을 변경하는 기능을 제공하기 때문이다.위 YAML 파일의 spec.replicas 를 4로 설정한뒤에 다시 kubetl apply ~ 명령을 실행하면 된다. Replica Set 동작 원리레플리카셋과 포드는, Label Selector 를 이용해 연결된다.레플리카셋은 spec.selector.matchLabel 에 정의된 라벨을 통해 생성해야할 포드를 찾는다.위 YAML 파일의 경우에, app: my-nginx-pods-label 라벨을 가지는 포드의 개수가 replicas 항목에 정의된 숫자인 3 개와 일치하지 않으면 포드를 정의하는 template 항목 내용대로 포드를 생성한다. 핵심은, 레플리카셋의 목적이 일정 개수의 포드를 유지하는 것 이라는 것이다.그래서, 현재 포드의 개수가 replicas 에 설정된 값보다 적으면 포드를 더 생성하고 많으면 포드를 삭제한다. Deployment 레플리카셋의 상위 오브젝트이다.디플로이먼트를 생성하면, 해당 디폴로이먼트에 대응하는 레플리카셋도 함께 생성된다.디플로이먼트 생성을 위해 deployment-nginx.yaml 파일을 작성하자. 1234567891011121314151617181920apiVersion: apps/v1kind: Deploymentmetadata: name: my-nginx-deploymentspec: replicas: 3 selector: matchLabels: app: my-nginx template: metadata: name: my-nginx-pod labels: app: my-nginx spec: containers: - name: nginx image: nginx:1.10 ports: - containerPort: 80 그리고 다음 명령어로 디플로이먼트를 생성한다. 1kubectl apply -f deployment-nginx.yaml Deployment 사용 이유 레플리카셋을 그대로 사용하지 않고, 왜 굳이 상위 개념을 도입해서 사용하는걸까 ?애플리케이션의 업데이트와 배포를 편하게 하기 위해서이다. 애플리케이션을 업데이트할 때, 레플리카셋의 변경 사항을 저장하는 revision 을 남겨 롤백을 가능하게 하고, 무중단 서비스를 위해 포드의 롤링 업데이트 전략을 지정할수 있다. 예를 들어, 애플리케이션 버젼을 업데이트하기 위해 포드의 이미지를 변경해보자.아래 명령어로,포드 탬플릿에 정의된 containers 항목의 nginx 라는 이름을 가진 컨테이너의 이미지를 nginx:1.11 로 변경하자. 1kubectl set image deployment my-nginx-delpoyment nginx=nginx:1.11 그러면, 새롭게 포드들이 3 개 생성이 되고 새로운 replicaset 이 생성된다. 그리고, 이전 버전의 레플리카셋이 삭제되지 않고 남아있다.즉, 디플로이먼트는 포드의 정보가 변경되어 업데이트가 발생할 때,이전의 정보를 리비전으로 보존한다. Service서비스 오브젝트는, 여러 개의 포드에 쉽게 접근할 수 있도록 고유한 도메인 이름을 부여 여러 개의 포드에 접근할 때, 요청을 분산하는 로드 밸런서 기능 수행 포트를 외부에 노출 서비스의 종류는 세 가지가 있는데 하나하나 알아보자. ClusterIP Type NodePort Type LoadBalancer Type ClusterIP 쿠버네티스 내부에서만 포드들에 접근할 때 사용한다.아래 내용으로 hostname-svc-clusterip.yaml 파일을 작성하자. 123456789101112apiVersion: v1kind: Servicemetadata: name: hostname-svc-clusteripspec: ports: - name: web-port port: 8080 # 서비스의 IP 에 접근할 때 사용할 포트 targetPort: 80 # selector 항목에서 정의한 라벨에 의해 접근 대상이 된 포드들이 내부적으로 사용하는 포트 selector: app: webserver # 이 서비스에서 어떤 라벨을 가지는 포드에 접근할 수 있게 할지 type: ClusterIP 그리고 서비스를 생성하자. 1kubectl apply -f hostname-svc-clusterip.yaml 그러면, 생성된 서비스의 IP:PORT 를 통해,서비스와 연결된 여러 포드에 자동으로 요청이 분산된다. NodePort NodePort 타입의 서비스는, 클러스터 외부에서도 접근할 수 있다.아래 내용으로 hostname-svc-nodeport.yaml 파일을 작성하자. 123456789101112apiVersion: v1kind: Servicemetadata: name: hostname-svc-nodeportspec: ports: - name: web-port port: 8080 targetPort: 80 selector: app: webserver type: NodePort 그리고 서비스를 생성하자. 1kubectl apply -f hostname-svc-nodeport.yaml 그리고 서비스 목록을 확인해보면, PORT 항목에 31514 라는 숫자가 있다.이것은, 모든 노드에 동일하게 접근할수 있는 포트이다.즉, 외부에서 포드에 접근하기 위해 각 노드에 개방된 포트인 31514 로 요청을 전송 31514 포트로 들어온 요청은, 서비스와 연결된 포드 중 하나로 라우팅 LoadBalancer LoadBalancer 타입의 서비스 는 AWS, GCP 같은 클라우드 플랫폼 환경에서만 사용할 수 있다.NodePort 를 사용할 때는, 각 노드의 IP 를 알아야 포드에 접근할 수 있었지만LoadBalancer 타입의 서비스는 클라우드 플랫폼으로부터 도메인 이름과 IP 를 할당 받아더 쉽게 포드에 접근 가능하다.아래 대로, hostname-svc-lb.yaml 파일을 생성하자. 123456789101112apiVersion: v1kind: Servicemetadata: name: hostname-svc-lbspec: ports: - name: web-port port: 80 targetPort: 80 selector: app: webserver type: LoadBalancer 그리고 서비스를 생성하고 서비스 목록을 확인하면,EXTERNAL-IP 항목이 있는데, 이 주소는 클라우드 플랫폼인 AWS 로부터 자동으로 할당된 것이다.그리고 PORTS 항목에, 각 노드에 동일하게 접근할 수 있는 포트 번호를 부여받는다.즉, LoadBalancer 타입의 서비스 가 생성되면서 모든 워커 노드는 포드에 접근할 수 있는 랜덤한 포트를 개방한다. 클라우드 플랫폼에서 생성된 로드 밸런서로 요청이 들어오면 쿠버네티스의 워커 노드 중에 하나로 전달되고 워커 노드로 전달된 요청은 포드 중 하나로 전달되어 처리된다. 시작하세요! 도커/쿠버네티스 &lt;용찬호&gt;","link":"/2020/12/10/getting-start-kube/"},{"title":"[도커&#x2F;쿠버네티스] 7장_쿠버네티스 리소스 관리와 설정","text":"효율적으로 애플리케이션을 관리하기 위해 사용되는Namespace / ConfigMap / Secret 오브젝트를 정리한다. Namespace네임스페이스는 포드, 레플리카셋, 디플로이먼트, 서비스 등과 같은 쿠버네티스 리소드들이 묶여 있는하나의 가상 공간 또는 그룹이다.하지만, 네임스페이스의 리소스들은 논리적으로 구분된 것일 뿐, 물리적으로 격리된 것은 아니다.즉, 서로 다른 네임스페이스에 생성된 포드가 같은 노드에 존재할 수 있다. 리눅스의 네임스페이스와는 완전히 다르다.리눅스의 네임스페이스는, 리눅스 커널 자체 기능 Namespace 사용하기아래와 같이 production-namespace.yaml 파일을 정의하자. 1234apiVersion: v1kind: Namespacemetadata: name: production 그리고 네임스페이스를 생성하자. 1kubectl apply -f production-namespace.yaml 특정 네임스페이스에 리소스를 생성하려면hostname-deploy-svc-ns.yaml 파일에 아래와 같이 작성하고, 1234567891011121314151617181920212223242526272829303132333435apiVersion: apps/v1kind: Deploymentmetadata: name: hostname-deployment-ns namespace: productionspec: replicas: 1 selector: matchLabels: app: webserver template: metadata: name: my-webserver labels: app: webserver spec: containers: - name: my-webserver image: alicek106/rr-test:echo-hostname ports: - containerPort: 80---apiVersion: v1kind: Servicemetadata: name: hostname-svc-clusterip-ns namespace: productionspec: ports: - name: web-port port: 8080 targetPort: 80 selector: app: webserver type: ClusterIP 아래와 같이 생성하자. 1kubectl apply -f hostname-deploy-svc-ns.yaml Namespace 에 종속되는 오브젝트, 종속되지 않는 오브젝트A 라는 네임스페이스에 포드를 만들면, A 네임스페이스에는 보이고 B 라는 네임스페이스에는 보이지 않을 것이다. 이런 경우를, 오브젝트가 네임스페이스에 속한다라고 한다. (namespaced)하지만, 모든 오브젝트가 쿠버네티스의 네임스페이스에 의해 구분되는 것은 아니다.예를 들면, 노드 오브젝트의 경우에 네임스페이스에 의해 구분되지 않는다.아래 명령어로도 확인할 수 있다. 1kubectl api-resources --namespaced=false ConfigMap, Sectret개발한 애플리케이션에는 설정값을 가지고 있다.예를 들면, LOG_LEVEL = INFO 와 같이 key-value 형태의 설정값을 사용할 수 있다.Nginx 웹 서버가 사용하는 nginx.conf 처럼 파일을 사용할 수도 있다.이러한 설정값을 애플리케이션에 적용하는 방법에는 뭐가 있을까 ? 도커 이미지 내부에 설정값 또는 파일을 정적으로 저장도커 이미지는 빌드되면 불변의 상태이다. 그래서, 설정 옵션을 유연하게 변경할 수 없다. 포드를 정의하는 YAML 파일에 환경 변수 설정 1234567891011121314151617181920212223apiVersion: apps/v1kind: Deploymentmetadata: name: env-hard-coding-deploymentspec: replicas: 1 selector: matchLabels: app: my-nginx template: metadata: name: my-nginx-pod labels: app: my-nginx spec: containers: - name: nginx env: - name: LOG_LEVEL # 이렇게 환경 변수를 설정 value: INFO image: nginx:1.10 ports: - containerPort: 80 이렇게 하면, 운영 환경과 개발 환경에서 각각 디플로이먼트를 생성해야한다면,환경 변수만 다르게 설정된 두 버젼의 YAML 파일이 필요하다. ConfigMap, Secret 오브젝트 사용컨피그맵에는 설정값을, 시크릿에는 노출되어서는 안되는 비밀값을 저장한다.한 개의 포드 YAML 파일을 사용하고,환경에 따라 다른 컨피그맵이나 시크릿을 생성해서 사용하면 된다. ConfigMap컨피그맵은 다음 처럼 생성할 수 있다. 12kubectl create log-level-configmap --from-literal LOG_LEVEL=DEBUGkubectl create start-k8s --from-literal k8s=kubuernetes --from-literal container=docker 생성한 컨피그맵의 값을 포드로 가져올 때는 두 가지 방법이 있다. 컨패그맵의 값을, 컨테이너의 환경 변수로 가져오기app-env-from-configmap.yaml 을 작성하자. 1234567891011121314apiVersion: v1kind: Podmetadata: name: container-env-examplespec: containers: - name: my-container image: busybox args: ['tail', '-f', '/dev/null'] envFrom: - configMapRef: name: log-level-configmap # 한 개의 key-value 가 포드의 환경 변수로 등록 - configMapRef: name: start-k8s # 두 개의 key-value 가 환경 포드의 환경 변수로 등록 포드를 생성하자. 1kubectl apply -f app-env-from-configmap.yaml 그리고 포드 내부에서 환경 변수를 출력하면, 설정된 세 개의 환경 변수가 조회된다. 컨패그맵의 값을, 포드 내부의 파일로 마운트애플리케이션이 nginx.conf 같은 특정 파일로부터 설정값을 읽어온다면,컨피그맵의 데이터를 포드 내부의 파일로 마운트해서 사용할 수 있다.예를 들어,start-k8s 컨피그맵에 존재하는 모든 key-value 쌍을 /etc/config 디렉토리에 위치시킨다. 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: configmap-volume-podspec: containers: - name: my-container image: busybox args: [ &quot;tail&quot;, &quot;-f&quot;, &quot;/dev/null&quot; ] volumeMounts: - name: configmap-volume # volumes에서 정의한 컨피그맵 볼륨 이름 mountPath: /etc/config # 컨피그맵의 데이터가 위치할 경로 volumes: - name: configmap-volume # 컨피그맵 볼륨 이름 configMap: name: start-k8s 파일로부터 ConfigMap 생성위와 같이, 컨피그맵을 볼륨 파일로 포드 내부에 제공할 수 있다.그런데, 어떻게 nginx.conf 내용을 아예 통째로 컨피그맵으로 저장할 수 있을까 ?파일로부터 컨피그맵을 생성하려면, –from-file 옵션을 사용하면 된다. (위에서는 –frome-lietral 사용) 1kubectl create configmap ngin-config-map --from-file nginx.conf YAML 파일로부터 ConfigMap 생성1kubectl apploy -f my-configmap-yaml SecretSSH 키, 비밀번호 등과 같은 민감 정보를 저장하기 위한 용도로 사용된다.컨피그맵처럼 –from-literal, –from-file 을 사용할 수 있다. 12kubectl create secret generic \\my-password --from-literal password=1234 generic 은 시크릿의 종류이다. 시크릿 종류는 사용목적에 따라 나뉜다.그리고, 쿠버네티스는 기본적으로 key-value 의 value 를 base64 로 인코딩해서 저장한다. 시작하세요! 도커/쿠버네티스 &lt;용찬호&gt;","link":"/2020/12/11/kube-resource-manage/"},{"title":"[도커&#x2F;쿠버네티스] 8장_인그레스","text":"ingress 는 일반적으로 외부에서 내부로 향하는 것을 지칭한다.쿠버네티스 인그레스는, 외부 요청을 어떻게 처리할 것인지 네트워크 7 계층 레벨에서 정의하는 오브젝트이다. 사용 이유 어플리케이션이 3 개의 디플로이먼트로 생성되어 있다고 하자.디플로이먼트를 외부에 노출하려면 위 그림 처럼,NodePort or LoadBalancer 타입의 서비스 3 개를 각각 디플로이먼트에 연결해주면 된다.그런데, 이 방식은 서비스마다 세부적인 설정을 할 때 추가적인 복잡성이 발생한다.예를 들면, 아래와 같은 내용을 구현하려면, 서비스와 디플로이먼트에 대해 일일이 설정해야한다. SSL / TLS 보안 연결 접근 도메인 및 클라이언트 상태에 기반한 라우팅 그래서 인그레스가 필요하다.인그레스 오브젝트를 이용하면, URL 엔드포인트를 단 하나만 생성해서 이런 번거로움을 해결할 수 있다. 위 그림처럼, 3 개의 서비스에 대해 3 개 URL 이 각각 존재하는 것이 아니라인그레스에 접근하기 위한 하나의 URL 만 존재한다.핵심은, 라우팅 정의나 보안 연결 같은 세부 설정은 서비스와 디플로이먼트가 이니라 인그레스에 의해 수행 구조ingress-example.yaml 파일을 작성하자. 12345678910111213141516apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: ingress-example annotations: nginx.ingress.kubernetes.io/rewrite-target: / kubernetes.io/ingress.class: &quot;nginx&quot;spec: rules: - host: jko.example.com # 이 도메인으로 접근하는 요청에 대한 처리 규칙 정의 http: paths: - path: /echo-hostname # 이 경로로 들어온 요청을 backend 에 정의한 서비스로 전달 backend: serviceName: hostname-service # 위 path 로 들어온 요청이 전달될 서비스의 이름 servicePort: 80 그리고, 인그레스 오브젝트를 생성하자. 1kubuctl apply -f ingress-example.yaml 하지만, 이것만으로 아무일도 일어나지 않는다.인그레스는 요청 처리 규칙을 정의한 선언적인 오브젝트일 뿐, 외부 요청을 받는 서버가 아니기 때문이다.그래서, 인그레스 컨트롤러라는 특수한 서버에 이 규칙을 적용해서 생성해야한다.인그레스 컨트롤러의 종류로는 다음 것들이 있다. Kong API Gateway : https://konghq.com/kong GKE (Google Kubernetes Engine) : https://cloud.google.com/kubernetes-engine Nginx 웹서버 인그레스 컨트롤러 : https://github.com/kubernetes/ingress-nginx 아래와 같이,쿠버네티스에서 공식적으로 개발되고 있는 Nginx 웹서버 인그레스 컨트롤러를 설치하자. 1kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.41.2/deploy/static/provider/aws/deploy.yaml 설치하면, ingress-nginx 네임스페이스에 디플로이먼트와 포드를 확인하면, Nginx 웹 서버가 생성되어 있다. 그리고, 외부에서 Nginx 인그레스 컨트롤러에 접근하기 위한 서비스도 생성되어 있다. 이제, 인그레스의 종착점이 될 테스트용 디플로이먼트와 서비스를 아래와 같이 생성해보자.Nginx 인그레스 컨트롤러로 들어오는 요청은 이 디플로이먼트의 포드들로 분산될 것이다. 123456789101112131415161718192021apiVersion: apps/v1kind: Deploymentmetadata: name: hostname-deploymentspec: replicas: 3 selector: matchLabels: app: webserver template: metadata: name: my-webserver labels: app: webserver spec: containers: - name: my-webserver image: alicek106/ingress-annotation-test:0.0 ports: - containerPort: 5000 name: flask-port 123456789101112apiVersion: v1kind: Servicemetadata: name: hostname-servicespec: ports: - name: web-port port: 80 targetPort: flask-port selector: app: webserver type: ClusterIP 12kubuctl apply -f hostname-deployment.yamlkubuctl apply -f hostname-service.yaml 이제, Nginx 인그레스 컨트롤러의 /echo-hostname 으로 요청을 전송해보자.AWS 를 사용하고 있기 때문에, DNS 이름으로 요청한다. 1curl a20...3.elb.amazonaws.com/echo-hostname 404 Not Found 에러가 반환될 것이다. 왜그럴까 ?Nginx 인그레스 컨트롤러가 jko.example.com 으로 접근할 때만 응답을 처리하도록 설정해서이다.위에서 작성한 ingress-example.yaml 파일을 수정해보자. 1234567kubectl edit ingress ingress-example...spec: rules: - host: a20...3.elb.amazonaws.com # 이 도메인으로 접근하는 요청에 대한 처리 규칙 정의... 다시 아래와같이 요청하면, Nginx 인그레스 컨트롤러가 해당 요청을 처리할 것이다. 1curl a20...3.elb.amazonaws.com/echo-hostname 인그레스 컨트롤러 동작 원리 지금까지의 과정은 위와 같다. 정리하면, 공식 github 에서 제공하는 YAML file 로 Nginx 인그레스 컨트롤러 생성 Nginx 인그레스 컨트롤러를 외부로 노출하기 위한 서비스 생성 요청 처리 규칙을 정의하는 인그레스 오브젝트 생성 Nginx 인그레스 컨트롤러로 들어온 요청은 인그레스 규칙에 따라 적절한 서비스로 전달 인그레스 리소스의 상태그런데 위의 3번에서 인그레스 오브젝트를 생성만 하면,인그레스 컨트롤러는 자동으로 인그레스를 로드해서 Nginx 웹 서버에 적용한다.어떻게 이게 가능할까 ?Nginx 인그레스 컨트롤러는 항상 인그레스 리소스의 상태를 지켜보고 있기 때문이다. bypass특정 경로와 호스트 이름으로 유입된 요청은 인그레스에 의해 정의된 규칙에 따라 서비스로 전달된다.위에서 정의한, ingress-example.yaml 파일을 다시 보면, 12345678910...spec: rules: - host: jko.example.com # 이 도메인으로 접근하는 요청에 대한 처리 규칙 정의 http: paths: - path: /echo-hostname # 이 경로로 들어온 요청을 backend 에 정의한 서비스로 전달 backend: serviceName: hostname-service # 위 path 로 들어온 요청이 전달될 서비스의 이름 servicePort: 80 /echo-hostname 으로 유입된 요청이 hostname-service 라는 서비스로 전달되도록 설정되어 있다.하지만 실제로는, 요청이 실제로 hostname-service 로 전달되지 않고Nginx 인그레스 컨트롤러는 서비스에 의해 생성된 엔드 포인트로 요청을 직접 전달한다.이러한 동작을 bypass 라고 한다. 시작하세요! 도커/쿠버네티스 &lt;용찬호&gt;","link":"/2020/12/15/ingress/"},{"title":"[gRPC 시작에서 운영까지] 1장_gRPC 소개","text":"gRPCgRPC 는 로컬 함수를 호출하는 것 만큼 쉽게 분산된 이기종 애플리케이션을 연결, 호출, 운영, 디버깅할 수 있는 프로세스 간 통신 기술이다.gRPC 애플리케이션을 개발할 때 가장 먼저 해야할 일은, 서비스 인터페이스를 정의하는 것이다.이 때, 인터페이스 정의 언어 (==IDL) 을 사용한다.서비스 정의를 사용해 Server Skeleton 이라는 server side code 를 생성할 수 있고, Stub 이라는 client side code 도 생성할 수 있다. 위 예시를 통해 살펴보자.서비스 정의는 ProductInfo.proto 파일에 정의하고, 서버 측과 클라이언트 측 코드를 생성하는데 사용된다.서비스 정의부터 자세히 보자. 서비스 정의gRPC 는 프로토콜 버퍼를 IDL 로 사용해서 서비스 인터페이스를 정의한다. 1234567891011121314151617package ecommerce;service ProductInfo { rpc addProduct(Product) returns (ProductID); rpc getProduct(ProductID) returns (Product);}message Product { string id = 1; string name = 2; string description = 3; float price = 4;}message ProductID { string value = 1;} gRPC Server위와 같이 서비스 정의가 완료되면, 이를 사용해 프로토콜 버퍼 컴파일러인 protoc 를 사용해 서버 측이나 클라이언트 측 코드를 생성할 수 있다.그리고, 서버는 아래 처리가 필요하다. 상위 서비스 클래스를 overriding 함으로써 생성된 서버 스켈레톤의 서비스 로직을 구현 gRPC 서버를 실행해 클라이언트 요청을 수신하고 응답 gRPC Client서버 측과 마찬가지로 서비스 정의를 사용해 클라이언트 스텁을 생성한다.스텁은 서버와 동일한 메서드를 제공하는데, 클라이언트 코드에서 메서드의 호출을 네트워크 상 원격 함수 호출로 변환해준다. gRPC 시작에서 운영까지 &lt;카순 인드라시리, 다네쉬 쿠루푸&gt;","link":"/2020/12/19/intro-grpc/"},{"title":"[gRPC 시작에서 운영까지] 2장_gRPC 시작","text":"위와 같은 온라인 판매 시스템을 만들어보자. 서비스 정의 작성gRPC 애플리케이션을 개발할 때, 가장 먼저 할 일은 클라이언트가 원격으로 호출할 수 있는 메서드와 메서드의 파라미터, 사용자 메시지 포맷 등을 포함하는 서비스 인터페이스를 정의하는 것이다.서비스 정의는 gRPC 에서 사용되는 인터페이스 정의 언어 (==IDL) 인 프로토콜 버퍼 정의로 작성된다. 메세지 정의12345678910message Product { string id = 1; string name = 2; string description = 3; float price = 4;}message ProductID { string value = 1;} 위에서, 각 메세지 필드에 정의된 번호는 메세지에서 필드를 고유하게 식별하는데 사용된다. 서비스 정의서비스는 클라이언트에게 제공되는 원격 메서드의 모임이다.위에서 작성한 Product message, ProductID message 와 같이 작성하자. 1234567891011121314151617package ecommerce;service ProductInfo { rpc addProduct(Product) returns (ProductID); rpc getProduct(ProductID) returns (Product);}message Product { string id = 1; string name = 2; string description = 3; float price = 4;}message ProductID { string value = 1;} 구현 이제, 서비스 정의에서 설정된 원격 메서드들로 gRPC 서비스를 구현한다.원격 메서드들은 서버에 의해 제공되며, gRPC 클라이언트는 서버에 연결해 해당 원격 메서드를 호출한다.먼저, ProductInfo 서비스 정의를 컴파일하고 선택한 언어로 소스 코드를 생성해야한다.컴파일은, 프로토콜 버퍼 컴파일러를 사용해 프로토 파일을 수동으로 컴파일 하거나, Maven 이나 Gradle 같은 빌드 자동화 도구를 사용할수도 있다. 서비스 개발gRPC 서비스 구현1234567891011121314151617181920212223242526272829303132333435363738package ecommerce;import io.grpc.Status;import io.grpc.StatusException;import java.util.HashMap;import java.util.Map;import java.util.UUID;public class ProductInfoImpl extends ProductInfoGrpc.ProductInfoImplBase { // 1 private Map productMap = new HashMap&lt;String, ProductInfoOuterClass.Product&gt;(); @Override public void addProduct(ProductInfoOuterClass.Product request, // 2 io.grpc.stub.StreamObserver&lt;ProductInfoOuterClass.ProductID&gt; responseObserver) { // 3 UUID uuid = UUID.randomUUID(); String randomUUIDString = uuid.toString(); request = request.toBuilder().setId(randomUUIDString).build(); productMap.put(randomUUIDString, request); ProductInfoOuterClass.ProductID id = ProductInfoOuterClass.ProductID.newBuilder().setValue(randomUUIDString).build(); responseObserver.onNext(id); responseObserver.onCompleted(); } @Override public void getProduct(ProductInfoOuterClass.ProductID request, io.grpc.stub.StreamObserver&lt;ProductInfoOuterClass.Product&gt; responseObserver) { String id = request.getValue(); if (productMap.containsKey(id)) { responseObserver.onNext((ProductInfoOuterClass.Product) productMap.get(id)); responseObserver.onCompleted(); } else { responseObserver.onError(new StatusException(Status.NOT_FOUND)); } }} 플러그인에 의해 생성된 추상 클래스를 확장한다. Product 클래스는 서비스 정의에 의해 생성된 ProductInfoOuterClass 에 선언되어 있다. responseObserver 객체는 클라이언트에게 응답을 보내고 스트림을 닫기 위해 사용된다. 서버 생성서비스를 위부에 제공하려면, gRPC 서버 인스턴스를 생성할 때 ProductInfo 서비스를 서버에 등록하면 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package ecommerce;import io.grpc.Server;import io.grpc.ServerBuilder;import java.io.IOException;import java.util.logging.Logger;public class ProductInfoServer { private static final Logger logger = Logger.getLogger(ProductInfoServer.class.getName()); private Server server; private void start() throws IOException { /* The port on which the server should run */ int port = 50051; server = ServerBuilder.forPort(port) .addService(new ProductInfoImpl()) .build() .start(); logger.info(&quot;Server started, listening on &quot; + port); Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; { // Use stderr here since the logger may have been reset by its JVM shutdown hook. logger.info(&quot;*** shutting down gRPC server since JVM is shutting down&quot;); ProductInfoServer.this.stop(); logger.info(&quot;*** server shut down&quot;); })); } private void stop() { if (server != null) { server.shutdown(); } } /** * Await termination on the main thread since the grpc library uses daemon threads. */ private void blockUntilShutdown() throws InterruptedException { if (server != null) { server.awaitTermination(); } } /** * Main launches the server from the command line. */ public static void main(String[] args) throws IOException, InterruptedException { final ProductInfoServer server = new ProductInfoServer(); server.start(); server.blockUntilShutdown(); }} Client 개발proto 서비스 정의 파일은 이미 여러 번 사용한 proto 파일을 그대로 사용한다.그리고, Gradle Build Tool 을 사용해 프로젝트에 대한 클라이언트 스텁 코드를 생성한다.그리고, ecommerce 패키지에 아래 클래스를 작성한다. 123456789101112131415161718192021222324252627282930313233343536package ecommerce;import io.grpc.ManagedChannel;import io.grpc.ManagedChannelBuilder;import java.util.logging.Logger;/** * gRPC client sample for productInfo service. */public class ProductInfoClient { private static final Logger logger = Logger.getLogger(ProductInfoClient.class.getName()); public static void main(String[] args) throws InterruptedException { ManagedChannel channel = ManagedChannelBuilder.forAddress(&quot;localhost&quot;, 50051) // 1 .usePlaintext() .build(); ProductInfoGrpc.ProductInfoBlockingStub stub = ProductInfoGrpc.newBlockingStub(channel); // 2 ProductInfoOuterClass.ProductID productID = stub.addProduct( ProductInfoOuterClass.Product.newBuilder() .setName(&quot;Samsung S10&quot;) .setDescription(&quot;Samsung Galaxy S10 is the latest smart phone, &quot; + &quot;launched in February 2019&quot;) .setPrice(700.0f) .build()); logger.info(&quot;Product ID: &quot; + productID.getValue() + &quot; added successfully.&quot;); ProductInfoOuterClass.Product product = stub.getProduct(productID); logger.info(&quot;Product: &quot; + product.toString()); channel.shutdown(); }} 현재 local 에서 실행되고 포트 50051 로 수신을 대기하는 서버에 연결한다. 채널을 사용해 클라이언트 스텁을 만드는데, 아래 두 가지 유형을 사용할 수 있다. BlockingStub : 서버의 응답을 받을 때 까지 대기NonBlockingStub : 서버 응답을 기다리지 않고 Observer 를 등록해 응답을 받음 빌드와 실행이제 gRPC 서버와 클라이언트 애플리케이션을 빌드하고 실행하자. 서버 빌드1gradle build 클라이언트 빌드1gradle build 서버와 클라이언트 실행12java -jar build/libs/product-info-service.jarjava -jar build/libs/product-info-client.jar gRPC 시작에서 운영까지 &lt;카순 인드라시리, 다네쉬 쿠루푸&gt;","link":"/2020/12/20/getting-started-grpc/"},{"title":"[gRPC 시작에서 운영까지] 4장_gRPC 동작 원리","text":"RPC 흐름클라이언트가 ProductID 를 제공해서 제품 세부 사항을 조회하는 getProduct 를 호출할 때의 처리 흐름은 아래와 같다. 클라이언트 프로세스는, 생성된 스텁에 있는 getProduct 함수를 호출 클라이언트 스텁은, 인코딩 메세지로 HTTP POST 요청을 생성 HTTP 요청 메세지는 네트워크를 통해 서버 머신으로 전송 서버는, 메세지 헤더를 검사해서 어떤 서비스 함수를 호출해야하는지 확인하고 메세지를 서비스 스텁에 전달 서비스 스텁은, 메세지 바이트를 언어별 데이터 구조로 파싱 파싱된 메세지를 사용해 서비스는, getProduct 함수를 로컬로 호출 서비스 함수의 응답이 인코딩되어 클라이언트로 다시 전송 메세지가 복원되어 해당 값이, 대기중인 클라이언트 프로세스로 반환 특히 위 2번의 경우, gRPC 에서는 모든 요청이 application/grpc 접두가 붙는 content-type 을 가진 HTTP POST 요청이다.호출하는 원격 함수 (/ProductInfo/getProduct) 는 별도의 HTTP 헤더로 전송된다. gRPC 시작에서 운영까지 &lt;카순 인드라시리, 다네쉬 쿠루푸&gt;","link":"/2020/12/27/grpc-principle/"},{"title":"[OAuth 2.0 마스터] 2장_OAuth 2.0 개요","text":"시나리오다음 시나리오로 시작하자.사용자가 GoodApp 이라는 App 을 사용한다고 하자.GoodApp 은 사용자의 페이스북에 등록된 친구들을 추천해줄 수 있다. 사용자가 GoodApp 에게 친구 추천을 요청 GoodApp 은 먼저 자신을 인가해달라고 대답 GoodApp 은 페이스북에 대한 접근 권한을 받기 위해, 사용자가 페이스북에 로그인하도록 함 페이스북은 GoodApp 이 사용자의 친구 목록에 접근하도록 허용할 것인지 질문 사용자는 네 라고 대답 페이스북은 GoodApp 에게 사용자의 친구 목록을 전달 GoodApp 은 이 친구 목록을 이용해서 사용자에게 친구 추천 ClientGoodApp 에게 사용자의 친구 목록에 접근할 수 있는 권한이 부여된 이후에는, GoodApp 과 페이스분 간 정보 교환을 위한 상호 작용이 이뤄진다.이 상호 작용은, 클라이언트 어플리케이션의 능력에 따라 달라진다. Untrusted Client기밀 정보를 안전한게 저장거나 전송할 수 없는 애플리케이션이다.예를 들면, HTML/Javascript 애플리케이션으로서 정보를 안전하게 저장하는 서버가 없는 경우이다. Trusted Client기밀 정보를 안전한게 저장하고 전송할 수 있는 애플리케이션이다.예를 들면, 백엔드 서버거 존재하는 클라이언트-서버-데이터베이스 구조의 애플리케이션이다. GrantOAuth 2.0 은 정보 교환을 위해, 클라이언트 어플리케이션에 따라 다양한 방법을 지원한다.이것이 Grant 유형이다. 두 가지가 있다. Implicit Grant : Client Side WorkflowGoodApp 이 웹 브라우저 상에서 동작하는 웹 애플리케이션이라고 하자. 사용자가 GoodApp 에게 친구 추천을 요청 GoodApp 은 먼저 자신을 인가해달라고 대답 GoodApp 은 페이스북에 대한 접근 권한을 받기 위해, 사용자가 페이스북에 로그인하도록 함 페이스북은 GoodApp 이 사용자의 친구 목록에 접근하도록 허용할 것인지 질문 사용자는 네 라고 대답 페이스북은 GoodApp 에게 사용자의 친구 목록에 접근하는 데 사용할 수 있는 키 를 전달 GoodApp 은 이 키를 이용해서 페이스북에게 사용자의 친구 목록 요청 페이스북은 이 키를 확인해서 GoodApp 에게 친구 목록 전달 GoodApp 은 이 친구 목록을 이용해서 사용자에게 친구 추천 위에서, 사용자의 친구 목록에 접근하는 데 사용할 수 있는 키 가 OAuth 2.0 에서는 Access Token 이라고 한다.Access Token 은 GoodApp 에게 사용자의 친구 목록에 접근할 수 있는 권한이 부여되었다는 의미이다. Authorization Code Grant : Service Side WorkflowGoodApp 이 백엔드 서버거 존재하는 클라이언트-서버-데이터베이스 애플리케이션이라고 하자. 사용자가 GoodApp 에게 친구 추천을 요청 GoodApp 은 먼저 자신을 인가해달라고 대답 GoodApp 은 페이스북에 대한 접근 권한을 받기 위해, 사용자가 페이스북에 로그인하도록 함 페이스북은 GoodApp 이 사용자의 친구 목록에 접근하도록 허용할 것인지 질문 사용자는 네 라고 대답 페이스북은 GoodApp 서버에게 사용자의 페이스북 친구 목록에 접근하는데 사용할 수 있는 키와 교환할 수 있는 Tag 를 전달 GoodApp 은 이 Tag 를 이용해서 페이스북에게 사용자의 친구 목록을 전달 받는 데 사용하는 키를 요청 페이스북은 이 Tag 를 확인해서 GoodApp 에게 키를 전달 GoodApp 은 이 키를 이용해서 페이스북에게 사용자의 친구 목록 요청 페이스북은 이 키를 확인해서 GoodApp 에게 친구 목록 전달 GoodApp 은 이 친구 목록을 이용해서 사용자에게 친구 추천 위에서, 사용자의 페이스북 친구 목록에 접근하는데 사용할 수 있는 키와 교환할 수 있는 Tag 는 일단 한 번 사용된 이후에는 다른 키를 얻기 위해 재사용할 수 없다.OAuth 2.0 에서는 위의 Tag 를 Authorization Code 라고 하고, 위의 Key 를 Access Token 이라고 한다. OAuth 2.0 마스터 &lt;찰스 비히스&gt;","link":"/2021/01/20/oauth-start/"},{"title":"[OAuth 2.0 마스터] 3장_네 개의 단계","text":"OAuth 2.0 클라이언트가 되기 위한 과정을 네 개의 단계로 정리한다. 클라이언트 애플리케이션 등록서비스 제공자는 자신에게 요청하는 클라이언트가 누구인지 알아야한다.그래서, 클라이언트 애플리케이션 등록이 필요하다.애플리케이션 등록 후에 사용하게 될 정보 셋은 다음과 같다. client id클라이언트 애플리케이션의 고유한 ID client secret서비스 제공자에게 요청을 보낼 때, 애플리케이션의 신원을 알려주는 비밀 키 redirection endpoint서비스 제공자가 응답을 전달하기 위해 사용하는 엔드 포인트 authorization endpoint클라이언트 애플리케이션이 인가 플로우를 시작할 때 사용하는 엔드 포인트 token endpoint클라이언트 애플리케이션이 토큰 플로우를 시작할 때 사용하는 엔드 포인트 엑세스 토큰 얻기애플리케이션을 등록했으면, 이제 엑세스 토큰을 얻어야한다.애플리케이션에 따라 워크 플로우가 결정되는데, 애플리케이션이 신뢰 애플리케이션이면, 인가 코드 그랜트 플로우를 애플리케이션이 비신뢰 애플리케이션이면, 그랜트 플로우를 사용할 것이다. 그런데, 액세스 토큰이 무엇일까 ? 엑세스 토큰하나의 리소스나 다수의 리소스에 대해, 일정 기간 동안 접근할 수 있는 권한을 캡슐화한 것이다. 범위 (scope)토큰 보유자가 접근할 수 있는 보호된 리소스 셋이다. 접근 기간서비스 제공자가 발급하는 대부분의 토큰은, 해당 토큰이 가지고 있는 접근 권한이 더 이상 유효하지 않게 되는 만료 시간을 가진다. 엑세스 토큰 사용엑세스 토큰을 받았으면, 이제 서비스 제공자에게 API 를 호출해야한다.이 때, 엑세스 토큰을 전달해야하는데 전달 하는 방법으로는, 인가 요청 Header Field 인코딩된 Form Parameter URI Query Parameter 엑세스 토큰 갱신토큰이 만료되면, 이 토큰을 이용해서 더 이상 보호된 리스에 접근을 못한다.그래서 리소스에 계속 접근하기 위해서는 다음 두 가지 중에 하나를 수행해야한다. 전체적인 인증 프로세스 리프레시 토큰을 이용해서 엑세스 토큰 갱신 (리프레시 토큰은 서비스 제공자로부터, 엑세스 토큰을 발급 받을 때 함께 응답 받는다) OAuth 2.0 마스터 &lt;찰스 비히스&gt;","link":"/2021/01/25/oauth-client/"},{"title":"[OAuth 2.0 마스터] 5장_Implicit Grant","text":"Sample암시적 그랜프 플로우를 샘플 앱인 WMIIG 샘플 앱으로 확인해보자. 사용자 : WMIIG 로 접속해서, 인포그래픽을 보려고 한다. WMIIG : 당신의 프로파일과 당신이 작성한 글에 접속해야 하므로, 여기서 인가해달라고 요청한다. (페이스북으로 연결) 페이스북 : WMIIG 이 사용자의 프로파일과 작성한 글에 접근하는 것을 허용할지 사용자에게 물어본다. 페이스북 : 사용자가 허락했으면, WMIIG 에게 사용자의 프로파일과 글에 접근하는 데 사용할 수 있는 엑세스 토큰을 전달한다. WMIIG : 페이스북으로부터 받은 엑세스 토큰을 이용해서 페이스북에게 사용자의 프로파일과 글을 요청한다. 페이스북 : 전달된 토큰을 확인하여, WMIIG 에게 사용자의 프로파일과 글을 전달한다. 암시적 그랜트 플로우WMIIG 은 사용자를 서비스 제공자의 인가 엔드 포인트로 연결함과 동시에,리다이렉션 엔드 포인트와 scope 같은 정보를 서비스 제공자에게 전달한다.사용자가 동의하면, 응답에 엑세스 토큰이 포함되어 전달된다. 인가 요청사용자를 서비스 제공자의 인가 엔드 포인트로 연결한다.OAuth 2.0 스팩은 다음과 같다. request1234567GET /authorize? response_type=token&amp; client_id=[CLIENT_ID]&amp; redirect_uri=[REDIRECT_URI]&amp; scope=[SCOPE]&amp; state=[STATE] HTTP/1.1HOST: server.example.com response_type암시적 그랜트 플로우를 사용하고 있음을 나타내기 위해, token 으로 세팅한다. client_id클라이언트 등록 과정에서 제공된 클라이언트 고유 아이디이다. redirect_uri서비스 제공자는 요청이 성공하면 엑세스 토큰을 이 uri 로 전달한다. scope클라이언트가 요청하는 접근 권한의 범위이다.각 범위는 공백 문자로 구분된다. state클라이언트의 요청과 그에 따른 콜백 간의 상태를 유지하기 위해 사용된다.클라이언트가 서비스 제공자에게 전달하면 서비스 제공자는 이 값을 다시 응답에 포함해서 전달한다. 엑세스 토큰 응답인가 요청 URL 에 질의를 보내면, 사용자의 동의 화면을 보게 되고, 거기서 인가 요청에 동의 하거나 거절할 수 있다.인가 요청에 대한 유효한 응답은 다음과 같은 형태로 전달된다. request1234567HTTP/1.1 302 FoundLocatoin: [REDIRECT_URI]# access_token=[ACCESS_TOKEN]&amp; token_type=[TOKEN_TYPE]&amp; expires_in=[EXPIRES_IN]&amp; scope=[SCOPE]&amp; state=[STATE] token_type전달된 토큰의 유형이다.대부분 bearer 토큰 유형이다. expires_in엑세스 토큰의 유효기간이다. state인가 요청에 state 파라미터가 포함되었다면, 응답에도 이 파라미터가 있어야한다. OAuth 2.0 마스터 &lt;찰스 비히스&gt;","link":"/2021/01/26/oauth-client-side-workflow/"},{"title":"[OAuth 2.0 마스터] 6장_Authorization Code Grant","text":"Sample인가 코드 그랜프 플로우를 샘플 앱인 WMIIG 샘플 앱으로 확인해보자. 사용자 : WMIIG 로 접속해서, 인포그래픽을 보려고 한다. WMIIG : 당신의 프로파일과 당신이 작성한 글에 접속해야 하므로, 여기서 인가해달라고 요청한다. (페이스북으로 연결) 페이스북 : WMIIG 이 사용자의 프로파일과 작성한 글에 접근하는 것을 허용할지 사용자에게 물어본다. 페이스북 : 사용자가 허락했으면, WMIIG 에게 사용자의 프로파일과 글에 접근하는 데 사용할 수 있는 엑세스 토큰과 교환 가능한 인가 코드를 전달한다. WMIIG : 페이스북으로부터 받은 인가 코드를 이용해서 사용자의 페이스북 프로파일과 글에 접근할 수 있는 엑세스 토큰을 요청한다. 페이스북 : 전달된 인가 코드를 확인하여, WMIIG 에게 엑세스 토큰을 전달한다. WMIIG : 페이스북으로부터 받은 엑세스 토큰을 이용해서 페이스북에게 사용자의 프로파일과 글을 요청한다. 페이스북 : 전달된 엑세스 토큰을 확인한 후, 사용자의 프로파일과 글을 전달한다. 인가 코드 그랜트 플로우 사용자 동의 화면에서 사용자가 동의를 하면 리다이렉션 엔드포인트로 인가 코드가 전달되고 인가 코드를 엑세스 토큰과 교환한다. 인가 요청사용자를 서비스 제공자의 인가 엔드 포인트로 연결한다.OAuth 2.0 스팩은 다음과 같다.response_type 이 code 이 경우만 제외하면, 암시적 그랜트 플로우와 동일하다. request1234567GET /authorize? response_type=code&amp; client_id=[CLIENT_ID]&amp; redirect_uri=[REDIRECT_URI]&amp; scope=[SCOPE]&amp; state=[STATE] HTTP/1.1HOST: server.example.com response_type인가 코드 그랜트 플로우를 사용하고 있음을 나타내기 위해, code 로 세팅한다. client_id클라이언트 등록 과정에서 제공된 클라이언트 고유 아이디이다. redirect_uri서비스 제공자는 요청이 성공하면 인가 코드가 이 uri 로 전달한다. scope클라이언트가 요청하는 접근 권한의 범위이다.각 범위는 공백 문자로 구분된다. state클라이언트의 요청과 그에 따른 콜백 간의 상태를 유지하기 위해 사용된다.클라이언트가 서비스 제공자에게 전달하면 서비스 제공자는 이 값을 다시 응답에 포함해서 전달한다. 인가 응답인가 요청 URL 에 질의를 보내면, 사용자의 동의 화면을 보게 되고, 거기서 인가 요청에 동의 하거나 거절할 수 있다.인가 요청에 대한 유효한 응답은 다음과 같은 형태로 전달된다. request1234HTTP/1.1 302 FoundLocatoin: [REDIRECT_URI]# code=[AUTHORIZATION_CODE]&amp; state=[STATE] code엑세스 토큰과 교환하는 데 사용되는 인가 코드이다. state인가 요청에 state 파라미터가 포함되었다면, 응답에도 이 파라미터가 있어야한다. 엑세스 토큰 요청지금까지는, 인가 코드만 있고 아직 엑세스 토큰이 없다.그래서 인가 코드를 엑세스 토큰과 교환하기 위해 요청을 한 번 더 해야한다.서비스 제공자의 토큰 엔드 포인트로 POST 요청을 해야한다. request123456789POST /token HTTP/1.1HOST: server.example.comAuthorization: BASIC [ENCODED_CLIENT_CREDENTIALS]Content-Type: application/x-www-form-urlencodedgrant_type=authorization_code&amp; code=[AUTHORIZATION_CODE]&amp; redirect_uri=[REDIRECT_URI]&amp; client_id=[CLIENT_ID] grant_type엑세스 토큰으로 교환하고자 한다는 것을 나타내기 위해,authorization_code 로 세팅되어 있어야한다. code인가 요청에 의해 전달 받은 인가 코드 값 엑세스 토큰 응답엑세스 토큰 요청이 성공하면 다음과 같은 파라미터가 전달된다. access_token얻고자 했던 엑세스 토큰이다. token_type전달되는 토큰의 유형이다.대부분 bearer 토큰이다. expired_in토큰의 유효기간이다. refresh_token엑세스 토큰이 만료되면 엑세스 토큰을 갱신하기 위해 사용되는 토큰이다. scope인가된 접근 범위이다. OAuth 2.0 마스터 &lt;찰스 비히스&gt;","link":"/2021/01/27/oauth-server-side-workflow/"},{"title":"[OAuth 2.0 마스터] 7장_엑세스 토큰 이용하기","text":"암시적 그랜트 플로우나 인가 코드 그랜트 플로우를 이용해서,서비스 제공자에게 엑세스 토큰을 요청할 수 있게 되었다.이제, 엑세스 토큰을 이용해서 서비스 제공자가 제공하는 API 를 호출할 차례이다. 엑세스 토큰 이용해서 API 호출API 를 호출할 때 엑세스 토큰을 전달하는 방법으로는 세 가지가 있다. 인가 요청 Header Field 에 담아서 전달 인코딩된 Form 의 Parameter 로 전달 URI Query Parameter 로 전달 인가 요청 Header Field 에 담아서 전달OAuth 2.0 스팩에서 권장하는 방식이다.HTTP 요청의 Authorization Header 에 엑세스 토큰을 담아서 서비스 제공자에게 전달하는 것이다.엑세스 토큰을 요청하기 위해 사용된, basic authorization 방법과 유사하다.차이점은, Basic 이 아니라 Bearer 가 사용된다는 것이다. request123GET /resource HTTP/1.1HOST: server.example.comAuthorization: Bearer mF_9.B5f-4.1JqM 인코딩된 Form 의 Parameter 로 전달Authorization Header Field 를 사용하지 않고 HTTP Header 의 다른 Field 를 사용하는 것이다.GET 아닌 POST 요청을 한다는 점이 중요하다. request12345POST /resource HTTP/1.1HOST: server.example.comContent-Type: application/x-www-form-urlencodedaccess_token=mF_9.B5f-4.1JqM URI Query Parameter 로 전달URI Query Parameter 로 엑세스 토큰을 전달하는 방식이다.애플리케이션을 테스트하고 디버깅하는데 수월한 방법이다.하지만, 보안 결함이 발생할 수 있다. 참고로, 클라이언트가 이 방법을 사용할 때는‘no-store’ 옵션을 포함하는 Cache-Control Header 도 함께 보내서엑세스 토큰이 캐쉬 되지 않도록 방지해야 한다. request12GET /resource?access_token=mF_9.B5f-4.1JqM HTTP/1.1HOST: server.example.com OAuth 2.0 마스터 &lt;찰스 비히스&gt;","link":"/2021/01/28/oauth-access-token/"},{"title":"[OAuth 2.0 마스터] 8장_엑세스 토큰 갱신하기","text":"액세스 토큰이 만료되면 어떻게 해야할까 ? Refresh Token Workflow서비스 제공자가 Refresh Token Workflow 를 지원한다면,엑세스 토큰 요청이 대한 응답에 access_token 뿐만 아니라 refresh_token 값도 포함되어있다.응답에 refresh_token 이 포함되어 있지 않으면 Refresh Token Workflow 를 지원하지 않는 것이다. 리프레시 요청리프레시 토큰을 이용해서 엑세스 토큰을 요청하려면,서비스 제공자의 토큰 엔드 포인트로 POST 요청해야한다. request123456POST /token HTTP/1.1HOST: server.example.comAuthorization: BASIC [ENCODED_CLIENT_CREDENTIALS]Content-Type: application/x-www-form-urlencodedgrant_type=refresh_token&amp;refresh_token=[REFRESH_TOKEN] grant_type리프레시 토큰을 이용해서 새로운 액세스 토큰을 요청한다는 것을 나태내기 위해refresh_token 이어야한다. scope원래의 엑세스 토큰보다 더 큰 접근 범위를 지정해서 요청할 수 없다.즉, 갱신된 엑세스 토큰은 이전과 동일하거나 작은 접근 권한 범위를 가져야한다. 엑세스 토큰 응답엑세스 토큰 요청이 성공하면 다음과 같은 파라미터가 전달된다. access_token얻고자 했던 엑세스 토큰이다. token_type전달되는 토큰의 유형이다.대부분 bearer 토큰이다. expired_in토큰의 유효기간이다. refresh_token엑세스 토큰이 만료되면 엑세스 토큰을 갱신하기 위해 사용되는 토큰이다. scope인가된 접근 범위이다. Refresh Token 이 없다면 ?서비스 제공자가 리프레시 워크 플로우를 지원하지 않거나,리프레시 토큰이 만료되었으면 어떻게 해야할까 ?유일한 방법은, 전체적인 인가 프로세스를 다시 시작하는 것이다. OAuth 2.0 마스터 &lt;찰스 비히스&gt;","link":"/2021/01/29/oauth-refresh-token/"},{"title":"Proxy Pattern","text":"Proxy Pattern 에 대해 정리한다. Proxy Server프록시 패턴에 대해 정리하기 전에, 프록시 서버가 무엇인지 보자. 프록시의 사전적 의미는 “대리, 대리권, 대리 투표, 대리인” 이다.프록시 서버는, 위키에 따르면 다음과 같다. 프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.서버와 클라이언트 사이에 중계기로서 대리로 통신을 수행하는 것을 가리켜 ‘프록시’, 그 중계 기능을 하는 것을 ‘프록시 서버’ 라고 부른다. 정리하면 프로시 서버는, 클라이언트의 요청을 서버에게 대신 전달하고 서버의 응답을 클라이언트에게 대신 전달한다. Proxy Pattern그렇다면, 프록시 패턴은 무엇일까 ? 위키에 따르면 다음과 같다. 프록시 패턴(proxy pattern)은 컴퓨터 프로그래밍에서 소프트웨어 디자인 패턴의 하나이다.일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다.프록시는 어떠한 것 (이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 또 복제할 수 없거나 수요가 많은 리소스) 과도 인터페이스의 역할을 수행할 수 있다. 프록시 패턴은 다음과 같은 클래스 다이어그램으로 나타난다. Proxy 클래스가 Subject 인터페이스를 구현하면서, Subject 를 구현하고 있는 RealSubject 에 의존하고 있다. Example프록시 패턴의 간다한 예제를 살펴보자.예제의 클래스 다이어그램은 다음과 같다. ProxyImage 클래스가 Image 인터페이스를 구현하면서, Image 를 구현하고 있는 RealImage 에 의존하고 있다. 이제 코드로 보자. 아래는, 클라이언트가 의존하는 interface 이다. 123interface Image { public void displayImage();} Image 인터페이스를 구현하는 구현 클래스이다. 12345678910111213141516class RealImage implements Image { private String filename; public RealImage(String filename) { this.filename = filename; loadImageFromDisk(); } private void loadImageFromDisk() { System.out.println(&quot;Loading &quot; + filename); } @Override public void displayImage() { System.out.println(&quot;Displaying &quot; + filename); }} Image 인터페이스를 구현하면서, RealImage 클래에 의존하는 클래스이다. 12345678910111213141516class ProxyImage implements Image { private String filename; private Image image; // &lt;------- Here public ProxyImage(String filename) { this.filename = filename; } @Override public void displayImage() { if (image == null) image = new RealImage(filename); image.displayImage(); }} 위 코드들을 수행하는 client code 는 아래와 같다. 123456789class ProxyExample { public static void main(String[] args) { Image image1 = new ProxyImage(&quot;HiRes_10MB_Photo1&quot;); Image image2 = new ProxyImage(&quot;HiRes_10MB_Photo2&quot;); image1.displayImage(); image2.displayImage(); }} 실행 결과는, 1234Loading HiRes_10MB_Photo1Displaying HiRes_10MB_Photo1Loading HiRes_10MB_Photo2Displaying HiRes_10MB_Photo2 정리실행 흐름은 다음과 같다. 클라이언트가 displayImage() 를 호출하면 ProxyImage 는 RealImage 생성한 뒤에 RealImage 의 displayImage() 을 호출한다. 위 Example 의 핵심적인 부분은 여기다. 123456class ProxyImage implements Image { private String filename; private Image image; // ...} ProxyImage 클래스는 Image 를 구현하면서, 동시에 Image 클래스를 필드로 가지고 있다.클라이언트는 ProxyImage 클래스의 displayImage 메서드를 호출했는데, 실제로는 RealImage 의 displayImage 메서드가 호출되고 있다.ProxyImage 클래스가 RealImage 대신에 대리, 즉 프록시 역할을 하고 있는 것이다. 언제 사용 ?프록시 패턴을 언제 사용할 수 있을끼 ?Real Target 을 호출하기 전,후로 추가적인 기능을 실행하기 위해 사용될 수 있다. 예를 들어, RealImage 를 생성전이나 RealImage 의 displayImage() 를 호출 후에 log 를 남기고 싶다면ProxyImage 클래스에 logging 을 추가해서 RealImage 클래스 변경 없이 구현가능하다. https://en.wikipedia.org/wiki/Proxy_patternhttps://github.com/junhee-ko/proxy-patternhttps://github.com/junhee-ko/demo-jpa-proxy","link":"/2021/04/17/proxy-pattern/"},{"title":"CMAK","text":"CMAK 를 어떤 목적으로 사용하는지 정리하고, 설치하고 실행해본다. CMAKCMAK (Cluster Manager for Apache Kafka) 는, 야후에서 만든 Kafka Cluster 를 managing 하기 위한 tool 이다. CMAK 를 이용해서 다음과 같은 것들을 할 수 있다. Create, Delete topic Add partitions to existing topic Update config for existing topic Inspection of cluster state … RequirementsKafka package 설치하고, Zookeeper 를 아래와 같이 start 한다. 1bin/zookeeper-server-start.sh config/zookeeper.properties Kafka 를 아래와 같이 start 한다. 1bin/kafka-server-start.sh config/server01.properties InstallCMAK 를 설치하자. yahoo github 에서 내려받아 설치할 수 있다. 1wget https://github.com/yahoo/CMAK/archive/3.0.0.5.tar.gz ConfigurationCMAK 를 위와같이 설치하면, conf directory 에 application.conf 파일이 있다. 이 파일에 아래와 같이 Zookeeper host 를 명시해야한다. 12kafka-manager.zkhosts=&quot;localhost:2181&quot;cmak.zkhosts=&quot;localhost:2181&quot; Runservice 를 시작한다.이 때, Java 11+ version 이 필요하다. 1./sbt run localhost:9000 에 접속했을 때, 다음과 같이 정상적으로 접근이 된다. 다음과 같이 test-cluster 를 생성해보자. 정상적으로 cluster 가 생성이 되었다. 토픽을 생성해보자. 토픽이 정상적으로 생성이 되었다. ConclusionCMAK 를 이용해서 Kafka Cluster 를 managing 할 수 있다.토픽을 새롭게 추가하거나, 삭제할 수 있을 뿐만 아니라 토픽에 파티션을 추가하거나 존재하는 토픽의 설정을 변경할 수 있다.이 뿐만 아니라 다양한 managing 을 Kafka Server 에서 command 로 하는 것이 아니라, UI 를 통해 쉽게 할 수 있다는 것이 장점이다. Kafka Cluster manging 은 CMAK 로,consumer group lag 같은 metric monitoring 은 Grafana 나 Chronograf 같은 Dashboard 를 구성하여 운영하자. https://github.com/yahoo/CMAK","link":"/2021/04/21/cmak/"},{"title":"Spring Kafka Listener Container BATCH AckMode","text":"Spring Kafka Listener Container 의 AckMode 가 BATCH 일 때,어떻게 records 를 consume 하고 commit 하는지 정리한다. Offsetcommit 을 정확히 이해하기 위해, offset 의 개념부터 정리하자.Kafka 는 partition 의 각각의 record 에 대해 numerical offset 을 가지고 있다.offset 은 두 가지 역할을 한다. partition 의 record 에 대한 unique identifier partition 에 대한 consumer 의 위치 그래서, commit 된 position 은 마지막 offset 을 가리킨다. AckModeSpring Kafka 에는 ContainerProperties 로 AckMode 일곱 가지가 있다.offset commit 을 어떻게 할지에 대한 설정이다.일곱 가지 중에 BATCH AckMode 는 어떻게 동작하는지 알아보자. 우선, BATCH AckMode 는 문서에 따르면 다음과 같이 정의되어 있다. Commit the offsets of all records returned by the previous poll after they all have been processed by the listener. 번역하면 다음과 같다.“이전 poll 에 의해 반환된 모든 레코드가” 리스너에 의해 모두 처리가 끝난 뒤에, offset 을 커밋한다. Test Scenariotest 는 다음 순으로 진행하자. create topic consumer group 과 lag 을 확인하기 위해, consumer app 을 실행한 뒤 down producer app 을 실행하여 1000 개의 record 를 produce consumer app 에 break point 를 걸고 실행하여, 언제 record 를 가져오고 commit 하는지 확인 Topic CreateKafka package 에 있는 실행파일로 토픽을 생성하자.(물론, Zookeeper 와 Broker 는 구동된 상태이어야한다. 이 과정은 생략한다.) 1bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic topic-for-commit-test 다음과 같이 정상적으로 생성된 것이 확인된다. Run Consumerconsumer config 설정은 다음과 같다. 1234567891011121314151617181920212223242526@Configurationpublic class MyConsumerConfig { @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; concurrentKafkaListenerContainerFactory() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConcurrency(1); factory.getContainerProperties().setAckMode(AckMode.BATCH); // --- HERE factory.setConsumerFactory(new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs())); return factory; } private Map&lt;String, Object&gt; consumerConfigs() { Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9091&quot;); props.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;group-for-commit-test&quot;); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false); props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, 500000); // --- HERE return props; }} 주의해서 볼 점은, AckMode 를 BATCH 를 설정 SESSION_TIMEOUT_MS_CONFIG 를 500000 로 설정 2번을 다시 보자.SESSION_TIMEOUT_MS_CONFIG 의 default 값은 10000 이다. 이 의미는, consumer 가 10 초동안 브로커에게 heartbeats 를 보내지 않으면 broker 는 이 consumer 를 failure 이라고 판단하고 rebalancing 을 한다는 것이다. 이 값을 default 값 10000 이 아니라, 500000 으로 설정한 이유는 다음과 같다.consumer app 을 debug mode 로 실행하여 line by line 으로 commit 을 어떻게 하는지 확인할 건데, 확인하는 시간 동안 heartbeats 를 보내지 않아 rebalancing 을 하게 되면 commit 에 실패하기 때문에 여유롭게 설정한 것이다. 이제, consumer app 을 실행하자.“group-for-commit-test” consumer group 은 현재 lag 과 offset 이 0 인 것이 확인된다. debug 모드로 다시 consumer 를 실행하기 위해, 현재 실행중인 consumer app 은 down 시킨다. Run Producerproducer 는 records 1000 개를 produce 한다. 12345678910111213141516171819202122232425262728293031323334@Slf4j@Component@RequiredArgsConstructorpublic class MyProducer { private final KafkaTemplate&lt;String, String&gt; template; private final ObjectMapper objectMapper; public void produce() throws JsonProcessingException { log.info(&quot;produce starts&quot;); for (int i = 1; i &lt;= 1000; i++) { String message = objectMapper.writeValueAsString( MyMessage.builder() .number(i) .build() ); template .send(&quot;topic-for-commit-test&quot;, message) .addCallback(new ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt;() { @Override public void onSuccess(SendResult&lt;String, String&gt; result) { log.info(&quot;Produce Success, Result : {}&quot;, result); } @Override public void onFailure(Throwable ex) { log.error(&quot;Produce Fail, Ex : {}&quot;, ex.getMessage()); } }); } }} “group-for-commit-test” consumer group 은 현재 lag 1000, offset 1000 인 것이 확인된다. Run Consumer해당 지점에 break point 를 걸고, debug mode 로 app 을 다시 실행시키자. 여기서, KafkaMessageListenerContainer 는 ConcurrentMessageListenerContainer 가 가지고 있는 container 이다.예를 들어, ConcurrentKafkaListenerContainerFactory 의 concurrency 를 3으로 설정하면 3 개의 KafkaMessageListenerContainer 를 독립적인 thread 로 실행된다. 계속 진행 상황을 파악하자.poll 을 통해서 500 개의 record 를 가져온것이 확인된다.그런데 왜 500 개씩 가져올까 ? consumer 의 max.poll.records 의 값이 default 500 이기 때문이다. 500 개의 record 각각을 handler (@KafkaListener method) 에게 전달하여 비즈니스 로직을 처리한다. commit 의 결과로 1000 이였던 lag 이 500 으로 줄어들었다. 이제 다시 poll 을 통해서 500 개의 record 를 가져온다. 마찬가지로, 500 개의 record 를 각각 handler 에게 전달하여 비즈니스 로직을 처리한다. 다음 poll 을 호출하기 전에 commit 을 한다. commit 의 결과로 500 이였던 lag 이 0 으로 줄어들었다. 주의max.poll.records 를 default 500 그대로 사용한다고 하자.그러면, consumer thread 하나는, polling 할 때마다 500 건을 가져올 것이다.가져온 500 건에 대해서 한 레코드 씩, @KafkaListener 가 붙은 메서드에 전달된다.그런데, 한 레코드를 처리하는 비즈니스 로직이 1초가 걸린다고 하자.그러면, 500 건 모두 처리하는데는 얼마나 걸릴까 ? 500 초이다. (1초 * 500건) 이제 500 건은 모두 처리했으니, commit 을 하고 poll 을 통해 500 건을 가져와야한다. 그런데, commit 을 할 때 다음과 같은 Exception 이 발생한다. Commit cannot be completed since the group has already rebalanced and assigned the partitions to another member. This means that the time between subsequent calls to poll() was longer than the configured max.poll.interval.ms, which typically implies that the poll loop is spending too much time message processing. You can address this either by increasing max.poll.interval.ms or by reducing the maximum size of batches returned in poll() with max.poll.records. 요약하면 다음과 같다.poll 을 통해 가져간 records 들을 모두 처리하고 commit 할 때까지의 총 소요 시간이 max.poll.interval.ms를 초과하면 commit 에 실패한다는 것이다. max.poll.interval.ms 를 설정하지 않으면, 다음과 같이 default 로 300000 ms (300초) 이다. 500 건을 처리하는데 500 초가 걸렸으니, max.poll.interval.ms 인 300 초를 초과했다.그래서 commit 시점에 실패하게 된다. 따라서, max.poll.interval.ms 를 비즈니스 로직을 모두 처리하는 데 걸리는 시간 이상으로 조정하거나, max.poll.records 를 max.poll.interval.ms 내에 처리할 수 있을 정도로 적게 설정해야한다. https://kafka.apache.org/23/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.htmlhttps://docs.spring.io/spring-kafka/api/org/springframework/kafka/listener/ContainerProperties.AckMode.html","link":"/2021/04/22/ack-mode-batch/"},{"title":"Spring Data JPA CRUD","text":"Spring Data JPA 를 이용해서, repository 의 CRUD 를 직접 테스트한다. Requirements의존성을 다음과 같이 추가한다. 12345dependencies { implementation 'org.springframework.boot:spring-boot-starter-data-jpa' testImplementation 'com.h2database:h2' testImplementation 'org.springframework.boot:spring-boot-starter-test'} 그리고, application.yml 에 다음과 같이 정의한다.테스트 코드 실행시 수행된 SQL 을 확인하기 위함이다. 123spring: jpa: show-sql: true 도서를 “생성/조회/수정/삭제” 하는 기능을 만들기 위해, Book 클래스를 정의하자. 1234567891011121314151617181920import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entitypublic class Book { @Id @GeneratedValue private Long id; private String name; public Book() { } public Book(String name) { this.name = name; }} 그리고 repository interface 를 정의하자. 123public interface BookRepository extends JpaRepository&lt;Book, Long&gt; {} CreateBook 객체를 생성해서 저장하는 간단한 테스트 코드를 작성하자. 1234567891011121314@SpringBootTestclass BookRepositoryTest { @Autowired private BookRepository bookRepository; @Test void create() { Book book = new Book(&quot;Java&quot;); Book savedBook = bookRepository.save(book); assertNotNull(savedBook); }} 실행된 SQL 을 확인해보자.예상했던 것과 같이, insert SQL 이 수행되었다. Read이제, Book 객체를 생성하고 저장한 뒤에 조회해보자. 123456789@Testvoid read() { Book book = new Book(&quot;Java&quot;); Book savedBook = bookRepository.save(book); Book selectedBook = bookRepository.findById(savedBook.getId()).orElseThrow(EntityNotFoundException::new); assertNotNull(selectedBook);} 결과는, 이상한 점이 있다. insert 를 한뒤에 왜 select 가 수행되는 걸까 ?영속성 컨텍스트의 1차 캐쉬에 Book entity 가 남아있으면, select 수행이 필요없지 않나 ? Update이제, 저장한 Book 객체를 update 해보자. 12345678910@Testvoid update() { Book book = new Book(&quot;Java&quot;); Book savedBook = bookRepository.save(book); savedBook.setName(&quot;JPA&quot;); Book updatedBook = bookRepository.save(savedBook); assertNotNull(updatedBook);} 결과는, 여기서도, 예상했던 것과 다르게 select 가 수행이 되었다.영속성 컨텍스트의 1차 캐쉬에 Book entity 가 남아있으면, 1차 캐쉬의 Book entity 스냅샷과 변경된 Book entity 를 Dirty Checking 해서 update SQL 만 수행되어야 하는 것 아닌가 ? Delete마지막으로, 저장한 Book 객체를 delete 해본다. 1234567@Testvoid delete() { Book book = new Book(&quot;Java&quot;); Book savedBook = bookRepository.save(book); bookRepository.delete(savedBook);} 여기서도, 예상했던 것과 다르게 select 가 수행이 되었다. Transaction Range Persistence Context위에서 보았듯이, 예상했던 것과 다르게 동작했던 원인을 파악해보자.원인은, Spring 은 트랜잭션 범위의 영속성 컨텍스트 전략을 사용하기 때문이다. 즉, 트랜잭션을 시작할 때, 영속성 컨텍스트 생성하고 트랜잭션을 종료할 때, 영속성 컨텍스트 종료한다. 조회 테스트 코드를 다시 보자. 123456789@Testvoid read() { Book book = new Book(&quot;Java&quot;); Book savedBook = bookRepository.save(book); Book selectedBook = bookRepository.findById(savedBook.getId()).orElseThrow(EntityNotFoundException::new); assertNotNull(selectedBook);} 이 line 을 자세히 봐보자. 1Book savedBook = bookRepository.save(book); save 메서드를 따라가보면, @Transactional 이 붙어있다. 즉, save 메서드를 시작하면서 트랜잭션을 시작하고 영속성 컨텍스트 생성한다. save 메서드가 종료되면서 트랜잭션을 종료하고 영속성 컨텍스트 종료한다. 즉, 영속성 컨텍스트는 save 메서드 내부에서만 유효했던 것이다.findById() 에서는 Database 에서 조회하기 때문에, select SQL 이 수행되는 것이다. Optimization영속성 컨텍스트의 장점을 이용해서, 이 문제를 해결해보자.결론은, read 테스트 메서드에서 영속성 컨텍스트를 유지하도록 하면 된다.이를 위해, read 테스트 메서드에서 Transaction 을 시작하고 종료하도록 하면 된다. 즉, 아래와 같이 @Transactional 을 붙이는 것이다.@Rollback 을 추가적으로 붙인 이유는, 테스트 메서드가 종료되어도 rollback 이 발생하지 않게 함으로써 실행된 SQL 을 확인하기 위함이다. 1234567891011@Test@Transactional@Rollback(value = false)void read() { Book book = new Book(&quot;Java&quot;); Book savedBook = bookRepository.save(book); Book selectedBook = bookRepository.findById(savedBook.getId()).orElseThrow(EntityNotFoundException::new); assertNotNull(selectedBook);} 결과는, 기대했던바와 같이 추가적인 select 가 발생하지 않는다. Update, Delete 도 위와 마찬가지로 해결된다. 이 부분은 생략한다. ConclusionSpring Data JPA 를 이용해서, repository 의 CRUD 를 직접 테스트해보았다.결론은, Spring 은 트랜잭션 범위의 영속성 컨텍스트 전략을 사용한다는 것이다.Spring Data JPA 를 사용한다면, Spring 에서 JPA 를 어떻게 활용하는지 정확히 이해하고 사용할 필요가 있다. https://github.com/junhee-ko/demo-spring-data-jpa","link":"/2021/04/25/spring-data-jpa-crud/"},{"title":"코틀린 기초","text":"코틀린의 기초적인 내용들을 정리한다. 함수, 변수, 클래스, enum, property 제어 구조 smart cast exception 함수두 값 중 큰 값을 반환하는, max 함수를 작성해보자. 123fun max(a: Int, b: Int): Int { return if (a &gt; b) a else b} 위 함수 처럼, 본문이 중괄호로 둘러싸안 함수를 “블록이 본문인 함수” 라고 한다. 1fun max(a: Int, b: Int): Int = if (a &gt; b) a else b 위 함수 처럼, 본문이 등호와 식으로 이루어진 함수를 “식이 본문인 함수” 라고 한다.“식이 본문인 함수” 는 반환 타입을 작성하지 않아도 컴파일러가 식의 결과 타입을 반환 타입으로 지정해준다. 그래서, 위 함수를 아래 처럼 수정할 수 있다. 1fun max(a: Int, b: Int) = if (a &gt; b) a else b 변수12val name = &quot;jko&quot;val age: Int = 20 “식이 본문인 함수” 처럼, 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다. 변수 선언 시 사용되는 키워드는 var, val 두 가지가 있다. var : 변수의 값이 바뀔 수 있다. (variable) val : 변수의 값이 바뀔 수 없다. (value) 클래스name, isMarried 프로퍼티를 가지는 Person 클래스를 작성하자. 1234class Person( val name: String, var isMarried: Boolean) 코틀린의 기본 가시성은 public 이므로, 변경자를 생략해도 된다. 프로퍼티val 로 선언한 name 프로퍼티는 읽기 전용이다. private 이며, public getter 를 만들어낸다.var 로 선언한 isMarried 프로퍼티는 변경 가능하다. private 이며, public getter/setter 를 만들어낸다. 사용할 때는 다음과 같이 사용한다. 123456val person = Person(&quot;jko&quot;, false)println(person.name)println(person.isMarried)person.isMarried = true 커스텀 접근자프로퍼티의 접근자를 직접 작성하는 방법이 있다. 1234567class Rectangle( private val height: Int, private val width: Int) { val isSquare: Boolean get() = height == width} isSquare 프로퍼티에는 자체 값을 저장할 필요가 없다.이 프로퍼티에는 자체 구현을 제공하는 게터만 존재한다. enumenum 클래스 안에는 프로퍼티나 메서드를 정의할 수 있다. 123456789101112enum class Color( private val r: Int, private val g: Int, private val b: Int) { RED(255, 0, 0), ORANGE(255, 165, 0), YELLOW(255, 255, 0); fun rgb() = (r * 256 + g) * 256 + b} 코틀린에서 유일하게 세미콜론이 필수인 부분이다.enum class 안에 메서드를 정의 하는 경우에, enum 상수와 메서드 사이에 세미콜론이 필수다. whenJava 의 switch 에 대응하는 구성 요소가 when 이다.if 와 마찬가지로 when 도 값을 만들어내는 식이다.그래서, 식이 본문인 함수에서 when 을 바로 사용할 수 있다. 12345fun get(color: Color) = when (color) { Color.RED, Color.ORANGE -&gt; &quot;This is Red, Orange&quot; Color.YELLOW -&gt; &quot;This is Yellow&quot; } 분기 조건에 상수만을 허용하는 Java 의 switch 와 다르게 when 의 분기 조건은 아래와 같이 객체를 허용한다. 123456fun mix(c1: Color, c2: Color) = when (setOf(c1, c2)) { setOf(Color.RED, Color.YELLOW) -&gt; Color.ORANGE setOf(Color.RED, Color.ORANGE) -&gt; Color.YELLOW else -&gt; throw Exception(&quot;Nothing&quot;) } smart cast어떤 번수가 원하는 타입인지 is 로 검사하면, 굳이 변수를 원하는 타입으로 캐스팅 하지 않아도 된다.컴파일러가 캐스팅을 해준다.Sum 타입인지 검사하고 난 뒤에, e.right 와 e.left 를 사용할 수 있다. 123if( e is Sum){ return eval(e.right) + eval(e.left)} 원하는 타입으로 명시적으로 타입 캐스팅을 하려면, 1val n = e as Num iteration수에 대한 iteration 예를 보자. 1234567for (i in 1..100){ println(i)}for (i in 100 downTo 1 step 2){ println(i)} 100 downTo 1 는 역방향 수열을 만든다.step 2 는 증가 값의 절대값이 2로 바뀐다. map 에 대한 iteration 예를 보자. 123456789val map = TreeMap&lt;Char, String&gt;()for(c in 'A'..'F'){ map[c] = Integer.toBinaryString(c.code)}for ((letter, binary) in map){ println(&quot;$letter = $binary&quot;)} inin 연산자를 이용해서, 어떤 값이 범위에 속하는지 검사 가능하다. 12345fun recognize(c: Char) = when (c) { in '0'..'9' -&gt; &quot;yes&quot; in 'a'..'z' -&gt; &quot;no&quot; else -&gt; &quot;?&quot;} 예외 처리checked exception 과 unchecked exception 을 구별하지 않는다.함수가 던지는 예외를 지정하지 않을 뿐만 아니라, 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다. try 키워드는 if 나 when 과 마찬가지로 식이다. 그래서, try 의 값을 변수에 대입 가능하다. 1234567fun readNumber(reader: BufferedReader) { val number = try { Integer.parseInt(reader.readLine()) } catch (e: NumberFormatException) { null }} Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/01/kotlin-basic/"},{"title":"함수 정의와 호출","text":"다음 내용들을 정리한다. 함수 정의와 호출 확장 함수와 확장 프로퍼티 컬렉션코틀린에서의 자체 컬렉션 기능은 없다.자바의 컬렉션을 사용한다. 1234567val set = hashSetOf(1, 2, 3)val list = arrayListOf(1, 2, 3)val map = hashMapOf(1 to &quot;one&quot;, 2 to &quot;two&quot;, 3 to &quot;three &quot;)println(set.javaClass) // java 의 getClass() 와 동일println(list.javaClass)println(map.javaClass) 출력 결과는 다음과 같다. 123class java.util.HashSet class java.util.ArrayList class java.util.HashMap 함수 구현collection 의 원소에 prefix, postfix 를 붙이고 separator 로 구분짓는 메서드를 만들자. 1234567891011121314151617181920fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String): String { val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) { if (index &gt; 0) result.append(separator) result.append(element) } result.append(postfix) return result.toString()}fun main() { val list = listOf(1, 2, 3) println(joinToString(list, &quot;; &quot;, &quot;(&quot;, &quot;)&quot;))} 출력 결과는 다음과 같다. 1(1; 2; 3) 이름 붙인 인자함수 호출 부분의 가독성을 높여보자.함수에 전달하는 인자 중, 일부 또는 전부의 이름을 명시할 수 있다. 123456joinToString( collection = list, separator = &quot;; &quot;, prefix = &quot;(&quot;, postfix = &quot;)&quot;) 디폴트 파라미터 값자바에서는 하위 호환성을 유지하거나 API 사용자에게 편의를 주기 위해, 오버로딩 메서드들이 만들어진다.즉, 코드 중복의 문제가 발생한다. 코틀린에서는, 함수 선언에서 파라미터의 디폴트 값을 지정함으로써 이 문제를 해결한다. 123456fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = &quot;, &quot;, prefix: String = &quot;&quot;, postfix: String = &quot;&quot;) 그러면, 함수를 호출할 때, 인자를 모두 쓰거나 일부 생략이 가능하다. 12joinToString(list)joinToString(list, &quot;; &quot;) 최상위 함수자바에서는, 모든 코드를 클래스의 메서드로 작성해야한다.그래서, 정적 메서드를 모아두는 역할을 하는 Util 이라는 이름이 붙은 클래스가 만들어지는 경우가 있다. 코틀린에서는, 함수를 직접 소스 파일의 최상위 수준에 위치시키면 된다.그리고 코틀린 컴파일러는 소스파일의 이름에 대응하는 클래스를 생성해낸다. 12345678package functionfun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = &quot;, &quot;, prefix: String = &quot;&quot;, postfix: String = &quot;&quot;) 확장 함수와 확장 프로퍼티확장 함수란, 어떤 클래스의 메서드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수이다. 1234567package stringsfun String.lastChar(): Char = this.get(this.length - 1)fun main() { println(&quot;Kotlin&quot;.lastChar())} 확장 함수를 만들기 위해서는, 추가하려는 함수 이름 앞에 함수가 확장할 클래스의 이름을 붙이면 된다.클래스 이름을 “수신 객체 타입”, 호출 되는 대상이 되는 값을 “수신 객체” 라고 한다. 위 코드에서는, String : 수신 객체 타입 “Kotlin” : 수신 객체 확장 함수 임포트함장 함수를 사용하려면, 그 함수를 임포트해야한다. 1234567package stringsclientimport strings.lastCharfun main() { println(&quot;Kotlin&quot;.lastChar())} as 키워드를 붙이면 임포트한 클래스나 함수를 다른 이름으로 호출할 수 있다. 1234567package stringsclientimport strings.lastChar as lastfun main() { println(&quot;Kotlin&quot;.last())} 확장 함수로 정의이제 joinToString 함수를 확장함수로 만들어보자. 1234567891011121314fun &lt;T&gt; Collection&lt;T&gt;.joinToString( // Collection&lt;T&gt; 에 대한 확장 함수 선언 separator: String = &quot;, &quot;, prefix: String = &quot;&quot;, postfix: String = &quot;&quot;): String { val result = StringBuilder(prefix) for ((index, element) in this.withIndex()) { // this: 수신 객체를 가리킴. 여기서는, Collection&lt;T&gt; if (index &gt; 0) result.append(separator) result.append(element) } result.append(postfix) return result.toString()} 사용할 때는, 12345678import function.joinToStringfun main() { val list = listOf(1, 2, 3) val joinToString = list.joinToString(separator = &quot;; &quot;, prefix = &quot;(&quot;, postfix = &quot;)&quot;) println(joinToString)} 확장 프로퍼티1234567891011var StringBuilder.lastChar: Char get() = get(length - 1) set(value: Char) { this.setCharAt(length - 1, value) }fun main() { val stringBuilder = StringBuilder(&quot;Kotlin?&quot;) val lastChar = stringBuilder.lastChar println(lastChar)} 자바 컬렉션 API 확장1234567fun main() { val list = listOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) println(list.last()) val set = setOf(1, 2, 3) println(set.maxOrNull())} 어떻게 Java 의 컬렉션 API 에 정의되어있지 않은 last() 와 maxOrNull() 을 호출할 수 있었을까 ?last() 와 maxOrNull() 이 확장함수 이기 때문이다.다음과 같이 정의되어 있다. 1234567891011121314151617public fun &lt;T&gt; List&lt;T&gt;.last(): T { if (isEmpty()) throw NoSuchElementException(&quot;List is empty.&quot;) return this[lastIndex]}@SinceKotlin(&quot;1.4&quot;)public fun &lt;T : Comparable&lt;T&gt;&gt; Iterable&lt;T&gt;.maxOrNull(): T? { val iterator = iterator() if (!iterator.hasNext()) return null var max = iterator.next() while (iterator.hasNext()) { val e = iterator.next() if (max &lt; e) max = e } return max} 가변 인자 함수리스트를 생성할 때, 다음과 같이 원하는 만큼 인자를 전달할 수 있다. 1val list = listOf(1,2,3,4,5,6) listOf 함수의 정의를 보자. 1public fun &lt;T&gt; listOf(vararg elements: T): List&lt;T&gt; = if (elements.size &gt; 0) elements.asList() else emptyList() vararg 는, 자바에서의 … 와 동일한 역할을 한다. 중위 호출맵을 만들기 위해서는 1val map = mapOf(1 to &quot;one&quot;, 2 to &quot;two&quot;) 여기서 to 는 일반 메서드이다.중위 호출 이라는 방식으로 to 라는 일반 메서드를 호출한 것이다.다음 두 호출은 동일하다. 1.to(“one”)1 to “one” 인자가 하나뿐인 일반 메서드나 확장 함수에 중위 호출을 사용할 수 있다.중위 호출이 가능하게 만들려면, infix 변경자를 함수 선언 앞에 붙이면 된다. to 메서드는 다음과 같이 정의되어 있다. 1public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) 로컬 함수와 확장12345678910111213class User(val id: Int, val name: String, val address: String)fun saveUser(user: User) { if (user.name.isEmpty()) { throw IllegalArgumentException(&quot;${user.id}&quot;) } if (user.address.isEmpty()) { throw IllegalArgumentException(&quot;${user.id}&quot;) } // save } 검증 코드를 로컬함수로 분리해보자. 1234567891011121314class User(val id: Int, val name: String, val address: String)fun saveUser(user: User) { fun validate(user: User, value: String) { if (value.isEmpty()) { throw IllegalArgumentException(&quot;${user.id}&quot;) } } validate(user, user.name) validate(user, user.address) // save} 위 코드에서, 로컬 함수에게 user 객체를 계속 전달하고 있다.하지만, 사실 전달할 필요가 없다.로컬함수는 자신이 속한 바깥 함수의 모든 파라미터에 접근 가능하기 때문이다. 123456789101112fun saveUser(user: User) { fun validate(value: String) { if (value.isEmpty()) { throw IllegalArgumentException(&quot;${user.id}&quot;) } } validate(user.name) validate(user.address) // save} 위 코드를 더 개선하고자 하면, 검증 로직을 User 클래스의 확장 함수로 만들 수도 있다. 12345678910111213141516class User(val id: Int, val name: String, val address: String)fun User.validateBeforeSave() { fun validate(value: String) { if (value.isEmpty()) { throw IllegalArgumentException(&quot;$id&quot;) } } validate(name) validate(address)}fun saveUser(user: User) { // save} Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/01/kotlin-function/"},{"title":"클래스","text":"다음 내용을 정리한다. 클래스 계층을 정의하는 방식 상속 제어 변경자 가시성 변경자 sealed 변경자 인터페이스간단한 인터페이스를 정의해보자. 123interface Clickable { fun click()} 위 간단한 인터페이스를 구현해보자. 123class Button : Clickable { override fun click() = println(&quot;Button was clicked&quot;)} 코틀린에서는 위와 같이,클래스 이름 뒤에 콜론을 붙여서 클래스 확장과 인터페이스 구현을 모두 처리한다. 그리고, override 변경자를 반드시 사용해야한다.이는, 실수로 상위 클래스의 메서드를 오버라이드하는 경우를 방지한다. 인터페이스 메서드도 디폴트 구현을 제공할 수 있다.자바처럼 default 키워드를 붙일 필요는 없다. 1234interface Clickable { fun click() fun showOff() = println(&quot;I am clickable&quot;)} showOff() 메서드를 정의하는, 다른 인터페이스를 정의해보자. 1234interface Focusable { fun setFocus(b: Boolean) = println(&quot;Set Foucs&quot;) fun showOff() = println(&quot;I am focusable&quot;)} 한 클래스가 Clickable, Focusable 인터페이를 같이 구현하면 어떻게 될까 ?두 인터페이스 모두가 showOff 디폴트 메서드가 있는데, 어느 메서드가 선택될까 ?정답은, showOff 구현을 대체할 오버라이딩 메서드가 없으면, 컴파일 에러가 발생한다. 따라서, 아래와 같이 직접 구현해야한다. 12345678class Button : Clickable, Focusable { override fun click() = println(&quot;Button was clicked&quot;) override fun showOff() { super&lt;Clickable&gt;.showOff() super&lt;Focusable&gt;.showOff() }} 상속 제어 변경자 : final자바의 클래스와 메서드는 기본적으로 상속에 대해 열려있다.하지만, 코틀린에서는 닫여있다. 즉, final 이다. 어떤 클래스의 상속을 허용하려면, open 변경자를 붙여야한다.그리고, 오버라이드를 허용하고 싶은 메서드나 프로퍼티 앞에도 open 변경자를 붙여야한다. 12345open class RichButton : Clickable { fun disable() {} // final. 하위 클래스가 오버라이드 불가능 open fun animate() {} // open. 하위 클래스가 오버라이드 가능 override fun click() {} // open. 하위 클래스가 오버라이드 가능} 기반 클래스나 인터페이스를 오버라이드하면, 그 메서드는 open 이다.오버라이드한 메서드의 구현을 하위 클래스에서 오버라이드 못하게 하려면,아래와 같이 final 을 붙이자. 12345open class RichButton : Clickable { fun disable() {} open fun animate() {} final override fun click() {} // Here !!} 추상 멤버는 항상 열려있다.하위 클래스에서 이 추상 멤버를 오버라이드 해야하기 때문이다. 12345abstract class Animated { abstract fun animate() fun animateTwice() {} // 추상 클래스에 속해도, 비추상 함수는 기본적으로 final open fun stopAnimating() {}} 가시성 변경자 : public가시성 변경자는, 클래스의 외부 접근을 제어한다.자바의 기본 가시성은 package-private 이다. ( visible only from the same package )코틀린에서는, public 이다. 코틀린에서는, 패키지를 namespace 관리 목적으로만 사용한다.그래서, 패키지를 가시성 제어에 사용하지 않는다. 대신, internal 이라는 가시성 변경자가 있다.모듈 내부에서만 볼 수 있다는 뜻이다.모듈이란, 한 번에 컴파일 되는 코틀린 파일들을 의미한다. 봉인된 클래스 : 계층 확장 제한상위 클래스인 Expr 과숫자를 표현하는 Num, 덧셈을 표현하는 Sum 두 하위 클래스가 있다. 123interface Exprclass Num(val value: Int) : Exprclass Sum(val left: Expr, val right: Expr) : Expr when 을 사용해 Expr 의 타입을 검사할 때,디폴트 분기인 else 가 반드시 있어야한다. 123456fun eval(e: Expr): Int = when (e) { is Num -&gt; e.value is Sum -&gt; eval(e.right) + eval(e.left) else -&gt; throw IllegalArgumentException() } 만약, 새로운 클래스를 추가하고 위 분기에 추가를 하지 않으면디폴트 분기가 선택되어서 버그가 발생할 수 있다. 이 문제는, sealed 클래스로 해결할 수 있다.상위 클래스에 sealed 변경자를 붙이면, 하위 클래스 정의를 제한한다. 1234sealed class Expr { class Num(val value: Int) : Expr() class Sum(val left: Expr, val right: Expr) : Expr()} 그러면, 아래와 같이 else 분기가 필요없다. 12345fun eval(e: Expr): Int = when (e) { is Expr.Num -&gt; e.value is Expr.Sum -&gt; eval(e.right) + eval(e.left) } 만약, sealed 클래스의 하위 클래스가 추가된다면,when 식이 컴파일 되지 않아 when 식을 고쳐야한다는 사실을 쉽게 알 수 있다. Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/07/kotlin-class/"},{"title":"생성자","text":"다음 내용을 정리한다. 주 생성자, 부 생성자 초기화 블록 프로퍼티 클래스 초기화 : 주 생성자, 초기화 블록클래스 이름 뒤에 괄호로 둘러싸인 코드가 주 생성자이다. 1class User(val nickname: String) 같은 목적을 이룰 수 있는 다은 형태의 코드를 보자. 1234567class User constructor(_nickname: String) { val nickname: String init { nickname = _nickname // _ : 프로퍼티와 생성자 파라미터를 구분하기 위해 사용 }} constructor 키워드는, 주 생성자나 부 생성자를 정의할 때 사용한다.init 키워드는, 초기화 블록을 시작한다. 초기화 블록은, 클래스의 객체가 만들어질 때 실행된다. 위 코드에서, nickname 프로퍼티를 초기화 하는 코드를, nickname 프로퍼티 선언에 포함 가능 주 생성자 앞에 다른 annotation 이나 가시성 변경자 없다면, constructor 키워드 생략 가능 그래서, 123class User(_nickname: String) { val nickname = _nickname} 그런데, val 을 추가해서 주 생성자의 파라미터로 프로퍼티를 초기화 가능하다.이렇게. 1class User(val nickname: String) 클래스에 기반 클래스가 있으면,주 생성자에서 기반 클래스의 생성자를 호출할 필요가 있다.기반 클래스 이름 뒤에 괄호를 쳐서 생성자 인자를 넘기면 된다. 12open class User(val nickname: String)class FacebookUser(nickName: String) : User(nickName) // Here !! 만약, 클래스 정의할 때 별도로 생성자를 정의하지 않으면컴파일러가 자동으로 인자 없는 디폴트 생성자를 만든다.하위 클래스는 기반 클래스의 이 디폴트 생성자를 호출해야한다.이렇게. 12open class Buttonclass RadioButton: Button() // Here !! 이 처럼, 기반 클래스의 이름 뒤에는 꼭 괄호가 들어간다.인터페이스는 생성자가 없어서, 어떤 클래스가 구현하는 경우 괄호가 안 들어간다. 부 생성자 : 상위 클래스를 다른 방식으로 초기화클래스에 주 생성자가 없으면,모든 부 생성자는 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야한다. 123456789101112131415161718192021open class View { constructor(button: String) { // ... } constructor(button: String, image: String) { // ... }}class Button : View { constructor(button: String) : this(button, &quot;IMAGE&quot;){ // 위임 // ... } constructor(button: String, image: String) : super(button, image) { // 상위 클래스 초기화 // ... }} 인터페이스에 선언된 프로퍼티인터페이스에 추상 프로퍼티 선언을 넣을 수 있다. 123interface User { val nickname: String} 이 인터페이스를 구현하는 방법을 보자. 1class PrivateUser(override val nickname: String) : User User 의 추상 프로퍼티를 구현하므로, override 를 붙여야한다. 1234class SubscribingUser(val email: String) : User { override val nickname: String get() = email.substringBefore('@')} 뒷받침 필드에 값을 저장하지 않고,매번 이메일 주소에서 별명을 계산해서 반환한다. 1234567class FacebookUser(val accountId: Int) : User { override val nickname = getFacebookName(accountId) private fun getFacebookName(accountId: Int): String { return &quot;test:accountId&quot; }} 객체를 초기화하는 단계에서 한 번만, getFacebookName 을 호출한다. getter, setter 에서 뒷받침하는 필드에 접근field 키워드를 이용해서 뒷밤침 필드에 접근 가능하다. 12345678910111213class User(val name: String) { var address: String = &quot;Incheon&quot; set(value: String) { println( &quot;&quot;&quot; address was changed !! $field -&gt; $value &quot;&quot;&quot;.trimIndent() // 뒷받침 필드 읽기 ) field = value // 뒷받침 필드 쓰기 }} 접근자 가시성 변경접근자의 가시성은 프로퍼티 가시성과 같다.get, set 앞에 가시성 변경자를 추가해서, 접근자 가시성을 변경할 수 있다. 123456789class LengthCounter { var counter: Int = 0 private set fun addWord(word: String) { counter += word.length }} private set 때문에, 외부에서 단어 길이 합을 마음대로 바꿀 수 없다. Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/07/kotlin-constructor/"},{"title":"데이터 클래스","text":"다음 내용을 정리한다. 데이터 클래스 : toString(), equals(), hashCode(), copy() 클래스 위임 패턴 : by 모든 클래스가 정의해야하는 메서드간단한 클래스를 작성해보자. 1class Client(val name: String, val postCode: Int) 이 클래스에 대해서,toString(), equals(), hashCode() 메서드들이 어떻게 사용되는지 보자. toString()기본 제공되는 객체의 문자열 표현은 다음과 같은 형식이다 : Client@5e9f23bf기본 구현을 바꾸려면 toString 메서드를 오버라이드해야한다. 1234class Client(val name: String, val postCode: Int) { override fun toString(): String = &quot;Client(name='$name', postCode=$postCode)&quot;} equals()123val client1 = Client(&quot;jko&quot;, 1234)val client2 = Client(&quot;jko&quot;, 1234)println(client1 == client2) 위 프린트의 결과는 false 이다.코틀린에서 == 는 참조 동일성을 검사하지 않는다.객체의 동등성을 검사한다.그래서, equals 를 호출하는 식으로 컴파일 된다. Client 클래스에 equals 를 추가해보자. 12345678910111213141516class Client(val name: String, val postCode: Int) { override fun equals(other: Any?): Boolean { if (this === other) return true if (javaClass != other?.javaClass) return false other as Client if (name != other.name) return false if (postCode != other.postCode) return false return true } override fun toString(): String = &quot;Client(name='$name', postCode=$postCode)&quot;} 그러면, 이제 프린트의 결과는 true 이다. hashCode()12val hashSet = hashSetOf(Client(&quot;jko&quot;, 1234))println(hashSet.contains(Client(&quot;jko&quot;, 1234))) 위 프린트의 결과는 false 이다.HashSet 은 원소를 비교할 때의 비용을 줄이기 위해, 객체의 해쉬 코드를 비교 같으면, 실제 값을 비교 그런데, 위 예에서는 두 Client 객체의 해쉬 코드가 다르기 때문에두 번째 Client 객체가 집합 안에 들어있지 않다고 판단한다. 이 문제를 해결하려면 Client 클래스가 hashCode 를 구현하면 된다. 12345678910111213141516171819202122class Client(val name: String, val postCode: Int) { override fun equals(other: Any?): Boolean { if (this === other) return true if (javaClass != other?.javaClass) return false other as Client if (name != other.name) return false if (postCode != other.postCode) return false return true } override fun hashCode(): Int { var result = name.hashCode() result = 31 * result + postCode return result } override fun toString(): String = &quot;Client(name='$name', postCode=$postCode)&quot;} 데이터 클래스어떤 클래스가 데이터를 저장하는 역할만을 수행한다면toString, equals, hashCode 메서드를 반드시 오버라이드해야한다. 코틀린의 data 클래스는 이 메서드들이 컴파일러에 의해 자동으로 만들어진다. 1data class Client(val name: String, val postCode: Int) copy()데이터 클래스의 객체를 불변 객체로 쉽게 활용할 수 있도록,코틀린 컴파일러는 copy 메서드를 만들어준다. 12val origin = Client(&quot;jko&quot;, 1234)val copy = origin.copy(name = &quot;jko&quot;, postCode = 5678) by : 클래스 위임상속을 허용하지 않는 클래스에 새로운 동작을 추가해아할 때가 있다.이럴 때, Decorator 패턴을 사용한다. 핵심은, 기존 클래스와 같은 인터페이스를 데코레이터가 제공하고 기존 클래스를 데코레이터의 내부 필드로 유지 다음 예를 보자. 12345678910class DelegatingCollection&lt;T&gt; : Collection&lt;T&gt; { private val innerList = arrayListOf&lt;T&gt;() override val size: Int = innerList.size override fun contains(element: T): Boolean = innerList.contains(element) override fun containsAll(elements: Collection&lt;T&gt;): Boolean = innerList.containsAll(elements) override fun isEmpty(): Boolean = innerList.isEmpty() override fun iterator(): Iterator&lt;T&gt; = innerList.iterator()} 위 코드는, 코틀린의 by 키워드를 사용해서인터페이스에 대한 구현을 다른 객체에 위임 중이라고 명시할 수 있다. 12345class DelegatingCollection&lt;T&gt;( innerList : Collection&lt;T&gt; = ArrayList&lt;T&gt;()) : Collection&lt;T&gt; by innerList { } Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/07/kotlin-data-class/"},{"title":"object 키워드","text":"object 키워드가 사용되는 경우인,다음 내용을 정리한다. 객체 선언 동반 객체 객체 식 객체 선언 : 싱글턴 객체 생성코틀린은 ‘객체 선언’ 을 통해, 싱글턴 패턴을 지원한다.‘객체 선언’ = ‘클래스 선언 + 그 클래스에 속한 단일 객체 선언’ 123456789object Payroll { val allEmployees = arrayListOf&lt;Person&gt;() fun calculateSalary() { for (person in allEmployees) { //.. } }} 사용할 때는, 12Payroll.allEmployees.add(Person(name = &quot;jko&quot;, isMarried = false))Payroll.calculateSalary() 일반 클래스의 객체와 달리,싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출없이 즉이 만들어진다. java.util.Comparator 인터페이스는,두 객체를 인자로 받아 어느 객체가 더 큰지 알려주는 정수를 반환한다.아래와 같이, 클래스 안에 객체로 선언할 수 있다. 123456data class Person(val name: String) { object NameComparator : Comparator&lt;Person&gt; { override fun compare(o1: Person, o2: Person): Int = o1.name.compareTo(o2.name) }} 사용할 때는, 12val persons = listOf(Person(&quot;jko&quot;), Person(&quot;junhee-ko&quot;))println(persons.sortedWith(Person.NameComparator)) 동반 객체 : 팩토리 메서드와 정적 멤버가 들어갈 장소코틀린은, static 키워드를 지원하지 않는다.대신, top-level function 을 지원한다.하지만, top-level function 은 클래스의 비공개(private) 멤버에 접근할 수 없다. 그래서, 클래스의 객체와 관계없이 호출하며 클래스의 내부 정보에 접근해야하는 함수가 필요할 때는클래스에 중첩된 객체 선언의 멤버 함수로 정의해야한다. 아래 코드는,생성자를 통해 User 객체를 만들 수 없고 팩토리 메서드를 이용해야한다. 1234567class User private constructor(val nickName: String) { companion object { fun newSubscribingUser(email: String) = User(email.substringBefore('@')) fun newFacebookUser(accountId: Int) = User(&quot;test:accountId&quot;) }} 사용할 때는, 12val subscribingUser = User.newSubscribingUser(&quot;junheee.ko@gmail.com&quot;)val facebookUser = User.newFacebookUser(1) 동반 객체도 결국, 클래스 안에 정의된 일반 객체이다.그래서, 이름을 붙이거나 인터페이스를 상속하거나 동반 객체 안에 확장 함수와 프로퍼티를 정의할 수 있다. 이름 붙이기123456class Person(val name: String) { companion object Loader { fun fromJson(jsonText: String): Person = Person(&quot;$jsonText&quot;) }} 사용할 때는, 12println(Person.Loader.fromJson(&quot;{name: 'jko'}&quot;))println(Person.fromJson(&quot;{name: 'junhee-ko'}&quot;)) 인터페이스 구현12345678910interface JsonFactory&lt;T&gt;{ fun fromJson(jsonText: String): T}class Person(val name: String) { companion object : JsonFactory&lt;Person&gt; { override fun fromJson(jsonText: String): Person = Person(&quot;$jsonText&quot;) }} 동반 객체 확장12345678class Person(val name: String) { companion object { // empty }}fun Person.Companion.fromJson(json: String): Person = Person(&quot;$json&quot;) fromJson 은 클래스 밖에 정의한 확장 함수이다.그런데, 동반 객체 안에 정의한 것 처럼 호출 할 수 있다.이렇게. 1Person.fromJson(&quot;....&quot;) 객체 식 : 무병 내부 클래스를 다른 방식으로 작성anonymous object (무명 객체) 를 정의할 때 object 키워드를 사용할 수 있다.무명 객체는 자바의 무명 내부 클래스를 대신한다. 1234567891011fun countClicks(window: Window) { var clickCount = 0 window.addMouseListener( object : MouseAdapter() { override fun mouseClicked(e: MouseEvent?) { clickCount++ } } )} 객체 선언과 다르게 클래스나 인스턴스에 이름을 붙이지 않는다. 싱글턴이 아니다. 즉, 객체 식이 쓰일 때마다 새로운 인스턴스를 생성한다. 객체 식은 무명 객체 안에서 여러 메서드를 오버라이드해야하는 경우 유용하다.메서드가 하나 뿐인 인터페이스를 구현해야하면, 코틀린의 SAM 변환 지원을 활용하는 것이 좋다. Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/07/kotlin-object-keyword/"},{"title":"람다","text":"코틀린의 람다에 대해 정리한다. 람다 소개아래와 같은 내용을 코드로 적용하려면 어떻게 해야할까 ? 이벤트가 발생하면 이 Handler 를 실행하자 모든 원소에 이 연산을 적용하자 자바에서는 무명 내부 클래스를 사용해, 클래스를 선언하고 그 클래스의 인스턴스를 함수에 넘길 수 있다.함수형 프로그래밍에서는 함수를 직접 다른 함수에 전달할 수 있다. 자바의 다음 예를 보자. 123456button.setOnClickListener(new onClickListener(){ @Override public void onClick(View view){ // event when clicked }}); 무명 내부 클래스를 선언해서, 코드가 번잡하다.코틀린에서는, 자바 8 과 마찬가지로 람다를 사용할 수 있다. 1button.setOnClickListener { /* event when clicked */ } 람다와 컬렉션이름과 나이를 저장하는 Person 클래스가 있다. 1data class Person(val name: String, val age: Int) 사람 리스트에서, 가장 연장자를 찾아보자. 123456789101112131415161718fun findTheOldest(people: List&lt;Person&gt;) { var maxAge = 0 var theOldest: Person? = null for (person in people) { if (person.age &gt; maxAge) { maxAge = person.age theOldest = person } } println(theOldest)}fun main() { val people = listOf(Person(&quot;jko&quot;, 12), Person(&quot;junhee-ko&quot;, 30)) findTheOldest(people)} 코틀린에서는, 라이브러리를 사용하면 아래와 같이 쉽게 구현이 가능하다. 1println(people.maxByOrNull { it.age }) 단지 함수나 프로퍼티를 반환하는 람다는, 멤버 참조로 대치 가능하다. 1println(people.maxByOrNull(Person::age)) 람다 식의 문법람다 식을 선언하기 위한 문법은 아래와 같다. 람다 식은 변수에 저장할 수 있다. 12val sum = { x: Int, y: Int -&gt; x + y }println(sum(1, 2)) 다음 예를 다시 보자. 12val people = listOf(Person(&quot;jko&quot;, 12), Person(&quot;junhee-ko&quot;, 30))println(people.maxByOrNull { it.age }) 위 코드를 정식으로 다시 작성하면, 1people.maxByOrNull({ p: Person -&gt; p.age }) 이 코드를 차례대로 개선해보자.우선, 함수 호출 시 맨 뒤에 있는 파라피터가 람다 식이면 그 람다를 괄호 밖으로 추출 가능하다. 1people.maxByOrNull() { p: Person -&gt; p.age } 위 코드처럼, 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 빈 괄호를 없앨 수 있다. 1people.maxByOrNull { p: Person -&gt; p.age } 그리고, 컴파일러는 람다 파라피터의 타입도 추론 가능하다. 그래서, 1people.maxByOrNull { p -&gt; p.age } 마지막으로, 람다의 파라미터가 하나 뿐이고 컴파일러가 타입을 추론할 수 있으면 it 을 사용할 수 있다. 1people.maxByOrNull { it.age } 만약, 본문이 여러 줄로 이뤄진 경우 본문의 맨 마지막에 있는 식이 람다의 결과 값이다. 123456val sum = { x: Int, y: Int -&gt; println(&quot;Ing sum...&quot;) x + y}println(sum(1, 2)) 현재 영역에 있는 변수 접근람다를 함수 안에서 사용하면, 함수의 파라미터 뿐만 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 사용가능하다. 다음 예를 보면, 람다 안에서 함수의 prefix 파라미터를 사용하고 있다. 12345678910fun printMessageWithPrefix(messages: Collection&lt;String&gt;, prefix: String) { messages.forEach { println(&quot;$prefix $it&quot;) // HERE !! }}fun main() { val errors = listOf(&quot;403 Forbidden&quot;, &quot;404 Not Found&quot;) printMessageWithPrefix(errors, &quot;Error :&quot;)} 자바와 다른 중요한 점은, 코틀린의 람다 안에서는 final 변수가 아닌 변수에도 접근할 수 있다는 것이다.다음 예를 보자. 1234567891011121314fun printProblemCounts(responses: Collection&lt;String&gt;) { var clientErrors = 0 var serverErrors = 0 responses.forEach { if (it.startsWith(&quot;4&quot;)) { clientErrors++ } else if (it.startsWith(&quot;5&quot;)) { serverErrors++ } } println(&quot;client errors : $clientErrors, server erros : $serverErrors&quot;)} 위의 코드처럼,람다 안에서 사용하는 외부 변수 (clientErrors, serverErrors) 를 람다가 포획 (capture) 한 변수라고 한다. 멤버 참조람다를 사용해서 코드 블록을 다른 함수에 넘기는 방법은 정리했다.그런데, 함수를 직접 넘기는 방법은 없을까 ?함수를 값으로 변경해서 넘기면 된다. 1val getAge = Person::age :: 를 사용하는 식이, 멤버 참조 (Member Reference) 이다.멤버 참조는 프로퍼티나 메서드를 단 하나만 호출하는 함수 값을 만들어준다. 최상위에 선언된 함수, 프로퍼티최상위에 선언된 (다른 클래스의 멤버가 아닌) 함수나 프로퍼티 참조도 가능하다. 12fun hello() = println(&quot;hello&quot;)run(::hello) 위 코드를 보면, 클래스 이름을 생략했다.hello 라는 멤버 참조를 run 라이브러리 함수에 넘긴다.run 은 인자로 받은 람다를 호출하는 역할을 한다. 생성자 참조생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장 가능하다. 1234data class Person(val name: String, val age: Int)val createPerson = ::Personval person = createPerson(&quot;junhee&quot;, 30) 확장 함수확장 함수도 멤버 함수와 동일한 방식으로 참조 가능하다. 12fun Person.isAdult() = age &gt; 21val predicate = Person::isAdult 자바 메서드에 람다를 인자로 전달함수형 인터페이스를 인자로 원하는 자바 메서드에 코틀린 람다를 전달할 수 있다. 1void postphoneComputation(int delay,Runnable computation) 위 자바 메서드에, 코틀린에서는 람다를 넘길 수 있다. 1postphoneComputation(1000) { println(42) } 코틀린에서는, 람다를 Runnable 인스턴스로 변환해준다.즉, Runnable 을 구현한 무명 클래스의 인스턴스를 만들어준다. Runnable 을 구현하는 무명 객체를 명시적으로 만들어서 사용할 수도 있다. 12345postphoneComputation(1000, object : Runnable { override fun run() { println(42) }}) 객체를 명시적으로 선언하는 경우, 메서드가 호출될 때마다 객체가 생성된다.람다는, 람다에 대응하는 무명 객체를 메서드가 호출 될 때마다 반복 사용한다. Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/15/kotlin-lamda/"},{"title":"지연 계산 컬렉션","text":"lazy collection 연산에 대해 정리한다. 지연 계산 (lazy) 켈렉션 연산다음 예를 보자. 123people .map(Person::name) .filter { it.startsWith(&quot;A&quot;) } filter 와 map 은 리스트를 반환한다.즉 위 코드는, 한 리스트는 filter 의 결과를 담고 다른 리스트는 map 의 결과를 담는다.원소의 개수가 수백만 개라면 효율이 떨어질 수 있다. 그래서, 각 연산이 컬렉션을 직접 사용하는 대신 시퀀스를 사용하게 만들어 효율을 높일 수 있다. 1234people.asSequence() // 원본 컬렉션을 시퀀스로 변환 .map(Person::name) .filter { it.startsWith(&quot;A&quot;) } .toList() // 결과 시퀀스를 다시 리스트로 변환 시퀀스 연산 실행 : 중간 연산, 최종 연산자바 8의 스트림과 코틀린의 시퀀스의 개념은 같다. 중간 연산은 다른 시퀀스를 반환한다.최종 연산은 결과를 반환한다. 다음 코드를 다시 보자. 1234people.asSequence() .map(Person::name) // 중간 연산 .filter { it.startsWith(&quot;A&quot;) } // 중간 연산 .toList() // 최종 연산 중간 연산은 항상 지연 계산된다.즉, 최종 연산이 호출될 때 적용 된다는 뜻이다. 다음 코드를 보자.실행하면, 아무 내용도 출력되지 않는다. 123456789listOf(1, 2, 3, 4).asSequence() .map { println(&quot;map $it&quot;) it * it } .filter { println(&quot;filter $it&quot;) it % 2 == 0 } 아래와 같이, toList() 를 추가하면 모든 계산이 수행된다. 1234567891011listOf(1, 2, 3, 4).asSequence() .map { println(&quot;map $it&quot;) it * it } .filter { println(&quot;filter $it&quot;) it % 2 == 0 } .toList() 다른 예를 보자. map 으로 리스트의 각 숫자를 제곱하고, 제곱한 숫자 중에 find 로 3 보다 큰 첫 번째 원소를 찾자. 123456789val lazy = listOf(1, 2, 3, 4).asSequence() .map { it * it } .find { it &gt; 3 }println(lazy)val eager = listOf(1, 2, 3, 4) .map { it * it } .find { it &gt; 3 }println(eager) 위 코드의 결과는 모두 4 이지만, 즉시 계산 (컬렉션 사용) 과 지연 계산 (시퀀스 사용) 의 차이를 보여준다. 컬렉션을 사용하면, 리스트가 다른 리스트로 일단 모두 변환 된다. 그래서 map 연산의 결과는 9, 16 을 포함한다. 그리고, find 가 술어를 만족하는 첫 번 째 원소인 4 를 찾는다. 시퀀스를 사용하면, find 호출이 원소를 하나씩 처리하기 시작한다. 1 을 가져와서 map 에 지정된 변환을 수행하고 find 에 지정된 술어를 만족하는지 확인한다. 2 를 가져와서 map 에 지정된 변환을 수행하고 find 에 지정된 술어를 만족하는지 확인한다. 만족한다. 그래서 결과로 반한한다. 그러면, 답을 찾았기 때문에 3, 4 를 처리할 필요가 없다. Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/15/kotlin-lazy-collection/"},{"title":"표준 라이브러리","text":"컬렉션을 다루는 코틀린 표준 라이브러리를 정리한다. filter, map all, any, count, find groupBy flatMap, flatten with, apply filter, mapfilter 는 컬렉션에서 원치 않는 원소를 제거한다. 12val list = listOf(1, 2, 3, 4)println(list.filter { it % 2 == 0 }) 결과는,컬렉션의 원소 중에, 주어진 술어 (==predicate, 참/거짓을 반환하는 함수) 를 만족하는 원소로 이루어진 새로운 컬렉션이다. map 은 원소를 변환한다. 12val list = listOf(1, 2, 3, 4)println(list.map { it * it }) 결과는,원본 리스트와 원소 개수는 같지만 각 원소는 주어진 함수에 따라 변환된 새로운 컬렉션이다. all, any, count, find all, any : 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단 count : 조건을 만족하는 원소의 개수 반환 find : 조건을 만족하는 첫 번째 원소 반환 어떤 사람의 나이가 25 살 이하인지 판단하는 술어 함수를 만들자. 1val under25 = { p: Person -&gt; p.age &lt; 25 } 모든 원소가 이 술어를 만족하는지 판단하려면 all 을 함수를 쓰자. 12val people = listOf(Person(&quot;jko&quot;, 30), Person(&quot;junhee-ko&quot;, 20))println(people.all(under25)) 술어를 만족하는 원소가 하나라도 있는지 판단하려면 any 를 쓰자. 12val people = listOf(Person(&quot;jko&quot;, 30), Person(&quot;junhee-ko&quot;, 20))println(people.any(under25)) 술어를 만족하는 원소 개수를 구하려면, count 를 쓰자. 12val people = listOf(Person(&quot;jko&quot;, 30), Person(&quot;junhee-ko&quot;, 20))println(people.count(under25)) 술어를 만족하는 원소 하나를 찾고 싶으면, find 를 쓰자. 12val people = listOf(Person(&quot;jko&quot;, 30), Person(&quot;junhee-ko&quot;, 20))println(people.find(under25)) groupBy컬렉션의 모든 원소를 어떤 특성에 따라 여러 그룹으로 나눌 때는, groupBy 함수를 쓰자. 123456val people = listOf( Person(&quot;jko&quot;, 30), Person(&quot;son&quot;, 30), Person(&quot;junhee-ko&quot;, 20))println(people.groupBy { it.age }) flatMapflatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용한다. (map)그리고, 람다를 적용한 결과로 얻어지는 리스트를 한 리스트에 모은다. (flatten) 간단한 예를 보자. 12val strings = listOf(&quot;abc&quot;, &quot;def&quot;)println(strings.flatMap { it.toList() }) 다른 예를 보자. 1234567val books = listOf( Book(&quot;Kotlin&quot;, listOf(&quot;junheeko&quot;, &quot;jko&quot;)), Book(&quot;Java&quot;, listOf(&quot;junheeko&quot;, &quot;Chulsu&quot;)), Book(&quot;C++&quot;, listOf(&quot;BTS&quot;, &quot;PSY&quot;)),)println(books.flatMap { it.authors }.toSet()) // [junheeko, jko, Chulsu, BTS, PSY] with다음 코드를 보자. 12345678910fun alphabet(): String { val result = StringBuilder() for (letter in 'A'..'Z') { result.append(letter) } result.append(&quot;\\nThe End&quot;) return result.toString()} result 에 대해 다른 여러 메서드를 호출하면서 매번 반복 사용한다.이 예제를 개선해보자. 123456789101112fun alphabet(): String { val stringBuilder = StringBuilder() return with(stringBuilder) { // 수신 객체 지정 for (letter in 'A'..'Z') { stringBuilder.append(letter) } append(&quot;\\nThe End&quot;) this.toString() }} 위 with 문은 파라미터가 2개인 함수이다.첫 번째 파라미터는 stringBuilder, 두 번째 파라미터는 람다이다. with 함수는 첫 번째 인자로 받은 객체를, 두 번재 인자로 받은 람다의 수신 객체로 만든다.람다 본문 에서는, this 를 사용해서 수신 객체에 접근하거나 프로퍼티나 메서드 이름만 사용해도 수신 객체의 맴버에 접근 가능하다. 더 개선하면, 123456789fun alphabet() = with(StringBuilder()) { for (letter in 'A'..'Z') { append(letter) } append(&quot;\\nThe End&quot;) this.toString()} apply거의 with 과 같다.유일한 차이는, 항상 자신에게 전달된 객체 (수신 객체) 를 반환한다는 것 뿐이다. 1234567fun alphabet() = StringBuilder().apply { for (letter in 'A'..'Z') { append(letter) } append(&quot;\\nThe End&quot;)}.toString() apply 를 호출한 결과는 StringBuilder 객체다.그래서, 이 객체의 toString 을 호출해서 String 객체를 얻을 수 있다. 그런데, 표준 라이브러리의 buildString 함수를 사용하면 alphabet 함수를 더 단순화 할 수 있다.buildString 의 인자는 수신 객체 지정 람다이며, 수신 객체는 항상 StringBuilder 이다. 1234567fun alphabet() = buildString { for (letter in 'A'..'Z') { append(letter) } append(&quot;\\nThe End&quot;)} Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/15/kotlin-standard-library/"},{"title":"Spring Web Flux : Functional","text":"스프링캠프 2017 에서 Toby 님이 발표한 Spring Web Flux 의 다음 내용을 정리한다. 함수형 스타일의 WebFlux 가 웹 요청을 처리하는 방식 함수형 스타일의 WebFlux 장/단점 Spring 이 웹 요청을 처리하는 방식다음 순서로 진행된다. 요청 매핑웹 요청을 어느 handler 에게 보낼지 결정한다. MVC 에서는 @RequestMapping 을 이용한다. 요청 바인딩handler 에 전달할 웹 요청을 준비한다.(URL Path, Header, Cookie 정보를 가져옴, body 의 json 을 자바 오브젝트로 바인딩…) 핸들러 실행전달 받은 요청 정보를 이용해 로직을 수행한다. 핸들러 결과 처리handler 의 return 값으로 웹 응답으로 변환한다. 전통적인 방식의 다음 코드를 보자. 12345678@RestControllerclass MyController { @GetMapping(&quot;hello/{name}&quot;) fun hello(@PathVariable name: String): String { return &quot;Hello $name&quot; }} @GetMapping 을 통해 요청을 매핑하고, @PathVariable 을 통해 요청을 바인딩한다.그리고, return “Hello $name” 에서 핸들러를 실행하고 결과를 처리한다. 참고로, 기존에는 @RequestMapping 과 메서드 타입을 사용했는데, Spring 4.xx 에서 @GetMapping, @PostMapping.. 이 등장했다. 또한, @RestController 이므로 response body 에 문자열이 그대로 들어간다. 특별한 Content-Type 을 지정하지 않으면, text/plain 으로 지정된다. 함수형 WebFlux 가 웹 요청을 처리하는 방식다음 순서로 진행된다. 요청 매핑 : RouterFunction 요청 바인딩 : HandlerFunction 핸들러 실행 : HandlerFunction 핸들러 결과 처리 : HandlerFunction 요청 매핑에, RouterFunction 이라는 Functional Interface 가 사용된다.요청 바인딩, 핸들러 실행, 결과 처리에는 HandlerFunction 이 사용된다. RouterFunction 은 다음과 같이 정의되어 있다. 12345@FunctionalInterfacepublic interface RouterFunction&lt;T extends ServerResponse&gt; { Mono&lt;HandlerFunction&lt;T&gt;&gt; route(ServerRequest request);} Functional Interface 이기 때문에, 람다식으로 표현이 가능하다. route 메서드에서, ServerRequest 는 Webflux 의 웹 요청이고, Mono&lt;HandlerFunction&gt; 는 ServerResponse 를 리턴하는 HandlerFunction 이다. 결국 이 route 는, 서버 요청을 받아서 HandlerFunction 을 찾아준다.여기서 이 HandlerFunction 은 Controller 의 method 에 대응된다. 함수형 스타일로 변형아래 코드는 전통적인 @MVC 방식이다. 12345678@RestControllerclass MyController { @GetMapping(&quot;hello/{name}&quot;) fun hello(@PathVariable name: String): String { return &quot;Hello $name&quot; }} 이제 위 코드를, Webflux 함수형 스타일로 바꿔보자.함수 2개를 작성하면 된다. HandlerFunction RouterFunction HandlerFunctionHandlerFunction 을 먼저 작성해보자. 1234567val helloHandler: HandlerFunction&lt;*&gt; = HandlerFunction { request: ServerRequest -&gt; val name: String = request.pathVariable(&quot;name&quot;) val result: Mono&lt;String&gt; = Mono.just(&quot;Hello $name&quot;) val response: Mono&lt;ServerResponse&gt; = ServerResponse.ok().body(result, String::class.java) response} ServerRequest.pathVariable() 로 {name} 을 추출하고 로직 적용 후 결과 값을 모노에 담아, 웹 응답을 ServerResponse 의 Builder 를 활용해서 만든다. 그리고, Mono 에 단긴 ServerResponse 타입으로 리턴한다. 위 코드는 다음과 같이 개선 가능하다. 123val helloHandler = HandlerFunction { request -&gt; ok().body(fromObject(&quot;Hello ${request.pathVariable(&quot;name&quot;)}&quot;))} BodyInserters.fromObject() 의 도움을 받아 Mono 에 담고 있다. 위의 코드에서 볼 수 있듯이, 우리가 직접 request.pathVariable() 로 값을 꺼내오고 있다.@MVC 에서는 @PathVariable 이 붙어 있으면, 스프링이 관례에 따라 값을 넣어서 메스드를 호출해준다.우리가 직접 path 에서 값을 꺼내오는 코드를 만들지 않는다.함수형에서는 명시적으로 가져와야하는 코드가 필요하다. RouterFunctionRouterFunction 을 작성해보자. 123456val routerFunction: RouterFunction&lt;ServerResponse&gt; = RouterFunction { request: ServerRequest -&gt; if (RequestPredicates.path(&quot;hello/{name}&quot;).test(request)) Mono.just(helloHandler) else Mono.empty()} hello/{name} 과 호환되는 요청인지 테스트해보고 결과 true 이면,위에서 만든 helloHandler 를 Mono 넣어서 리턴하고 있다. HandlerFunction + RouterFunctionHandlerFunction 과 RouterFunction 을 조합할 수 있다. 123456val routerFunctionWithHandler: RouterFunction&lt;ServerResponse&gt; = RouterFunctions.route( RequestPredicates.path(&quot;hello/{name}&quot;), HandlerFunction { request: ServerRequest -&gt; ok().body(fromObject(&quot;Hello ${request.pathVariable(&quot;name&quot;)}&quot;)) }) RouterFunctions.route static method 의 첫 번째 파리미터에는, 매핑 조건을 체크한는 RequestPredicate 을 전달하고, 두 번재 파라미터에는, HandlerFunction 을 그대로 전달하고 있다. 위 코드는, 아래와 같이 조금 더 개선 가능하다. 123val routerFunctionWithHandler = RouterFunctions.route(RequestPredicates.path(&quot;hello/{name}&quot;)) { request -&gt; ok().body(fromObject(&quot;Hello ${request.pathVariable(&quot;name&quot;)}&quot;))} RouterFunction 등록그런데, 스프링 컨테이너는 요청이 들어왔을 때 RouterFunction 을 거쳐 HandlerFunction 을 어떻게 실행하게 할까 ?RouterFunction 을 @Bean 으로 등록하면 된다. 123456789101112@Configurationclass HelloRouter { @Bean fun route(): RouterFunction&lt;ServerResponse&gt; = RouterFunctions .route(RequestPredicates.path(&quot;hello/{name}&quot;)) { request -&gt; ServerResponse .ok() .body(BodyInserters.fromObject(&quot;Hello ${request.pathVariable(&quot;name&quot;)}&quot;)) }} handler 의 로직이 복잡하다면, 아래와 같이 handler 를 추출할 수 있다. 1234567891011121314@Configurationclass HelloRouter { @Bean fun route(): RouterFunction&lt;ServerResponse&gt; { // Here !! val helloHandler = HandlerFunction { request -&gt; ServerResponse.ok().body(BodyInserters.fromObject(&quot;Hello ${request.pathVariable(&quot;name&quot;)}&quot;)) } return RouterFunctions .route(RequestPredicates.path(&quot;hello/{name}&quot;), helloHandler) }} Handler 를 별개의 클래스로 정의하면 더 간결해질 수 있다. 123456789@Componentclass HelloHandler(val helloService: HelloService) { fun hello(request: ServerRequest): Mono&lt;ServerResponse&gt; { val res = helloService.hello(request.pathVariable(&quot;name&quot;)) return ok().body(fromObject(res)) }} 이렇게, HelloHandler 를 별개의 클래스로 정의하면,HelloHandler 클래스 안에 HandlerFunction 에 mapping 될 수 있는 메서드들을 정의할 수 있다. 그리고 이제, Router 에서는 정의한 Handler 를 호출한다. 12345678@Configurationclass HelloRouter { @Bean fun route(@Autowired helloHandler: HelloHandler): RouterFunction&lt;ServerResponse&gt; = RouterFunctions .route(path(&quot;hello/{name}&quot;), helloHandler::hello) // Here !!} RouterFunction 중첩하나의 Bean 에 n 개의 RouterFunction 선언이 가능하다.and(), andRoute() 를 사용하면 된다. 또한,RouterFunction.nest() 사용하면, @RequestMapping 처럼 공통의 조건을 정의할 수 있다. 아래 코드를 보자. 12345678910111213@Beanfun routeMany(@Autowired personHandler: PersonHandler): RouterFunction&lt;ServerResponse&gt; { return nest( path(&quot;/person&quot;), nest( accept(APPLICATION_JSON), route(GET(&quot;/{id}&quot;), personHandler::getPerson) // 1 .andRoute(method(HttpMethod.GET), personHandler::listPeople) //2 ).andRoute( POST(&quot;/&quot;).and(contentType(APPLICATION_JSON)), personHandler::createPerson // 3 ) )} 세 개의 HandlerFunction 을 매핑하고 있다. getPerson : /person prefix &amp;&amp; accept Header 가 APPLICATION_JSON &amp;&amp; /person/{id} listPeople : /person prefix &amp;&amp; accept Header 가 APPLICATION_JSON &amp;&amp; GET HTTP method createPerson: /person prefix &amp;&amp; POST HTTP Method &amp;&amp; content type 이 APPLICATION_JSON 함수형 스타일의 WebFlux 장/단점장점 정확한 타입 체크, 잘못된 코드 작성 오류 최소화기존 @MVC 에서는, @RequestMapping 같은 annotation 을 달아 선언에 따른 관례들이 조합이 되어서 바인딩되는 결과를 얻는다.함수형 스타일의 WebFlux 에서는, 모든 웹 요청 처리 작업을 명시적으로 코드로 작성한다.그래서, 정확한 타입 체크가 가능하고 관례를 혼동해서 작성되는 잘못된 코드 작성을 막는다. 추상화와 확장에 유리함수 형태로 메서드를 채이닝하기 때문에, 추상화하거나 프레임워크화가 가능하고, 확장에 유리하다. 테스트 작성 편리함기존 @MVC 에서는, return 되는 body 의 JSON 을 테스트하기 위해, 컨네이너를 띄어 사실상 통합 웹 테스트 발생한다. 그래서, 테스트하는데 시간이 오래 걸린다.반면, 함수형 스타일에서는 컨테이너를 띄우지 않고, handler 로직은 물론이고 요청 매핑과 리턴 값 처리까지 단위 테스트로 가능하다. 단점함수형 스타일의 코드 작성이 편하지 않으면, 코드 작성과 이해가 어렵다. https://www.youtube.com/watch?v=2E_1yb8iLKk&amp;t=443s","link":"/2021/08/22/spring-web-flux-functional/"},{"title":"Spring Web Flux : 소개","text":"스프링캠프 2017 에서 Toby 님이 발표한 Spring Web Flux 의 다음 내용을 정리한다. WebFlux 사용 이유 WebFlux 개발 방식 WebFlux 의 주요 특징 사용 이유Thread, CPU, Memory 등 자원을 낭비하지 않고 더 많은 요청을 처리할 수 있는 고성능 Web Application 을 만들 수 있다.이런 부분에서 효율성을 극대화할 수 있는 경우는, 서비스 간 호출이 많은 Microservice Architecture 가 있다. 개발 방식두 가지 개발 방식을 지원한다. 기존의 @MVC 방식 : @Controller, @RequestMapping 등 annotation 을 사용한다. 함수형 모델 : annotation 에 의지하지 않고, RouterFunction 과 HandlerFunction 를 사용한다. 주요 특징 Servlet 기반이 아니다. (서블릿 지원하는 컨테이너에서 동작할 수 있게 호환성은 가지고 있음) ServerRequest, ServerResponse 을 사용한다. (HTTP Request, Response 를 추상화한 새로운 모델) 지원하는 웹 서버 컨테이너 Tomcat, Jetty : 서블릿의 기존 동기-블로킹 방식을 사용하지 않고, 서블릿 3.1+ 의 비동기 논블로킹 요청 처리 방식을 이용한다. Netty, Undertow : 서블릿과 상관 없는 비동기-논블로킹 IO 웹 서버에서 동작한다. https://www.youtube.com/watch?v=2E_1yb8iLKk&amp;t=443s","link":"/2021/08/22/spring-web-flux-intro/"},{"title":"Spring Web Flux : @MVC","text":"스프링캠프 2017 에서 Toby 님이 발표한 Spring Web Flux 의 다음 내용을 정리한다. annotation 방식의 @MVC 와 유사한 WebFlux 개발 방법 @MVC WebFlux : 01annotation 방식의 @MVC 방식과 유사하면서비동기 + 논블러킹 리액티브 스타일의 코드 작성이 가능하다. 1234567@RestControllerclass MyController { @GetMapping(&quot;hello/{name}&quot;) fun hello(request: ServerRequest): Mono&lt;ServerResponse&gt; = ok().body(fromObject(request.pathVariable(&quot;name&quot;)))} 요청 정보가 미리 바인딩되지 않아, ServerRequest.pathVariable() 로 가져온다. 응답은, Mono 에 감싸진 ServerResponse 를 응답한다. 상태 코드와 바디를 명시적으로 선언한다. @MVC WebFlux : 02위 코드는, 더 이전 스타일로 표현 가능하다.가장 대표적인 @MVC WebFlux 작성 방식이다. 123@GetMapping(&quot;hello/{name}&quot;)fun hello(@PathVariable name: String): Mono&lt;String&gt; = Mono.just(&quot;Hello $name&quot;) 파라미터 바인딩을 MVC 방식 그대로 한다. 그리고, 핸들러 로직의 결과를 Mono/Flux 타입으로 리턴한다. 웹 요청의 바디를 받으려면, 123@GetMapping(&quot;hello/{name}&quot;)fun hello(@RequestBody user: User): Mono&lt;String&gt; = Mono.just(&quot;Hello ${user.name}&quot;) MVC 방식과 동일하게, 웹 요청의 바디를 MessageConverter 에서 바인딩한다. https://www.youtube.com/watch?v=2E_1yb8iLKk&amp;t=443s","link":"/2021/08/23/spring-web-flux-mvc/"},{"title":"Spring Web Flux : Reactive","text":"스프링캠프 2017 에서 Toby 님이 발표한 Spring Web Flux 의 다음 내용을 정리한다. WebFlux 를 사용하며 개선할 포인트 Data Access Repository Non Blocking API call Blocking IOWebFlux 를 사용하는데, 서비스 로직에서 Blocking IO 가 사용되는 코드가 많으면 성능이 오히려 나빠질 수 있다. 개선할 blocking IO 는 다음과 같은 것들이 있다. data access repository 를 호출 HTTP API 호출 기타 네트워크를 이용하는 서비스 JDBC 기반 RDB 연결JDBC API 는 아쉽게도, Blocking 메서드로 점철되었다.이 부분을 다음과 같이 개선해서, 서블릿 스레드를 점유하지 않도록 만들 수 있다. @Async 비동기를 적용해서, CompletableFuture 리턴하게 하여 서블릿 스레드만 빨리 스레드풀에 리턴하게 함으로써 가용한 자원으로 만들 수 있다. 예를 들어,repository 의 메서드에 다음과 같이 @Async 를 붙인다. 12@Asyncfun findOneByFirstname(firstname: String): CompletableFuture&lt;User&gt; 위 메서드를 호출하는 쪽에서는, 12fun findUser(name: String): Mono&lt;User&gt; = Mono.fromCompletionStage(userRepository.findOneByFirstname(name)) Reactive Data Access 기술Spring Data 2.0 부터 추가된 다음 기술을 통해서,DB access 하는 코드를 완벽하게 Non blocking 으로 만들 수 있다. ReactiveCrudRepository 확장 Spring Data 의 Reactive Repository 이용 (MongoDB, Casandra, Redis…) 123456interface ReactivePersonRepository : ReactiveCrudRepository&lt;Person, String&gt; { fun findByLastname(lastname: Mono&lt;String&gt;): Flux&lt;Person&gt; @Query(&quot;{ 'firstname': ?0, 'lastname': ?1}&quot;) fun findByFirstnameAndLastname(firstname: String, lastname: String): Mono&lt;Person&gt;} WebClientNon Blocking API Call 은 WebClient 를 이용하면 된다.WebClient 는 AsyncRestTemplate 의 Reactive version 이다.요청을 Mono/Flux 로 전달할 수 있고, 응답을 Mono/Flux 형태로 가져온다. 다음 코드를 보자. 12345678910@GetMapping(&quot;hello/webclient&quot;)fun helloWithWebClient(): Mono&lt;String&gt; = WebClient.create(&quot;http://localhost:8080&quot;) .get() .uri(&quot;/hello/{name}&quot;, &quot;Spring&quot;) .accept(MediaType.TEXT_PLAIN) .exchange() .flatMap { it.bodyToMono(String::class.java) } .map { it.toUpperCase() } .flatMap { userRepository.save(it) } 위 코드는, 요청을 받아 API 호출을 한 뒤에, 그 결과를 대문자로 바꿔서 DB 에 저장하고 리턴한다. 그리고, exchange 는 요청을 응답으로 바꾸는 메서드이다.즉, 서버에 실제적으로 API 호출을 하고 그 결과를 받아와 리턴한다. 성능 향상Async + Non blocking 리팩티브 웹 애플리케이션의 효과를 얻으려면 코드에서 blocking 이 발생하지 않도록 한다.Flux or Mono 에 데이터를 넣어서 전달하면 된다. WebFlux 와 다음 기술들을 결합하여 사용한다Reactive Repository, Reactive 원격 API 호출, Reactive 지원 외부 서비스, @Async Blocking IO https://www.youtube.com/watch?v=2E_1yb8iLKk&amp;t=443s","link":"/2021/08/24/spring-web-flux-reactive/"},{"title":"GraphQL Query","text":"GraphQL Query 를 어떻게 작성하는지 정리한다. QueryQuery 로 API 에 데이터를 요청할 수 있다.Query 안에는 서버로부터 받고 싶은 데이터를 필드로 넣는다. https://snowtooth.moonhighway.com 에 접속해서, 아래 Query 를 실행해보자. 123456query { allLifts{ name status }} 응답되는 JSON 에는 아래와 같이,allLifts 배열과 각 Lift 에 대한 name 과 status 가 있다. query root typequery 는 GraphQL 의 타입 중 루트 타입이다.타입 하나는 하나의 작업을 수행하는데, query 는 쿼리 문서의 루트를 의미하기 때문이다.query 에 사용할 수 있는 필드는 API 스키마에 정의한다.사용할 수 있는 필드는 아래와 같이 liftCount, allLifts, allTrains 등이 있다. Selection Set쿼리를 작성할 때는 필요한 필드를 중괄호로 감싸야한다.이 중괄호로 묶인 블록을 Selection Set 라고 부른다. liftCount, allLifts, allTrains 필드는 모두 Query 안에 정의된 필드이다.selection set 는 서로 중첩시킬 수 있다.allLifts 필드는 Lift 타입 리스트를 반환하므로, Lift 타입에 대한 새로운 selection set 를 만들기 위해 중괄호를 사용해야한다. Alias응답 객체의 필드명을 다르게 받고 싶으면, 쿼리 안의 필드명에 별칭을 부여하면 된다. 123456query { myAll: allLifts{ name status }} 결과는 아래와 같다. Filtering쿼리 결과에 대한 필터링을 하고 싶으면, query arguments 를 전달하면 된다. 123456query { allLifts(status:CLOSED){ name status }} 데이터를 특정하고 싶으면, 1234567query { Lift(id : &quot;jazz-cat&quot;){ name status night }} Filter Type필드는 다음 두 타입 중에 하나이다. 스칼라 타입 객체 타입 Scalar Type스칼라 타입에는 다음 다섯 가지가 있다. 정수(Int) 실수(Float) 문자열(String) 불(Boolean) 고유 식별자 (ID) 정수와 실수 타입은, JSON 숫자 타입 데이터를 응답하고문자열과 ID 타입은, JSON 문자열 타입 데이터를 응답한다.특히, ID 타입은 항상 유일한 문자열을 응답하도록 되어 있다. Object Type객체 타입은 스키마에 정의한 필드를 그룹으로 묶어둔 것이다. Example특정 리프트에서 접근할 수 있는 코스 목록을 조회해보자. 123456789query { Lift(id : &quot;jazz-cat&quot;){ capacity trailAccess { name difficulty } }} selection set 의 capacity 는, 스칼라 타입 데이터이다.selection set 의 trailAccess 는, 객체 타입 (Trail 타입) 이다. FragmentFragment 는 selection set 의 일종이다.여러 번 재사용할 수 있다. 다음 쿼리를 보자. 123456789101112131415161718192021222324query { Lift(id : &quot;jazz-cat&quot;){ name status night capacity trailAccess { name difficulty } } Trail(id: &quot;river-run&quot;){ name difficulty accessedByLifts { name status capacity night elevationGain } }} Lift selection set 와 accessedByLifts 필드의 selection set 에는, 다음 필드들이 있다. name status night capacity 이런 경우에 아래와 같이,프래그먼트로 쿼리에서 중복된 부분을 줄일 수 있다. 1234567891011121314151617181920212223242526fragment liftInfo on Lift{ name status night capacity elevationGain}query { Lift(id : &quot;jazz-cat&quot;){ ...liftInfo trailAccess { name difficulty } } Trail(id: &quot;river-run&quot;){ name difficulty accessedByLifts { ...liftInfo } }} liftInfo 라는 이름을 붙인 프래그먼트는, Lift 타입에 대한 selection set 이다. Union Type타입 여러개를 한 번에 리스트에 담아 반환하고 싶으면, union type 을 사용해라. AgendaItem 이라는 유니언 타입이 있다.AgendaItem 은 Workout or StudyGroup 타입을 반환한다.이 때, 프래그먼트를 사용하면 AgendaItem 이 Workout 일 때와 StudyGroup 일 때 특정 필드만 선택되도록 할수 있다. 12345678910111213query schedule{ agenda { ...on Workout{ name reps } ...on StudyGroup{ name subject students } }} 여기서의 프래그먼트를 인라인 프래그먼트라고 한다.인라인 프래그먼트는 프래그먼트와 다르게 이름이 없다. 물론 아래와 같이 이름이 붙은 프래그먼트로도 쿼리를 작성할 수 있다. 1234567891011121314151617query schedule{ agenda { ...workout ...study }}fragment workout on Workout{ name reps}fragment study on StudyGroup{ name subject students} Interface인터페이스는 필드 하나로 객체 타입을 여러 개 반환할 때 사용한다.추상적인 타입이며, 유사한 객체 타입을 만들 때 구현해야하는 필드 리스트를 모아둔 것이다. agenda 필드가 ScheduleItem 인터페이스를 반환한다고 하자.ScheduleItem 인터페이스에는 name, start, end 필드가 정의되어있다.Workout 과 StudyGroup 이 이 인터페이스를 구현했다면, 두 타입 모두 name, start, end 필드를 가져야한다. 아래 query 를 보자. 12345678910query schedule{ agenda { name start end ...on Workout{ reps } }} 프래그먼트를 사용하면 특정 객체 타입이 반환될 때, 필드가 더 들어갈 수 있게 작성할 수 있다. 웹 앱 API 개발을 위한 GraphQL &lt;이브 포셀로, 알렉스 뱅크스&gt;","link":"/2021/08/25/graphql-query/"},{"title":"Null","text":"코틀린에서 null 을 어떻게 처리하는지 정리한다. nullabilitynullability (널 가능성) 은, NPE 를 피할 수 있도록 돕기 위한 코틀린 타입 시스템의 특성이다.널이 될 수 있는지의 여부를 타입 시스템에 추가해서,컴파일러가 오류를 미리 감지해 실행 시점에 발생할 수 있는 가능성을 줄인다. 널이 될 수 있는 타입다음 자바 함수를 보자. 123int stringLength(String s) { return s.length();} 이 함수의 파라미터로 null 을 전달하면, NPE 가 발생한다.이 함수를 코틀린으로 작성하면, 1fun stringLength(s: String) = s.length 이 함수의 파라미터로 null 을 전달하면, 컴파일 시 오류가 발생한다.그래서, 실행 시점에 NPE 가 발생하지 않는다고 확신할 수 있다. 만약 위 함수가 널과 문자열을 받을 수 있게 하려면, ? 를 명시해야한다. 1fun stringLength(s: String?) = ... 연산 제한널이 될 수 있는 타입의 변수이면, 수행할 수 있는 연산이 제한된다.예를 들어, “변수.메서드()” 처럼 메서드를 직접 호출하면 컴파일 에러가 발생한다. 1fun stringLength(s: String?) = s.length 아래 처럼, null 검사를 추가하면 컴파일에 성공한다. 1234567fun stringLength(s: String?): Int { if (s != null) { return s.length } else { return 0 }} 그런데, 이렇게 널 가능성을 체크하기 위해 if 를 통해 검사를 해야한다면, 코드가 번잡해질 것이다.그래서 코를린은 널을 다룰 수 있는 여러 도구를 제공한다. ?.?. 는 널 검사와 메서드 호출을 한 번의 연산으로 수행한다.아래의 코드는, 12345if (s ! = null) { s.toUpperCase()} else { null} 이것과 같다. 1s?.toUpperCase() 주의할 점은, ?. 의 결과 타입도 널이 될 수 있다.다음을 보자. 1234fun printAllCaps(s: String?) { val allCaps: String? = s?.toUpperCase() println(allCaps)} allCaps 는 null 일 수 있다. ?:널 대신 사용할 디폴트 값을 지정할 때, 엘비스 연산자 (?:) 를 사용하면 된다. 123fun foo(s: String?) { val t: String = s ?: &quot;&quot;} s 가 null 이면 결과는 “” 이다. 다른 예제를 보자. 12345678910111213class Address(val street: String, val zipCode: Int, val city: String)class Company(val name: String, val address: Address?)class Person(val name: String, val company: Company?)fun printShippingLabel(person: Person) { val address = person.company?.address ?: throw IllegalArgumentException(&quot;No Address&quot;) with(address) { println(street) println(&quot;$zipCode $city&quot;) }} address 가 null 이면 예외를 던진다. as?as? 연산자는 어떤 값을 지정한 타입으로 cast 한다.cast 할 수 없으면 null 을 반환한다. 아래 코드를 보자. 12345678910111213141516class Person(val firstName: String, val lastName: String){ override fun equals(o: Any?): Boolean { val otherPerson = o as? Person ?: return false // 안전한 캐스트 이후엔, otherPerson 이 Person 타입으로 스마트 캐스트됨 return otherPerson.firstName == firstName &amp;&amp; otherPerson.lastName == lastName } override fun hashCode(): Int { var result = firstName.hashCode() result = 31 * result + lastName.hashCode() return result }} equals 메서드에서, 타입이 서로 일치하지 않으면 false 를 반환한다. !!!! (not-null assertion) 는, 어떤 값이든 널이 될 수 없는 타입으로 바꾼다. 1234fun ignoreNulls(s: String?) { val notNullString = s!! println(notNullString.length)} 만약에 s 가 null 이면, 예외가 발생한다.주의할 점은, notNullString.length 에서 발생하는 것이 아니라, val notNullString = s!! 에서 발생한다. !! 를 한 줄에 쓰지 말자. 예외 stack trace 에서 파일의 몇 번째 줄인지는 알 수 있지만, 어떤 식에서 예외가 발생했는지는 알 수 없기 때문이다. 1perosn.company!!.address!!.country // 이렇게 한줄에 쓰지 말자 let다음 함수를 보자. 1fun sendEmailTo(email: String){} 위 함수에는 널이 될 수 있는 타입의 값을 넘길 수 없다.그래서 아래와 같이, 파라미터를 넘기기 전에 값이 널인지 검사해야한다. 1234val email: String? = ...if (email != null) { sendEmailTo(email)} 이럴 때 let 함수를 사용할 수 있다.let 함수는 자신의 수신 객체를 인자로 전달받은 람다에 넘긴다.아래와 같이 사용할 수 있다. 1email?.let{email -&gt; sendEmailTo(email)} it 을 사용하면 더 줄일 수 있다. 1email?.let{ sendEmailTo(it)} lateinit 변경자코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야한다. 프로퍼티 타입이 널이 될 수 없는 타입이라면, 반드시 널이 아닌 값으로 초기화해야한다. 다음 코드를 보자. 1234567891011121314151617class MyService { fun action(): String = &quot;foo&quot;}class MyTest { private var myService: MyService? = null @Before fun setUp() { myService = MyService() } @Test fun testAction() { Assert.assertEquals(&quot;foo&quot;, myService!!.action()) }} myService 를 null 로 초기화하기 위해, 널이 될 수 있는 타입으로 선언했다.testAction() 에서는 널 가능성을 신경써서 !! 를 사용했다.myService 를 계속 사용해야한다면, !! 를 계속 사용해야한다. MyTest 클래스를 개선해보자.프로퍼티에 lateinit 변경자를 붙이면, 프로퍼티를 나중에 초기화할 수 있도록 만들 수 있다. 12345678910111213class MyTest { private lateinit var myService: MyService @Before fun setUp() { myService = MyService() } @Test fun testAction() { Assert.assertEquals(&quot;foo&quot;, myService.action()) }} myService 프로퍼티를 초기화하지 않고 널이 될 수 없는 프로퍼티로 선언했다.testAction() 에서는 더 이상 !! 를 사용하지 않는다. val 프로퍼티는 final 필드로 컴파일되며, 생성자 안에서 반드시 초기화해야한다.그래서, 생성자 밖에서 초기화하는 나중에 초기화하는 프로퍼티는 항상 var 이어야한다. 널이 될 수 있는 타입 확장null 이 될 수 있는 수신 객체에 대해 확장 함수를 호출할 수 있다.String? 타입의 수신 객체애 대해 호출 가능한 isNullOrEmpty 와 isNullOrBlank 메서드가 있다. 다음 코드를 보자. 12345fun verifyInput(input: String?) { if (input.isNullOrBlank()) { println(&quot;null or blank&quot;) }} 여기서, input 은 널이 될 수 있는 타입의 값이다.여기서, isNullOrBlank 은 널이 될 수 있는 타입의 확장 함수이다. isNullOrBlank 함수를 자세히 봐보자. 1234567public inline fun CharSequence?.isNullOrBlank(): Boolean { contract { returns(false) implies (this@isNullOrBlank != null) } return this == null || this.isBlank()} this 가 널이 될 수 있다는 것을 알 수 있다.코틀린에서는, 널이 될 수 있는 타입의 확장 함수 안에서는 this 가 널이 될 수 있다.자바에서는, 메서드 안의 this 는 메스드가 호출된 수신 객체이므로 널이 될 수 없다. 플랫폼 타입플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입이다.널이 될 수 있는 타입으로 처리해도 되고, 널이 될 수 없는 타입으로 처리해도 된다.코틀린에서 플랫폼 타입을 선언할 수 없고, 자바 코드에서 가져온 타입만 플랫폼 타입이 될 수 있다. 다음 자바 코드를 보자. 1234567891011public class MyPerson { private final String name; public MyPerson(String name) { this.name = name; } public String getName() { return name; }} getName() 은 null 을 리턴할까 안할까 ?코틀린 컴파일러는 이 경우, String 타입의 널 가능성에 대해 모른다.그래서, 우리가 직접 처리해야한다.만약, 아래의 yellAt 함수에 null 을 인자로 전달한다면, 예외가 발생한다. 123fun yellAt(person: MyPerson){ println(person.name.uppercase())} 플랫폼 타입은 아래 두 선언이 모두 가능하다. 12val s1: String ? = person.nameval s2: String = person.name 자바에서 가져온 널 값을 널이 될 수 없는 코틀린 변수에 대입하면, 실행 시점에 대입 될 때 예외가 발생한다.자바 API 를 다룰 때는 문서를 잘 보고 사용하자. Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/08/25/kotlin-null/"},{"title":"GraphQL 소개","text":"GraphQL 이 무엇이고, REST 와의 차이는 무엇인지 정리한다. GraphQL 이란GraphQL 은, API 를 만들 때 사용할 수 있는 쿼리 언어이자, 쿼리에 대한 데이터를 받을 수 있는 server-side 런타임이다. GraphQL 은 선언형 데이터 패칭 언어라고 불린다.무엇이 필요한지에 대한 요구사항만 작성하면 되고, 어떻게 가져올지는 신경쓰지 않아도 된다. 이에 대한 이해를 하기 위해, GraphQL 쿼리문과 응답 테스트를 여기서 해보자.쿼리문을 보내고 데이터를 받을 수 있다.https://graphql.github.io/swapi-graphql/ 다음과 같이 입력하고 실행해보자. 1234567query{ person(personID: 5){ name birthYear created }} 아래에서,왼쪽이 쿼리문이고 오른쪽이 쿼리문에 대한 응답 데이터이다. 응답 데이터의 형태가 쿼리문과 일치하며, 필요한 데이터만 들어있다.쿼리문을 아래와 같이, 변경해보자. 123456789101112query{ person(personID: 5){ name birthYear created filmConnection{ films { title } } }} 결과는 아래와 같다. 클라이언트 입장에서 GraphQL 을 사용하면, 쿼리문을 중첨함으로써, 연관된 객체를 응답 데이터로 같이 받을 수 있다. 복수의 객체 데이터를 받기 위해 요청을 여러번 반복할 필요가 없다. 원치 않은 데이터가 포함되어 있으면 제외할 수 있다. 서버에서는, 쿼리가 실행될 때마다, 타입 시스템을 기반으로 쿼리가 유효한지 검사한다. 또한, GraphQL 스키마에 사용할 타입을 정의해야한다. 위에서의 person 쿼리는 다음 Person 객체를 바탕으로 작성된 것이다. 123456789type Person { id: ID! name: String birthYear: String gender: String hairColor: String height: Int ...} REST 와의 비교오버패칭REST 버전으로 테스트하기 위해, 여기에서 응답 JSON 을 확인해보자. https://swapi.dev/api/people/1 실제 클라이언트가 필요한 데이터는 이름, 신장, 몸무게가 전부인데불필요한 데이터까지 함께 응답받는다. 이것이, over-fetching 의 사례이다.필요하지 않은 데이터를 많이 받는 것이다. GraphQL 에서는,필요한 데이터만 응답 받을 수 있다. 1234567query{ person(personID: 1){ name height mass }} 결과는, 아래와 같이 필요한 데이터만 담겨 있다. 언더패칭아래의 응답에서 모든 영화 제목을 얻으려면 films 배열에 담긴 각각의 라우트에서 데이터를 가져와야한다. https://swapi.dev/api/people/1 123456&quot;films&quot;: [ &quot;https://swapi.dev/api/films/1/&quot;, &quot;https://swapi.dev/api/films/2/&quot;, &quot;https://swapi.dev/api/films/3/&quot;, &quot;https://swapi.dev/api/films/6/&quot;] 즉, 추가 데이터를 또 요청해야하는 상황이다.이것을 under-fetching 되었다고 한다. GraphQL 에서는,쿼리를 중첩함으로써 페치 한번에 필요한 모든 데이터를 응답받을 수 있다. 123456789101112query{ person(personID: 1){ name height mass filmConnection { films { title } } }} 아래와 같이 필요한 데이터를 모두 받아왔다. 앤드포인트 관리클라이언트의 변경 사항이 생기면, 보통 앤드포인트를 새로 만들어야한다.이렇게 되면, 앤드포인트의 개수가 갈수록 늘어나게 된다. GraphQL 을 사용하면, 앤드포인트가 보통 하나로 끝난다.단일 앤드포인트가 게이트웨이 역할을 하게 되는 것이다. 웹 앱 API 개발을 위한 GraphQL &lt;이브 포셀로, 알렉스 뱅크스&gt;","link":"/2021/08/25/graphql-intro/"},{"title":"Primitive Type","text":"코틀린의 원시 타입을 정리한다. 원시 타입 : Int, Boolean …자바에서는 원시 타입과 참조 타입을 구분한다.원시 타입의 변수에는 그 값이 들어가고, 참조 타입의 변수에는 메모리상의 객체 위치가 들어간다. 코틀린에서는 원시 타입과 참조 타입을 구분하지 않는다.아래 코드에서는, 정수를 표현하기 위해 Int 를 사용한다. 12val i: Int = 1val list: List&lt;Int&gt; = listOf(1, 2, 3) 그리고, 코틀린에서는 아래처럼 원시 타입의 값에 대해 메서드 호출이 가능하다. 1234fun showProgress(progress: Int){ val percent = progress.coerceIn(0, 100) println(&quot;progress : $percent&quot;)} 그런데, 원시 타입과 참조 타입 같으면 항상 객체로 표현되는 걸까? 아니다.실행 시점에 가장 효츌적인 방식으로 표현된다.예를 들어, 대부분의 경우 코틀린의 Int 타입은 자바 int 타입으로 컴파일 된다. 널이 될 수 있는 원시 타입 : Int?, Boolean? …자바에서는, null 참조를 참조 타입의 변수에만 대입할 수 있다.그래서, 코틀린에서 널이 될 수 있는 원시 타입을 사용하면 자바의 래퍼타입으로 컴파일 된다.아레 예제에서, age 프로퍼티의 값은 java.lang.Integer 로 저장된다. 12345678910data class Person(val name: String, val age: Int? = null) { fun isOrderThan(other: Person): Boolean? { if (age == null || other.age == null) { return null } return age &gt; other.age }} 숫자 변환코틀린은 한 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다.다음 코드는 컴파일 에러가 발생한다. 12val i = 1val l : Long = i 아래와 같이 직접 변환 메서드를 호출해야한다. 12val i = 1val l : Long = i.toLong() Any : 최상위 타입자바에서는 Object 가 클래스 계층의 최상위 타입이다.코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 최상위 타입이다.널을 포함하는 모든 값을 대입할 변수를 선언하려면 Any? 타입을 사용해라. 코틀린 함수가 Any 를 사용하면 자바 바이트코드의 Object 로 컴파일된다. 모든 코틀린 클래스에는 toString, equals, hashCode 라는 세 메서드가 들어있다.이 세 메서드는 Any 에 정의된 메서드를 상속한 것이다. Unit : 코틀린의 void코틀린 Unit 타입은 자바 void 와 같은 기능을 한다.아래 두 함수는 같다. 12345fun f(): Unit {}fun f() {} 그러면, Unit 이 자바의 void 와 다른 점이 무엇일까 ?void 와 달리 Unit 을 타입 인자로 사용 가능하다.다음 예를 보자. 1234567891011interface Processor&lt;T&gt; { fun process(): T}class NoResultProcessor : Processor&lt;Unit&gt; { override fun process() { // 명시적으로 Unit 반환할 필요 없음 // 컴파일러가 묵시적으로 return Unit 넣어줌 }} Processor 인터페이스는 process 함수가 어떤 값을 반환하라고 정의되어 있지만,Unit 타입도 Unit 값을 제공하기 때문에 메서드에서 Unit 값을 반환해도 된다. 자바에서도 java.lang.Void 타입을 사용하면 “값 없음” 을 표현할 수 있다.하지만 그래도, Void 타입에 대응하는 유일한 값인 null 을 반환하기 위해, return null 을 해야한다. Nothing : 함수 비정상 종료함수가 정상적으로 끝나지 않는다는 사실을 표현하기 위해, Nothing 이라는 반환 타입이 있다. 테스트 라이브러리들은 fail 이라는 함수를 제공하는 경우가 많다.fail 은 특별한 메세지가 들어있는 예외를 던져 현재 테스트를 실패시킨다. 123fun fail(message: String): Nothing { throw IllegalArgumentException(message)} Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/09/12/kotlin-primitive-type/"},{"title":"컬렉션과 배열","text":"코틀린의 컬렉션과 자바의 컬렉션 간의 관계에 대해 정리한다. 널 가능성과 컬렉션타입 인자로 쓰인 타입에 ? 표시를 붙이면 널을 저장할 수 있다.아래 예제에서는, List&lt;Int?&gt; 는 Int 나 null 을 저장할 수 있다. 123456789101112131415fun readNumbers(reader: BufferedReader): List&lt;Int?&gt; { val result = ArrayList&lt;Int?&gt;() for (line in reader.lineSequence()) { try { val number = line.toInt() result.add(number) } catch (e: NumberFormatException) { result.add(null) } } return result} “어떤 변수 타입의 널 가능성” 과 “타입 파라미터로 쓰인 타입의 널 가능성” 은 차이가 있다.예를 들어, List&lt;Int?&gt; : 리스트 안의 각 값이 널이 될 수 잇다. List? : 전체 리스트가 널이 될 수 있다. 읽기 전용과 변경 가능한 컬렉션코틀린 컬렉션과 자바 컬렉션의 중요한 차이 중 하나는,코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 변경하는 인터페이스가 분리되었다는 점이다. kotlin.collections.Collection : 컬렉션 안의 데이터에 접근 kotlin.collections.MutableCollection : 데이터 변경 (kotlin.collections.Collection 를 확장) 아래 코드에서, target 에 해당하는 인자로 읽기 전용 컬랙션을 넘길 수 없다. 12345fun &lt;T&gt; copyElements(source: Collection&lt;T&gt;, target: MutableCollection&lt;T&gt;) { for (item in source) { target.add(item) }} 코를린 컬렉션과 자바자바는 읽기 전용 컬렉션과 변경 가능 컬렉션을 구분하지 않는다.그래서, 코틀린에서 읽기 전용 컬렉션으로 선언된 객체여도 자바에서는 그 컬렉션의 내용을 변경할 수 있다. 다음은, 자바 코드이다. 123456789public class CollectionUtils { public static List&lt;String&gt; uppercaseAll(List&lt;String&gt; items) { for (int i = 0; i &lt; items.size(); i++) { items.set(i, items.get(i).toUpperCase()); } return items; }} 다음은, 위 자바 코드를 호출하는 코틀린 코드이다. 1234fun printlnUppercase(list: List&lt;String&gt;) { println(CollectionUtils.uppercaseAll(list)) println(list.first())} 읽기 전용 list 임에도 불구하고, 컬렉션을 변경하는 자바 함수를 호출하면 컬렉션이 변경이 된다. 배열코틀린 배열은 타입 파라미터를 받는 클래스이다.배열의 원소 타입은 타입 파라미터에 의해 정해진다. 배열은 생성하는 다음 예제를 보자. 1val letters = Array&lt;String&gt;(26){i -&gt; ('a'+i).toString()} 람다는 배열의 인덱스를 인자로 받아, 해당 위치에 들어갈 원소를 반환한다. 코틀린은 원시 타입의 배열을 표현하는 별도 클래스를, 각 원시 타입마다 제공한다.( IntArray, ByteArray, CharArray, BooleanArray… )이 모든 타입은 자바 원시 타입 배열인 int[], byte[], char[] 로 컴파일된다. 12val fiveZeros1 = IntArray(5)val fiveZeros2 = intArrayOf(0, 0, 0, 0, 0) Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/09/13/kotlin-collection/"},{"title":"Convention","text":"코틀린의 관례에 대해 다음 순으로, 정리한다. 산술 연산자 비교 연산자 컬렉션, 범위 구조 분해 선언 관례란, 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법이다. 산술 연산자 오버로딩자바에서는, 원시 타입에 대해서 산술 연산자를 사용할 수 있으며 String 에 대해 + 연산자를 사용할 수 있다. 코틀린에서는, 다른 클래스에도 산술 연산자를 사용할 수 있다. 이항 산술 연산 오버로딩연산자를 오버로딩하는 함수 앞에는 operator 키워드가 붙어야한다.다음을 보자. 12345678910111213fun main() { val p1 = Point(10, 20) val p2 = Point(30, 40) println(p1 + p2)}data class Point(val x: Int, val y: Int) { operator fun plus(other: Point): Point { return Point(x + other.x, y + other.y) }} 실행 결과는 다음과 같다. 1Point(x=40, y=60) 연산자를 멤버 함수로 만드는 대신, 확장 함수로 정의할 수 있다.외부 함수의 클래스에 대한 연산자를 정의할 때는,관례를 따르는 이름의 확장 함수로 구현하는 것이 일반적인 패턴이다. 123operator fun Point.plus(other: Point): Point { return Point(x + other.x, y + other.y)} 복합 대입 연산 오버로딩plus 같은 연산자를 오버로딩 하면, +=, -= 등의 복합 대입 연산자도 같이 지원한다.다음을 보자. 12var point = Point(1,2)point += Point(3,4) 단항 연산자 오버로딩12345operator fun BigDecimal.inc() = this + BigDecimal.ONEvar number = BigDecimal.ZEROprintln(number++) // 0println(++number) // 2 비교 연산자 오버로딩산술 연산자와 마찬가지로, 원시 타입 값 뿐만 아니라 모든 객체에 대해 비교 연산을 수행할 수 있다. 동등성 연산자 : equals동등성 검사는 equals 호출과 null 검사로 컴파일 된다.즉, 1a == b 는 아래와 같이 컴파일 된다. 1a?.equals(b) ?: (b == null) data class 의 경우에, 컴파일러가 자동으로 equals 메서드를 생성해준다.직접 구현하면 다음과 같다. 12345678data class Point(val x: Int, val y: Int){ override fun equals(other: Any?): Boolean { if (this === other) return true if (other !is Point) return false return other.x == x &amp;&amp; other.y == y }} 위 equals 메서드에 대해 정리해보자. override 다른 연산자 오버로딩 관례와 달리, equals 는 Any 에 정의된 메서드라서 override 를 붙여야한다. operator 키워드를 붙이지 않아도, 상위 클래스의 operator 지정이 적용된다. === 자바의 == 와 같다. 두 피연산자가 서로 같은 객체를 가리키는지 비교한다. is 타입을 검사한다. Point 로 스마트 캐스트 된 뒤에, x 와 y 의 프로퍼티에 접근하고 있다. 순서 연산자 : compareTo자바에서 정렬이나, 최대값과 최소값을 비교하려면 Comparable 인터페이스를 구현해야한다.Comparable 의 compareTo 메서드는 한 객체와 다른 객체의 크기를 비교해 정수로 나타낸다.아래와 같이. 1element1.compareTo(element2) 코틀린에서도 같은 Comparable 인터페이스를 지원한다.자바와 다른 점은, compareTo 메서드를 호출하는 관례를 제공한다. 즉, 다음 코드는 1a &gt;= b 아래와 같이 컴파일 된다. 1a.compareTo(b) &gt;= 0 다음 예를 보자. 1234567891011121314class Person( private val firstName: String, private val lastName: String) : Comparable&lt;Person&gt; { override fun compareTo(other: Person): Int { return compareValuesBy( this, other, Person::lastName, Person::firstName ) }} equals 와 마찬가지로, Comparable 의 compareTo 에도 operator 변경자가 붙어 있어서하위 클래스의 오버라이딩 함수에 operator 를 붙이지 않아도 된다. 컬렉션과 범위에 쓸 수 있는 관례인덱스로 원소에 접근 : get, set각괄호를 사용한 접근은 get 함수 호출로 컴파일된다. 1234567891011operator fun Point.get(index: Int): Int { return when(index){ 0 -&gt; x 1 -&gt; y else -&gt; throw IndexOutOfBoundsException() }}val point = Point(3, 4)println(point[0])println(point[1]) 각 괄호를 사용한 대입문은 set 함수 호출로 컴파일 된다. 12345678910111213data class MutablePoint(var x: Int, var y: Int)operator fun MutablePoint.set(index: Int, value: Int) { return when(index){ 0 -&gt; x = value 1 -&gt; y = value else -&gt; throw IndexOutOfBoundsException() }}val mutablePoint = MutablePoint(1, 2)mutablePoint[0] = 5mutablePoint[1] = 6 inin 연산자는 contains 함수 호출로 변환된다. 12val numbers = listOf(1, 2, 3)println(1 in numbers) 위의 경우,Collection interface 에 다음과 같이 정의되어 있기 때문에, contains 함수 호출로 변환되는 것이다. 1public operator fun contains(element: @UnsafeVariance E): Boolean rageTo.. 연산자는 rageTo 함수 호출로 변환된다. iteratorfor loop 는 범위 검사와 똑같이, in 연산자를 사용한다.하지만 의미는 다르다. 1for (x in list) {...} 위 코드는, list.iterator() 를 호출해서 이터레이션을 얻는다. 그리고, 이터레이션에 대해 hasNext 와 next 호출을 반복한다. 구조 분해 선언 (Destructing Declaration)구조분해 선언은 componentN 함수 호출로 변환된다.다음 코드는, 1val (a, b) = p 아래와 같이 컴파일된다. 12val a = p.component1()val b = p.component2() 그래서 아래와 같은 코드가 가능한 것이다. 1234val p = Point(3, 5)val (x, y) = pprintln(x)println(y) 다음 예를 보자. 12345fun print(map: Map&lt;String, String&gt;) { for ((key, value) in map) { println(&quot;$key -&gt; $value&quot;) }} 위 코드에서는 두 가지 관례가 사용되었다. 이터레이션표준 라이브러리에 맵에 대한 확장 함수로 iterator 가 있다.iterator 는 맵 원소에 대한 이터레이터를 반환한다. 구조 분해 선언Map.Entry 에 대한 확장 함수로 component1 과 component2 를 제공한다. 즉, 1234567fun print(map: Map&lt;String, String&gt;) { for (entry in map.entries) { val key = entry.component1() val value = entry.component2() println(&quot;$key -&gt; $value&quot;) }} Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/09/18/kotlin-convention/"},{"title":"고차함수","text":"코틀린의 고차 함수에 대해 정리한다. 고차 함수고차 함수란, “다른 함수를 인자로 받거나 반환하는 함수” 이다. 그런데 코틀린에서는, 람다나 함수 참조를 사용해서 함수를 값으로 표현할 수 있다.그래서, “람다나 함수 참조를 인자로 반거나 반환하는 함수” 도 고차 함수이다. 예를 들어, 표준 라이브러리에 있는 함수인 filter 는 고차 함수이다.filter 는 술어 함수를 인자로 받는 함수이기 때문이다. 12val numbers = listOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)val longerThan3 = numbers.filter { it.length &gt; 3 } // 술어함수를 인자로 받는 filter 함수 타입위에서 정리한 것 처럼, 람다를 인자로 받는 함수는 고차함수이다.그러면 람다 인자의 타입은 어떻게 선언할까 ? 더 단순한 단계인, 람다를 로컬 변수에 대입하는 경우를 보자. 12val sum = { x: Int, y: Int -&gt; x + y }val action = { println(sum) } 위의 경우, 컴파일러는 sum 과 action 의 함수 타입을 아래 처럼 추론한다. 12val sum: (Int, Int) -&gt; Int = { x: Int, y: Int -&gt; x + y }val action: () -&gt; Unit = { println(sum) } 물론 아래처럼, 널이 될 수 있는 함수 타입을 정의할 수 있다. 1val funOrNull : ((Int, Int) -&gt; Int)? = null 인자로 받은 함수 호출이제, 고차 함수를 구현하는 방법을 보자. 1234fun twoAndThree(operation: (Int, Int) -&gt; Int) { val result = operation(2, 3) println(&quot;result is : $result&quot;)} 인자로 받은 함수를 호출하는 구문은, 일반 함수를 호출하는 구문과 같다.그리고, 위 고차함수를 호출할 때는 아래 처럼 람다를 전달하면 된다. 12twoAndThree { a, b -&gt; a + b }twoAndThree { a, b -&gt; a * b } 디폴트 값 지정파라미터를 함수 타입으로 선언할 때, 디폴트 값을 지정할 수 있다. 다음 예시를 보자.toString() 을 사용해서 객체를 문자열로 바꾼다. 123456789101112131415161718fun &lt;T&gt; Collection&lt;T&gt;.joinToString( separator: String = &quot;, &quot;, prefix: String = &quot;&quot;, postfix: String = &quot;&quot;): String { val result = StringBuilder(prefix) for ((index, element) in this.withIndex()) { if (index &gt; 0) { result.append(separator) } else { result.append(element) // HERE !! } } result.append(postfix) return result.toString()} toString() 을 디폴트 값으로 지정하고, 호출하는 쪽에서 지정하게 만들 수 있다. 12345678910111213141516171819fun &lt;T&gt; Collection&lt;T&gt;.joinToString( separator: String = &quot;, &quot;, prefix: String = &quot;&quot;, postfix: String = &quot;&quot;, transform: (T) -&gt; String = { it.toString() } // HERE !!!): String { val result = StringBuilder(prefix) for ((index, element) in this.withIndex()) { if (index &gt; 0) { result.append(separator) } result.append(transform(element)) // HERE !!! } result.append(postfix) return result.toString()} 호출하는 쪽에서서 joinToString() 에 아무 값도 전달하지 않으면,default 로 정의한 변환 함수를 사용한다. 123val letters = listOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)val result2 = letters.joinToString()val result1 = letters.joinToString { it.toLowerCase() } 함수를 함수에서 반환“다른 함수를 반환하는” 함수를 정의하려면,반환 타입으로 함수 타입을 지정하면 된다. 1234567891011121314151617181920enum class Delivery { STANDARD, EXPEDITED}class Order(val itemCount: Int)fun getShippingCostCalculator( delivery: Delivery): (Order) -&gt; Double { // HERE !!! if (delivery == Delivery.EXPEDITED) { return { order -&gt; 6 + 2.1 * order.itemCount } } return { order -&gt; 1.2 * order.itemCount }}fun main() { val shippingCostCalculator = getShippingCostCalculator(Delivery.EXPEDITED) val cost = shippingCostCalculator(Order(3)) println(cost)} getShippingCostCalculator 함수는Order 를 받아서 Double 을 반환하는 함수를 반환한다. 람다를 활용한 중복 제거코드 중복을 줄이기 위해, 함수 타입을 사용할 수 있다. 웹 사이트의 방문 기록을 분석하는 예를 보자. 123456789101112131415161718192021data class SiteVisit( val path: String, val duration: Double, val os: OS)enum class OS { WINDOWS, LINUX, MAC, IOS, ANDROID}val log = listOf( SiteVisit(&quot;/&quot;, 34.0, OS.WINDOWS), SiteVisit(&quot;/login&quot;, 10.0, OS.ANDROID), SiteVisit(&quot;/signup&quot;, 12.0, OS.IOS), SiteVisit(&quot;/&quot;, 20.0, OS.MAC), SiteVisit(&quot;/&quot;, 40.1, OS.LINUX),) 윈도우 사용자의 평균 방문 시간을 구하자. 1234val averageWindowsDuration = log .filter { it.os == OS.WINDOWS } .map(SiteVisit::duration) .average() 맥 사용자의 평균 방문 시간을 구하자. 1234val averageMacDuration = log .filter { it.os == OS.MAC } .map(SiteVisit::duration) .average() 중복 코드를 피하기 위해,확장 함수로 정의해서 다음과 같이 개선할 수 있다. 1234fun List&lt;SiteVisit&gt;.averageDuration(os: OS) = filter { it.os == os }.map(SiteVisit::duration).average()log.averageDuration(OS.MAC) 만약에, 다음과 같은 복잡한 질의에 대해 분석하고 싶을 때는 어떻게 할까 ?“ANDROID 사용자의 /login 페이지 평균 방문 시간은 ? “ 이 때, 람다를 적용할 수 있다. 1234fun List&lt;SiteVisit&gt;.averageDuration(predicate: (SiteVisit) -&gt; Boolean) = filter(predicate).map(SiteVisit::duration).average()log.averageDuration { it.os == OS.ANDROID &amp;&amp; it.path == &quot;/login&quot; } Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2021/10/22/kotlin-higher-order-function/"},{"title":"map, flatMap","text":"Project Reactor 의 “map, flatMap” transform operator 에 대해 정리한다. map하난의 element 를 1-to-1 방식으로 변형한다.공식 문서의 Mono 의 map 정의는 다음과 같다. 12Transform the item emitted by this Mono by applying a synchronous function to it. 공식 문서의 Flux 의 map 정의는 다음과 같다. 12Transform the items emitted by this Flux by applying a synchronous function to each item. 다응 코드를 보자. 123456789101112131415161718192021fun namesFluxMapAndFilter(strLen: Long): Flux&lt;String&gt; { val names = listOf(&quot;ko&quot;, &quot;jun&quot;, &quot;hee&quot;) return Flux.fromIterable(names) .map { it.uppercase(Locale.getDefault()) } // HERE !! .filter { it.length &gt; strLen }}@Testfun namesFluxMapAndFilter() { // given val strLen = 2L // when val names: Flux&lt;String&gt; = fluxMonoGenerator.namesFluxMapAndFilter(strLen) // then StepVerifier.create(names) .expectNext(&quot;JUN&quot;, &quot;HEE&quot;) .verifyComplete()} 위 코드는, 각 element 를 대문자로 변형한다. (map)“ko” -&gt; “KO”“jun” -&gt; “JUN”“hee” -&gt; “HEE” 길이가 2 보다 큰 element 만 추출한다. (filter)“JUN”, “HEE” flatMap하나의 element 를 1-to-n 방식으로 변형한다.공식 문서의 Flux 의 flatMap 정의는 다음과 같다. 123Transform the elements emitted by this Flux asynchronously into Publishers, then flatten these inner publishers into a single Flux through merging, which allow them to interleave. 정리하면, 각 element 를 Publisher(Mono or Flux) 로 asynchronous 하게 변형한다. 그리고, 각 Publisher 를 합쳐서 하나의 Flux 로 펼친다. 다음 코드를 보자. 1234567891011121314151617181920212223242526272829fun namesFluxFlatMap(strLen: Long): Flux&lt;String&gt; { val names = listOf(&quot;ko&quot;, &quot;jun&quot;, &quot;hee&quot;) return Flux.fromIterable(names) .map { it.uppercase(Locale.getDefault()) } .filter { it.length &gt; strLen } .flatMap { splitString(it) } // HERE !!}// &quot;KO&quot; -&gt; Flux &quot;K&quot;, &quot;O&quot;private fun splitString(name: String): Flux&lt;String&gt; { val split: List&lt;String&gt; = name.split(&quot;&quot;).filter { it.isNotEmpty() } return Flux.fromIterable(split)}@Testfun namesFluxFlatMap() { // given val strLen = 2L // when val names: Flux&lt;String&gt; = fluxMonoGenerator.namesFluxFlatMap(strLen) // then StepVerifier.create(names) .expectNext(&quot;J&quot;, &quot;U&quot;, &quot;N&quot;, &quot;H&quot;, &quot;E&quot;, &quot;E&quot;) .verifyComplete()} 위 코드는, 각 element 를 대문자로 변형한다. (map)“ko” -&gt; “KO”“jun” -&gt; “JUN”“hee” -&gt; “HEE” 길이가 2 보다 큰 element 만 추출한다. (filter)“JUN”, “HEE” 각 element 를 split 해서 list 를 생성한 뒤 Flux 를 생성한다.“JUN” -&gt; Flux “J”, “U”, “N”“HEE” -&gt; Flux “H”, “E”, “E” 3번의 결과를 하나의 Flux 로 생성한다.Flux “J”, “U”, “N”, Flux “H”, “E”, “E” -&gt; Flux “J”, “U”, “N”, “H”, “E”, “E” https://projectreactor.io/ Udemy, “Build Reactive MicroServices using Spring WebFlux/SpringBoot”","link":"/2021/12/26/reactor-map-flatMap/"},{"title":"Generics","text":"다음 내용을 정리한다. 제네릭 타입 파라미터 제네릭 함수 제네릭 클래스 제네릭 타입 파라미터 제약 제네릭스 동작 원리 제네릭 타입 파마리터제네릭스를 사용하면, 타입 파마리터를 받는 타입을 정의할 수 있다.제네릭 타입의 인스턴스를 만들려면, 타입 파라미터를 구체적인 타입 파라미터로 치환해야한다. 예를 들어, Map 클래스는 키 타입과 값 타입을 타입 파리미터로 받으므로 Map&lt;K, V&gt; 이다.이 제네릭 클래스에 대해 제네릭 타입의 인스턴스를 만들려면,Map&lt;String, Person&gt; 처럼 구체적인 타입 파라미터로 치환해서 인스턴스화할 수 있다. 타입 파라미터 추론코틀린 컴파일러는 보통의 타입과 마찬가지로, 타입 파라미터도 추론가능하다. 코틀린 Collections 의 listOf function 에는 아래 처럼, 타입 파라미터 T 가 정의되어 있다. 아래에서는, listOf 에 전달된 두 값이 문자열이므로 여기서 생기는 리스트가 List&lt;String&gt; 임을 추론한다. 1val names = listOf(&quot;junhee&quot;, &quot;ko&quot;) 아래에서는, 빈 리스트를 만든다면 타입 파라미터를 추론할수 없어서 직접 타입 파라미터를 명시해야한다. 1val names = listOf&lt;String&gt;() 제네릭 함수컬렉션을 다루는 라이브러리의 함수는 대부분 제네릭 함수다.slice 함수의 정의를 보자. 이 slice 제네릭 함수를 호출해보자. 1234val letters = ('a'..'z').toList()val slice1 = letters.slice&lt;Char&gt;(0..2) // 타입 파라미터 명시적으로 지정val slice2 = letters.slice(10..12) // 컴파일러가 T 를 Char 로 추론 다른 예로, filter 함수의 정의를 보자. 이 filter 제네릭 함수를 호출해보자. 1234val names = listOf(&quot;james&quot;, &quot;kobe&quot;, &quot;jko&quot;, &quot;messi&quot;)val me = listOf(&quot;jko&quot;, &quot;junhee&quot;, &quot;ko&quot;)names.filter { it in me } // 여기서 it 의 타입은 T 라는 제네릭 타입 위에서, 컴파일러는 T 가 String 이라는 사실을 다음 사실로 추론한다. filter 가 List&lt;T&gt; 타입의 리스트에 대해 호출될 수 있다는 사실 filter 의 수신 객체인 names 의 타입이 List&lt;String&gt; 이란 사실 제네릭 확장 프로퍼티리스트의 마지막 원소 바로 앞에 있는 원소를 반환하는 확장 프로퍼티를 만들어보자. 1234val &lt;T&gt; List&lt;T&gt;.penultimate: T get() = this[size - 2]listOf(1,2,3).penultimate // 타입 파라미터 T 가 Int 로 추론된다. 제네릭 클래스타입 파라미터를 이름 뒤에 붙이면, 클래스 본문에서 타입 파리미터를 다른 일반 타입처럼 사용 가능하다.표준 자바 인터페이스인 List 를 코틀린으로 정의해보자. 1234interface List&lt;T&gt;{ operator fun get(index: Int): T} 위 인터페이스 안에서 T 를 일반 타입처럼 사용가능하다. 제네릭 클래스를 확장하는 클래스를 정의하기 위해서는,기반 타입의 제네릭 파라미터에 대해 타입 파라미터를 지정해야한다.이 때, 구제적인 타입을 넘길 수도 있고1234567891011interface List&lt;T&gt;{ operator fun get(index: Int): T}class StringList : List&lt;String&gt; { // 구체적인 타입 override fun get(index: Int): String { TODO(&quot;Not yet implemented&quot;) }} 타입 파라미터로 받은 타입을 넘길수도 있다.1234567891011interface List&lt;T&gt;{ operator fun get(index: Int): T}class ArrayList&lt;T&gt; : List&lt;T&gt; { // 타입 파라미터로 받은 타입 override fun get(index: Int): T { TODO(&quot;Not yet implemented&quot;) }} 타입 파라미터 제약타입 파라미터 제약은 클래스나 함수에 사용하는 타입 파라미터를 제한한다.제약을 가하려면 타입 파라미터 이름 뒤에 콜론(:) 을 표시하고 그 뒤에 상한 타입을 적으면 된다. 아래 예를 보자. 아래 호출은 실제 타입 파라미터인 Int 가 Number 를 확장하므로, 정상 호출된다. 1listOf(1,2,3).sum() 타입 파리미터를 널이 될수 없는 타입으로 한정다음 예를 보자. 123456789class Processor&lt;T&gt; { fun process(value: T){ // ? 가 붙어있지 않음 value?.hashCode() }}val processor = Processor&lt;String?&gt;()processor.process(null) value 파라미터의 타입 T 에는 ? 가 붙어있지 않다.하지만, 실제로 T 에 해당하는 타입 파라미터로 널이 될 수 있는 타입을 넘길 수 있다. 항상 널이 될 수 없는 타입만 타입 파라미터로 받기위해서는,Any 를 상한으로 지정하는 제약을 가하면 된다. 1234567891011class Processor&lt;T: Any&gt; { // 항상 널이 될 수 없는 타입만 파라미터로 받음 fun process(value: T){ value.hashCode() }}fun processorTest(){ val processor = Processor&lt;String&gt;() processor.process(&quot;jko&quot;)} 제레릭스 동작 원리실행 시점에는, Type Erasure 로 인해 제네릭 클래스의 인스턴스에는 타입 파리미터의 정보가 없다.inline function 에 reified 타입 파라미터를 사용하면 타입 파라미터를 지워지지 않게 할 수 있다.이 내용을 구체적으로 정리해보자. Type Erasure다음 코드를 보자. 123456fun &lt;T&gt; print(list: List&lt;T&gt;) { if (list is List&lt;String&gt;) { println(&quot;list is List&lt;String&gt;&quot;) }} 위 코드는 컴파일 에러가 발생한다. 1Cannot check for instance of erased type: List&lt;String&gt; 이러한 에러가 발생하는 이유는,제네릭 파라미터에 대한 정보가 런타임에 지워지기 때문이다. (== type erasure)즉, List 객체를 만들고 문자열을 넣어도 실행 시점에는 List 로만 볼 수 있다. 다음을 보자. 123fun main(){ val list = listOf&lt;String&gt;(&quot;jko&quot;, &quot;junhee&quot;)} 위 코드를 컴파일한 결과를, 다시 디컴파일 해보자. 위와 같이, List 객체가 어떤 타입의 원소를 저장하는지 알 수 없게 되었다.메모리 사용량이 줄어든다는 장점은 있다. 저장해야하는 타입의 정보가 줄어들었기 때문이다. 어떤 값이 List 인지는 Star Projection (*) 을 통해서 알 수 있다. 1if (list is List&lt;*&gt;) { } reified 타입 파라미터1fun &lt;T&gt; isA(value: Any) = value is T 역시 컴파일 에러가 발생한다. 1Cannot check for instance of erased type: T 제레닉 타입의 파라미터 정보가 실행 시점에 없기 때문이다.이런 제약을 해결하기 위해, inline 함수에 타입 파라미터를 reified 로 지정하면 된다. 123456inline fun &lt;reified T&gt; isA(value: Any) = value is Tfun isATest(){ val isAString1 : Boolean = isA&lt;String&gt;(&quot;abc&quot;) val isAString2 : Boolean = isA&lt;String&gt;(123)} reified 타임 파라미터를 활용한 표준 라이브러리 함수의 예로, filterIsInstance 가 있다. 12val list = listOf(&quot;junhee&quot;, 123)val filteredList: List&lt;String&gt; = list.filterIsInstance&lt;String&gt;() filterIsInstance 가 어떻게 작성되었는지 보자. &lt;reified T&gt; 는 타입 파라미터가 실행 시점에 지워지지 않는다는 것을 의미한다.디컴파일된 결과를 보면, 아래와 같이 String 이 남아있다. Kotlin In Action &lt;드미트리 제메로프, 스베트라나 이사코바&gt;","link":"/2022/01/23/kotlin-generics/"},{"title":"Spring WebFlux Thread Model","text":"Spring Webflux 에서는 어떤 thread 들이 어떻게 request 를 처리하는지 정리한다. Threads: reactor-http-nio1234On a “vanilla” Spring WebFlux server (for example, no data access nor other optional dependencies), you can expect one thread for the server and several others for request processing (typically as many as the number of CPU cores). Servlet containers, however, may start with more threads (for example, 10 on Tomcat), in support of both servlet (blocking) I/O and servlet 3.1 (non-blocking) I/O usage. Spring 공식 문서에 따르면,부가적인 dependency 가 없는 Spring WebFlux 서버는, 서버를 위한 thread 하나와 요청 처리를 위한 여러 thread 들로 구성된다. spring-boot-starter-webflux dependency 만 추가해서 project 하나를 만들어보자. 그리고, 아래와 같이 ‘1,2,3’ 을 응답하는 간단한 endpoint 를 추가하자. 12345678910111213@RestController@RequestMappingclass NumbersController { private val logger = LoggerFactory.getLogger(this::class.java) @GetMapping(&quot;/local&quot;) fun getNumbers(): Flux&lt;Int&gt; { logger.info(&quot;-- getNumbers&quot;) return Flux.fromIterable(listOf(1, 2, 3)) }} App 을 실행시키고, 해당 endpoint 를 호출해보자. 1curl http://localhost:8080/local 요청 처리를 reactor-http-nio-2 스레드가 담당하는 것을 알 수 있다. Worker Tread CountThread Pool 의 worker thread 개수는, availableProcessors 의 개수와 동일하다.availableProcessors 의 개수를 출력해보자. 12345678910@SpringBootApplicationclass Applicationprivate val logger = LoggerFactory.getLogger(Application::class.java)fun main(args: Array&lt;String&gt;) { runApplication&lt;Application&gt;(*args) logger.info(&quot;CPU: ${Runtime.getRuntime().availableProcessors()}&quot;)} 출력 결과는 다음과 같다. 위에서 만든 endpoint 로 여러 요청을 해보자.아래와 같이, 16개의 worker thread 가 요청 처리를 하고 있는 것을 알 수 있다. WebClient Threads123The reactive WebClient operates in event loop style. So you can see a small, fixed number of processing threads related to that (for example, reactor-http-nio- with the Reactor Netty connector). However, if Reactor Netty is used for both client and server, the two share event loop resources by default. Spring 공식 문서에 따르면, WebClient 는 이벤트 루프 스타일로 동작한다.다음 endpoint 를 추가해보자. 12345678910111213@GetMapping(&quot;/local/remote&quot;)fun getNumbersMergedWithRemote(): Flux&lt;Int&gt; { logger.info(&quot;-- Start getNumbersMergedWithRemote&quot;) val numbers: Flux&lt;Int&gt; = Flux.fromIterable(listOf(1, 2, 3)) val numbersFromRemote: Flux&lt;Int&gt; = webClient.get() .uri(&quot;/remote&quot;) .retrieve() .bodyToFlux&lt;Int&gt;() .log() return numbers.concatWith(numbersFromRemote)} 위 endpoint 를 호출했을 대, 출력되는 결과는 다음과 같다. 요청 처리는 reactor-http-nio-4 가 담당하고 있다.그리고 reactor-http-nio-4 에서 subscribes 를 한다.하지만, 결과는 다른 스레드인 reactor-http-nio-2 에 publish 되고 있다. https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-concurrency-model https://piotrminkowski.com/2020/03/30/a-deep-dive-into-spring-webflux-threading-model/ https://github.com/junhee-ko/spring-webflux-thread-model","link":"/2022/01/23/spring-web-flux-thread-model/"},{"title":"Kotlin Compiler Plugins","text":"kotlin compiler plugins 중에 plugin-spring 과 plugin-jpa 에 대해 정리한다. 프로젝트 생성Spring Initializer 를 이용해서 프로젝트를 생성해보자.kotlin + gradle 기반에 의존성으로 Spring Data JPA 만 추가한다.생성된 build.gradle.kt 파일을 보자. plugin 에 위와 같이 “plugin.spring”, “plugin.jpa” 가 추가된 것을 볼 수 있다.왜 이 두 개의 plugin 이 자동으로 추가된 걸까 ? plugin.spring“org.jetbrains.kotlin.plugin.spring” 는 org.jetbrains.kotlin.plugin.allopen” 의 wrapper plugin 이다. “org.jetbrains.kotlin.plugin.allopen” 와 동일하게 동작한다. “org.jetbrains.kotlin.plugin.spring” compiler plugin 은, 아래 annotation 이 붙은 클래스와 그 클래스의 맴버에 open 을 자동으로 추가한다. @Component @Async @Transactional @Cacheable @SpringBootTest 직접 확인해보자. 다음과 같이 프로젝트에 두 개의 클래스를 추가해보자. 12345678910class Book( private val name: String, private val number: Long)@Componentclass BookComponent( private val name: String = &quot;kotlin&quot;, private val number: Long = 84219) 컴파일된 결과를 보면, Book 에는 open 키워드가 붙어있지 않지만, BookComponent 에는 붙어있다. BookComponent 클래스에 @Component 가 붙어있기 때문에,all-open compiler plugin 이 BookComponent 클래스와 BookComponent 의 맴버인 name 과 number 에 open 을 자동으로 추가한다. 물론, @SpringBootApplication 이 붙은 클래스의 컴파일 결과에도 open 키워드가 붙어있다. plugin.jpa“org.jetbrains.kotlin.plugin.jpa” 는 “org.jetbrains.kotlin.plugin.noarg” 의 wrapper plugin 이다. “org.jetbrains.kotlin.plugin.jpa” compiler plugin 은, 아래 annotation 이 붙은 클래스에 zero-argument constructor 를 생성한다. @Entity @Embeddable @MappedSuperclass 직접 확인해보자. 다음과 같이 프로젝트에 두 개의 클래스를 추가해보자. 1234567class User@Entityclass UserEntity( @Id private val id: Long) compile 된 결과를 decompile 해보자.UserEntity 에는 zero-argument constructor 가 생성되었지만, User 에는 없다. https://kotlinlang.org/docs/all-open-plugin.html https://kotlinlang.org/docs/no-arg-plugin.html#jpa-support","link":"/2022/02/13/kotlin-compiler-plugins/"},{"title":"Spring Data JPA Paging","text":"Spring Data JPA 를 이용해서 paging 처리를 할 때,부가적인 count query 를 발생시키지 않는 방법을 정리한다. Setup아래와 같이 의존성으로, Spring Data JPA 와 H2 를 추가하자.테스트를 위해 Embedded DB 로 H2 를 사용한다. Entity 로 Book 을 정의하자. 12345678@Entityclass Book( @Id @GeneratedValue val id: Long? = null, val name: String) 그리고, BookRepository 를 정의하자.Paging 을 위해, PagingAndSortingRepository interface 를 상속한다. 1interface BookRepository : PagingAndSortingRepository&lt;Book, Long&gt; TestJPA 관련 테스트이기 때문에, @DataJpaTest 를 활용해보자. 1234@DataJpaTestinternal class BookRepositoryTest { } 각 테스트가 실행될 때마다, 데이터를 setUp 하자. 123456789101112131415161718192021222324@DataJpaTestinternal class BookRepositoryTest { @Autowired private lateinit var bookRepository: BookRepository @BeforeEach internal fun setUp() { val books = listOf( Book(name = &quot;jpa-paging-1&quot;), Book(name = &quot;jpa-paging-2&quot;), Book(name = &quot;jpa-paging-3&quot;), Book(name = &quot;jpa-paging-4&quot;), Book(name = &quot;jpa-paging-5&quot;), Book(name = &quot;jpa-paging-6&quot;), Book(name = &quot;jpa-paging-7&quot;), Book(name = &quot;jpa-paging-8&quot;), Book(name = &quot;jpa-paging-9&quot;), Book(name = &quot;jpa-paging-10&quot;) ) bookRepository.saveAll(books) }} 이제 test method 를 작성해보자. 123456789@Testinternal fun `Page 를 return 하면, count query 가 발생한다`() { val firstPage = PageRequest.of(0, 4) val books: Page&lt;Book&gt; = bookRepository.findAll(firstPage) books.map { println(&quot;name: ${it.name}&quot;) }} 위 메서드의 실행 결과는 어떻게 나올까 ?물론, jpa-paging-1, jpa-paging-2, jpa-paging-3, jpa-paging-4 가 순서대로 출력될 것이다. 확인해보자. 예상대로 출력되었다. 그런데, 왜 select 가 두 번 query 되었을까 ? 두 번째 select 는 count query 인 것을 알 수 있다.공식 문서에 따르면, 다음과 같다. 12A Page knows about the total number of elements and pages available. It does so by the infrastructure triggering a count query to calculate the overall number 번역하면, 12Page 는 사용 가능한 요소와 페이지의 총 수를 알고 있다.그래서, 전체 수를 계산하기 위해 카운트 쿼리가 트리거된다. Page interface 의 정의를 보면, totalPage 와 totalElement 를 return 하는 메서드가 정의되어있다. 만약에 조회해야하는 elements 가 많을 때는, page 별 select 를 할 때마다 count query 가 수행되어 expensive 하다. 개선그럼 어떻게 count query 가 수행되지 않게 할 수 있을까 ?간단하다. List 를 return 하게 하면 된다. Page 를 build 하기 위한 count query 가 필요없기 때문이다. 직접 확인해보자.BookRepository 에 Pageable instance 를 받고, List 를 리턴하는 query method 를 정의하자. 1234interface BookRepository : PagingAndSortingRepository&lt;Book, Long&gt; { fun findAllBy(pageable: Pageable): List&lt;Book&gt;} 그리고, 위 메서드를 사용하는 테스트 코드를 작성하자. 123456789@Testinternal fun `List 를 return 하면, count query 가 발생하지 않는다`() { val firstPage = PageRequest.of(0, 4) val books: List&lt;Book&gt; = bookRepository.findAllBy(firstPage) books.map { println(&quot;name: ${it.name}&quot;) }} 실행결 결과는 아래처럼, count query 가 발생하지 않는다. https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.special-parameters https://github.com/junhee-ko/spring-data-jpa-paging","link":"/2022/02/17/spring-data-jpa-paging/"},{"title":"[빅데이터를 지탱하는 기술] 4장_빅데이터 축적","text":"1. 벌크 형과 스트리밍 형의 데이터 수집데이터 수집 방법으로 두 가지 방법이 있다.이 챕터에서는 각각의 방법으로, 분산 스토리지에 데이터가 저장되기까지의 흐름을 정리한다. 벌크 형 스트리밍 형 객체 스토리지와 데이터 수집빅데이터는 확장성이 높은 분산 스토리지에 저장된다. 분산 스토리지로, 분산형 데이터베이스 객체 스토리지객체 스토리지는 다수의 컴퓨터를 사용해 파일을 여러 디스크에 복사해서 데이터 중복화 및 부하 분산을 실현한다.객체 스토리지의 구조는 데이터 양이 많을 때는 우수하지만, 소량의 데이터에 대해서는 비효율적이다.하둡의 HDFS, 클라우드 서비스의 Amazon S3 가 대표적이다. 데이터 수집데이터 수집이란, 수집한 데이터를 가공해 집계 효율이 좋은 분산 스토리지를 만드는 일련의 프로세스이다.작은 데이터는 적당히 모아서 하나의 큰 파일로 만들어 효율을 높이는데 도움이 된다.파일이 지나치게 크면, 네트워크 전송 시간이 오래 걸려 오류 발생률이 높다. 벌크 형 데이터 전송 전통적인 데이터 웨어하우스에서는 주로 벌크 형 방식으로 데이터베이스나 파일 서버 또는 웹 서비스 등에서 각각의 방식 (SQL, API …) 으로 정리해 데이터를 추출한다.처음부터 분산 스토리지에 데이터가 저장되어 있지 않으면 데이터 전송을 위한 ETL 서버를 설치한다.데이터 전송의 신뢰성이 중요하면 벌크형 도구를 사용하는 것이 좋다. 파일 사이즈의 적정화ETL 프로세스는 하루마다 또는 한시간 마다의 간격으로 정기적인 실행을 하므로 그 동안 축적된 데이터는 하나로 모인다.데이터 양이 많을 때는 한 달씩이나 하루 단위로 전송하도록 작은 태스크로 분해해 한 번의 태스크 실행이 커지지 않도록 조정해야한다.워크 플로우 관리 도구를 사용하면 쉽게 관리 할 수 있다. 스트리밍 형의 데이터 전송 계속해서 전송되어 오는 작은 데이터를 취급하기 위한 데이터 전송이다.이러한 데이터 전송은 다수의 클라이언트에서 계속 작은 데이터가 전송된다. 이러한 데이터 전송 방식이 메세지 배송 (Message Delivery) 이다.보내온 메세지를 저장하는 방법으로, NoSQL 데이터베이스Hive 와 같은 쿼리 엔진으로 NoSQL 데이터베이스에 연결해 데이터를 읽을 수 있다. Message Queue데이터를 일정 간격으로 꺼내고 모아서 분산 스토리지에 저장한다. 웹 브라우저에서 메세지 배송 상주형 로그 수집 소프트웨어자체 개발한 웹 애플리케이션 등에서는 웹 서버 안에서 메세지를 만들어서 배송한다. 전송 효율을 높이기 위해 서버상에서 일단 데이터를 축적해 놓고 나중에 모아서 보내는 경우가 있다.이 때, Fluentd 나 Logstash 같은 상주형 로그 수집 소프트웨어가 자주 사용된다. 웹 이벤트 추적자바스크립트를 이용해 웹 브라우에서 직접 메세지를 보내는 경우도 있다. 모바일 앱에서 메세지 배송 MBaaS모바일 앱에서는 서버를 직접 마련하는 것이 아니라, MBaaS (Mobile Backend as a Serivce) 라는 백엔드의 각종 서비스를 이용할 수 있다. SDK모바일 앱이 오프라인이 되었을 때는 발생한 이벤트를 SDK 내부에 축적하고 온라인 상태 되었을 때 모아서 보낼 수 있다. 디바이스에서 메세지 배송 MQTT (MQ Telemetry Transport) 는 TCP/IP 를 이용하여 데이터 전송하는 프로토콜 중 하나이다. 일반적으로 Pub/Sub 메세지 배송 구조이다. 메세지 배송의 공통화메세지가 처음 생성되는 기기를 클라이언트, 해당 메세지를 먼저 받는 서버를 프론트엔드라고 한다.프론트 엔드는 단지 데이터를 받는 것에 전념하고, 그 이후의 문제는 백엔드의 공통 시스템에 맡길 수 있다. 2. 성능, 신뢰성 : 메세지 배송의 트레이드오프이 챕터는 메세지 브로커를 중심으로 메세지 배송 구조와 한계를 정리한다. 메세지 브로커메세지 배송에 의해 보내진 데이터를 분산 스토리지에 저장할 때, 데이터 양이 적을 때는 문제가 되지 않지만 쓰기의 빈도가 증가하면 디스크 성능의 한계에 도달해 더 쓸 수 없게 될 우려가 있다.대량의 메세지를 안정적으로 받기 위해서는 빈번한 쓰기에도 견딜 수 있는 성능이 높고, 필요에 따라 성능을 얼마든지 올릴 수 있는 스토리지가 필요하다.분산 스토리지가 반드시 이 성격을 가질 수 있다고 할 수 없기 때문에, 메세지를 일시적으로 축적하는 중산층이 설치된다. 이것이 메세지 브로커이다.ex) Apache Kafka, Amazon Kinesis push 형, pull 형송신 측의 제어로 데이터를 보내는 방식을 push 형, 수신 측 주도로 데이터를 가져오는 것을 pull 형이라고 한다.메세지 브로커에 데이터를 push 하는 것을 producer, pull 하는 것을 consumer 라고 한다.push 형의 메세지 배송은 모두 메세지 브로커에 집중 시키고 거기에서 일정한 빈도로 꺼낸 데이터를 분산 스토리지에 기록한다.또한, pull 형의 메세지 배송은 파일 사이즈 적정화에도 도움이 된다. consumer 는 메세지 브로커로부터 일정한 간격으로 데이터를 취해 적당히 모아진 데이터를 분산 스토리지에 저장한다. 메세지 라우팅메세지 브로커에 써넣은 데이터는 다수의 다른 consumer 에서 읽을 수 있다. 이를 통해 메세지가 복사되어 데이터를 여러 경로로 분기 시킬 수 있다. 이것이 메세지 라우팅이다.예를 들어, 메세지 일부를 실시간 장애 감지를 사용하면서, 같은 메세지를 장기적인 데이터 분석을 위한 분산 스토리지에 저장하는 것도 가능하다. 메세지 배송 신뢰성 문제와 세 가지 설계 방식대부분의 경우 다음 중 하나를 보장하도록 설계된다. at most once기껏해야 한 번.메세지는 한 번만 전송된다. 도중에 전송 실패로 사라질 가능성이 있다. exactly once정확히 한 번.메세지는 손실 되거나 중복 없이 한 번만 전달된다.네트워크 상에 두 개의 노드가 있는 경우 양쪽의 통신 내용을 보장하기 위해 coorninator 가 필요하다. 문제가 생기면 송신 측과 수신 측 모두 서로의 정보를 코디네이터에게 전달해서 문제가 발생하면 코디네이터의 지시에 따라 해결할 수 있다.그러나 분산 시스템에서는 코디네이터와의 통신이 끊길 수 있고 코데네이터가 정지될 수도 있다. 따라서 코디네이터의 부재 시에 어덯게 할 것인지에 대한 consensus 가 필요하다. 보통, 단시간 장애 가능성은 받아 들인다.또한, 코디네이터의 판단에만 따르고 있으면 시간이 너무 소요된다.그래서 메세지 배송 시스템에서는 코디네이터를 도입하지 않고 at least once 를 따른다. at least once최소한 한 번.메세지는 확실히 전달된다. 단, 같은 것이 여러번 전달될 가능성이 있다.메세지가 재전송되어도 그것을 없앨 수 있는 구조가 있으면 보기에 중복이 없는 것처럼 할 수 있다. 이러한 구조를 ‘중복 제거’ 라고 한다.예를 들어, TCP 는 메세지 수신 확인을 위해 ‘ack’ 플래그를 도입했다. 메세지 재전송에 의한 중복이 발생하지만, 모든 TCP 패킷에서는 이것을 식별하는 시퀀스 번호를 이용해 중복 제거가 이뤄진다.대부분의 메세지 배송 시스템은 at least once 를 보장하는 한편, 중복 제거는 이용자에게 맡기고 있어서 TCP/IP 처럼 자동으로 중복을 제거해주지 않는다. (ex) Apache Kafka, Apache Flume, Logstash 중복 제거는 높은 비용의 오퍼레이션중복 제거 방법으로 다음과 같은 방법이 있다. 오프셋 이용각 메세지에는 파일 안의 시작 위치 (오프셋) 를 붙인다.메세지가 중복되어도 같은 파일의 같은 장소를 덮어쓸 뿐이므로 문제되지 않는다.벌 크형 데이터 전송과 같이 데이터양이 고정된 경우에 사용한다. 고유 ID 이용모든 메세지에 UUID 등의 고유 ID 를 지정한다.메세지가 늘어남에 따라 ID 가 증가하므로 그것을 어떻게 관리하느냐가 문제이다.스트리밍 형의 메세지 배송에서 자주 사용된다. End to End 신뢰성클라이언트가 생성한 메세지를 최종 도달 지점인 분산 스토리지에 기록하는 단계에서 중복 없는 상태로 해야한다.중간에 한 부분이라도 at most once 가 있으면 메세지를 빠뜨릴 가능성이 있고, at least once 가 있으면 중복될 수 있다.신뢰성이 높은 메세지 배송을 실현하려면 중간 경로를 모두 at least once 로 통일한 후 클라이언트 상에서 모든 메세지에 고유 ID 를 포함하도록 하고 경로의 말단에서 중복 제거를 실행해야한다. 고유 ID 를 사용한 중복 제거 방법두가지 방법이 있다. 분산 스토리지로 NoSQL 데이터베이스 사용Cassandra 나 Elasticsearch 등은 데이터를 쓸 대 고유 ID 를 지정하게 되어 있어 동일한 ID 의 데이터는 덮어쓴다. SQL보내온 데이터는 일단 그대로 객체 스토리지 등에 저장하고, 나중에 읽어 들이는 단계에서 중복을 제거한다.Hive 와 같은 배치형 쿼리 엔진에서 실행할 수 있다. 데이터 수집 파이프라인 일련의 프로세스를 거쳐 마지막으로 데이터를 구조화해서 열 지향 스토리지로 변환함으로써, 장기간의 데이터 분석에 적합한 스토리가 완성된다. 이것인 데이터 수집 파이프라인이다.실제로 어떤 파이프라인을 만들지는 요구사항에 따라 다르므로, 필요에 따라 시스템을 조합한다.예를 들어, 쓰기 성능에 불안감이 없으면 메세지 브로커가 불필요 하므로 클라이언트에서 직접 NoSQL 데이터베이스에 데이터를 써도 된다. 중복이 허용된다면 중복 제거를 생략할 수 있다. 중복을 고려한 시스템 설계스트리밍 형의 메세지 배송 방식에서는 중간에 중복 제거 방식을 도입하지 않으면 중복 가능성이 있다고 생각하면 된다.신뢰성이 중시되는 경우에는 스트리밍 형의 메세지 배송을 피하는 것이 좋다.예를 들어, 과금 데이터같은 오차가 불허용 되는 경우 트랜잭션 처리를 지원하는 데이터베이스에 직접 애플리케이션이 기록해야한다. 그 후에 벌크 형의 데이터 전송을 함으로써 중복도 결손도 확실히 피해야한다. 3. 시계열 데이터의 최적화스티밍형의 메세지 배송에서는 ‘메세지가 도착할 때까지의 시간 지연’ 이 문제다. 늦게 도달하는 데이터가 집계 속도에 미치는 영향을 정리한다. 프로세스 시간과 이벤트 시간다음 두 시간의 차이가 성가신 문제를 일으킨다. 이벤트 시간클라이언트 상에서 메시지가 생성된 시간. 데이터 분석의 대상은 주로 이벤트 시간 프로세스 시간서버가 처리하는 시간 프로세스 시간에 의한 분할과 문제점늦게 도달하는 데이터가 있다는 것은, 과거의 집계 결과가 매일 조금씩 바뀐다는 것을 의미한다. 보다 실제에 가까운 데이터를 얻기 위해서는 ‘이벤트 시간’ 보다 며칠 정도 지난 시점에서 집계해야한다.분산 스토리지에 데이터를 넣는 단계에서는 이벤트 시간이 아니라 프로세스 시간 사용하는 것이 보통이다.예를 들어, 2017년 1월 1일에 도착한 데이터는 ‘20170101’ 과 같은 이름으로 지정한다. 그리고 그 파일에는 이벤트 시간으로 보면 다수의 과거 데이터가 포함된 상태다. 다음 그림과 같다. 이 상태에서 과거 특정 일에 발생한 이벤트를 집계하고 싶다고 하자. 예를 들어, 1월 1일에 발생한 이벤트면, 그 이후에 만들어진 모든 파일에 포함되어 있을 수 있다.다수의 파일을 모두 검색하는 쿼리를 Full Scan 이라고 한다. 이것이 시스템의 부하를 높이는 요인이다. 시계열 인덱스 : 이벤트 시간에 의한 집계 효율화 01이벤트 시간 취급을 효율화하기 위해 데이터를 정렬해보자. 이벤트 시간에 대해 인덱스 만들기RDB 에서 익덴스를 만든것 처럼.Cassandra 와 같은 시계열 인덱스 (time-series index) 에 대응하는 분산 데이터베이스를 이용하면 처음부터 이벤트 시간으로 된 테이블을 만들 수 있다.시계열 인덱스를 사용하면, 매우 짧은 범위의 특정 시간에 맞춘 데이터 집계를 빠르게 실행할 수 있다.정해진 시간에 발생한 이벤트를 조사하거나, 실시간 대시보드를 만드는 경우에 유용하다. 열 지향 스토리지장기간에 걸쳐 대량에 데이터를 집계하는 경우에는 분산 데이터베이스가 효율적이지 않다.장기적인 데이터 분석에는 집계 효율이 높은 열지향 스토리지를 지속적으로 만들어야한다. 조건절 푸쉬다운 : 이벤트 시간에 의한 집계 효율화 02매일 한 번씩 새로 도착한 데이터를 배치 처리로 변환해보자.열 지향 스토리지에서는 RDB 와 동등한 인덱스를 만들 수 없지만, 처음에 데이터를 정렬할 수 있다. 그래서 다음 그림처럼, 이벤트 시간으로 데이터를 정렬하고 열지향 스토리지로 변환하자. 열 지향 스토리지는 ‘칼럼 단위의 통계 정보’ 를 이용해 최적화가 이뤄진다. 예를 들어, 시간이면 각 칼럼의 최솟값과 최댓값 등이 모든 파일에 메타 정보로 저장되어 있다. 그런 정보를 참고해 어떤 파일의 어떤 부분에 원하는 데이터가 포함되어 있는지 알 수 있다. 조건절 푸쉬 다운이란, 이 통계를 이용해 필요한 최소한의 데이터를 읽도록 최적화 하는 것이다. 열 지향 스토리지를 만들 때, 가급적 읽어 들이는 데이터 양을 최소화하기 위해 데이터를 정렬해서 조건절 푸쉬다운에 의한 최적화로 풀 스캔을 피한다. 이벤트 시간에 의한 분할앞 장에서 테이블을 물리적으로 분리하는 테이블 파티셔닝을 설명했다. 그 중에서도 시간을 이용해 분할된 테이블을 시계열 테이블 이라고 한다. 여기에서는 다음 그림과 같이 이벤트 발생 시간을 파티션의 이름에 포함되도록 한다. 과거의 이벤트 시간을 갖는 데이터를 드물지만, 몇년에 걸쳐서 보내올 가능성이 있다. 따라서, 시계열 테이블을 구성하는 각 파티션에는 조금씩 데이터가 추가된다. 결과적으로, 분산 스토리지에는 대량의 작은 파일이 만들어지고 점차 쿼리의 성능이 악화된다. 그래서, 이벤트 시간으로부터 시계열 테이블을 만든다면 작은 데이터를 효율적으로 추가할 수 있는 데이터베이스를 사용하거나 너무 오래된 데이터는 버리는 아이디어가 필요하다. 데이터 마트를 이벤트 시간으로 정렬하기 데이터 수집 단계에서는 이벤트 시간을 따지지 않고 프로세스 시간만을 사용하여 데이터를 저장한다. 그리고 데이터 마트를 만드는 단계에서 이벤트 시간에 의한 정렬을 한다. 그러면, 파일이 조각나는 일이 없고, 항상 최적의 데이터 마트를 유지할 수 있다. 4. 비구조화 데이터의 분산 스토리지NoSQL 데이터베이스에 의한 데이터 활용빅데이터를 위한 분산 스토리이지는, 다음이 요구된다. 확장성필요에 따라 얼마든지 확장할 수 있어야한다. 유연성데이터를 구조화하지 않고도 저장할 수 있어야한다. 기본이 되는 객체 스토리지는, 장점임의의 파일을 저장할 수 있다. 단점파일을 교체하기 어렵다. 일단 파일으 써넣으면 통째로 교체할 방법이 없다. 로그 파일처럼 나중에 변경할 일이 없는 것은 상관 없지만, 데이터베이스처럼 수시로 변경하는 용도는 적합하지 않다. 특히 중요한 데이터는 트랜잭션 처리가 가능한 데이터베이스에 기록해야한다. 그리고, 객체 스토리지에 저장된 데이터를 집계할 수 있게 되기까지는 시간이 걸린다. 열지향 스토리지를 만듦으로써 집게는 고속화 되지만, 그 작성에 시간이 걸린다. 데이터를 기록하고 바로 활용할 경우 실시간 집계와 검색에 적합한 데이터 저장소가 필요하다. 객체 스토리지의 단점을 해결하기 위한 데이터 저장소를 일컬어 NoSQL 데이터베이스이다. NoSQL 데이터베이스의 예로, 분산 KVS 와이드 칼럼 스토어 도큐먼트 스토어 분산 KVS 모든 데이터를 키값 쌍으로 저장하도록 설게된 데이터 저장소이다. 키가 정해지면, 그 값을 클러스터 내의 어느 노드에 배치할 것인지 결정한다. 이 구조에 의해 노드 간에 부하를 균등하게 분산하고 노드를 증감하는 것만으로 클러스터의 성능을 변경할 수 있다. 예를 들어, 아마존의 DynamoDB 가 있다. 분산 아키텍쳐P2P 형의 분산 아키텍쳐를 가지고 있으며, 미리 설정한 초 단위의 요청 수에 따라 노드가 증감되는 특징이 있다. 따라서, 데이터의 읽기 및 쓰기에 지연이 발생하면 곤라한 애플리케이션에 유용하다. 데이터 분석DynamoDB 데이터를 분석하려면, 아마존 EMR, Redshift 등과 결합하여 Hive 에 의한 배치 처리를 실행하거나 데이터 웨어하우스에 데이터를 전송하도록 한다. 스트림 처리DynamoDB 고유 기능인 DynamoDB Streams 를 상요하면 데이터 변경을 이벤트로 외부에 전송해 실시간 스트림 처리가 가능하다. 일반적으로 NoSQL 데이터베이스는 애플리케이션에서 처음에 데이터를 기록하는 장소로 이용된다. NoSQL 데이터베이스 자체는 대량의 데이터를 집계하는 기능이 없는 것이 많아 데이터 분석을 위해서는 외부로 데이터를 추출해야한다. 단, RDB 등과 비교하면 읽기 성능이 높기 때문에 쿼리 엔진에서 접속해도 성능상의 문제가 발생하기 어렵다. 그래서 애드 혹 분석에서는 데이터를 복사하지 않고 필요시에 직접 연결해서 사용할 수 있다. [기초지식] ACID 특성과 CAP 정리 ACID 란 트랜잭션 4 가지 성질로 ‘원시성, 일관성, 독립성, 내구성’이다. 일반적인 RDB 는 이것을 충족하고 있어서 신뢰성있는 트랜잭션 처리를 하고 있다. 하지만, ACID 를 만족하면서 분산 시스템을 구축하기는 어려워서 CAP 정리가 나왔다. 일반적으로 분산 시스템에서는 다음 세가지를 동시에 충족시킬 수 없어 하나가 희생될 수 있다. CAP 정리 : 일관성, 가용성, 분단내성 NoSQL 데이터베이스의 일부는 CAP 정리의 일관성이나 가용성 중 하나를 선택한다. 즉, 일관성을 우선하고 가용성을 포기하면 단시간의 장애 발생을 수용하는 것이고, 가용성을 우선하고 일관성을 포기하는 것은 오래된 데이터를 읽을 수 있는 것이다. 그 중에서도 결과 일관성이란, ‘써 넣은 데이터를 바로 읽을 수 있다고는 말할 수없다’ 이다. 와이드 칼럼 스토어KVS 를 발전시켜, 2개 이상의 임의의 키에 데이터를 저장할 수 있도록 한 것이다.ex ) Google Cloud Bigtable, Apache HBase, Apache Cassandra하나의 테이블에 가로와 세로의 2차원에 데이터를 쓸 수 있도록 한 것이 특징이다. 예를 들어, Apache Cassandra 를 살펴보자. CQL내부적으로 데이터 저장소로 와이드 칼럼 스토어를이용하면서, CQL 이라는 높은 수준의 쿼리 언어가 구현되어 있다.SQL 동일한 감각으로 테이블을 조작할 수 있다 구조화된 데이터만 취급먼저 테이블의 스키마를 결정할 필요가 있기 때문에, 구조화 데이터만 취급한다. 분산 아키텍쳐P2P 형의 분산 아키텍쳐를 갖고 있으며, 지정한 키에 의해 결정한 노드에 해당 키와 관련된 모든 값을 저장한다.사용자 id 를 키로 사용하는 경우, 그 사용자에 대한 기록은 하나의 노드에 모이고 그 노드 안에서 쿼리가 실행된다.따라서 다수의 독립적인 키가 있는 경우에 처리를 잘 분산 할 수 있다. 와이드 칼럼 스토어에도 데이터를 집계하는 데는 적합하지 않다. 집계를 위해서는 분산된 모든 노드에서 데이터를 모아야하기 때문이다. Hive, Presto, Spark 등의 쿼리 엔진을 이용해 데이터를 추출해야한다. 도큐먼트 스토어와이드 칼럼 스토어가 성능 향상을 목표로 하는 반면, 도큐먼트 스토어는 데이터 처리읭 유연성을 목적으로 한다. 구체적으로는, JSON 처럼 복잡한 스키마리스 에이터를 그대로의 형태로 저장하고 쿼리를 실행할 수 있도록 한다.물론 간단한 분산 KVS도 JSON 텍스트로 저장할 수 있다. 하지만, 그에 대한 복작한 쿼리를 실행할 수 없다. 도큐먼트 스토어의 장점은, 스키마를 정하지 안혹 데이터 처리를 할수 잇다는 것이다. 그래서 외부에서 들여온 데이터를 저장하는데 특히 적합하다. 예를 들어, MongoDB를 살펴보자. 여러 노드에 데이터를 분산할 수 있지만, 그 자체는 대량의 데이터를 집계하는데 적합하지 않다. 데이터 분석이 목정니 경우 역시 쿼리 엔진으로부터 접속하는 등 데이터를 추출할 필요가 있다. 검색 엔진NoSQL 데이터베이스와는 성격이 다르지만, 저장된 데이터를 쿼리로 찾아낸다는 점에서는 유사한 부분이 있다. 특히 텍스트 데이터 및 스키마리스 데이터를 집계하는데 자주 사용된다. 검색 엔진의 특징은 텍스트 데이터를 전문 검색하기 위해 역색인을 만드는 부분이다. 따라서, 기록하는 시스템 부하 및 디스크 소비량은 커지지만, 키워드 검색이 고속화된다. 검색 엔진은 텍스트 데이터를 검색하기 위해 역색인을 만든다. 즉, 텍스트에 포함된 단어를 분해하고 어떤 단어가 어떤 레코드에 포함되어 있는가에 대한 인덱스를 먼저 만들어서 검색을 고속화한다. 예전이라면, 검색 엔진을 사용하지 않고도 전체 스캔을 하는것은 생각할 수 없었지만, 빅데이터 기술의 발전으로 그것도 가능하다. 예를들어, Google BigQuery 를 사용하면 대량의 계산 자원을 이용해 몇 초 만에 빅데이터의 전체 스캔이 가능하다. 쿼리를 실행시킬 때마다 모든 데이터를 로드하기 때문에 매우 비효율적이지만, 실행 빈도가 높지 않다면 문제가 없다. 검색엔진은 데이터의 집계에 적합하며, 민첩성이 요구되는 용도에 최근의 데이터를 보기위해 사용된다. 장기적인 데이터를 축적하기 보다, 실시간 집계 시스템의 읠부로 이용된다. 예를 들어, 메세지가 배송된 데이터를 분산 스토리지에 저장하고, 같은 데이터를 검색 엔진에 전송해 실시간성이 높은 데이터 처리를 위해 활용된다. 에를들어, Elasticsserach 가 있다. 임의의 JSON 데이터를 저장할수 있어서 도큐먼트 스토어와 비슷하지만, 아무것도 지정하지 않으면ㅌ 모든필드에 색인이 만들어진다. Splunk 도 있다. 자신하는 분야는 비정형 데이터로, 주로 웹서버나 네트워키 기기 등으로부터 출력되는 로그 파일이나 JSON 파일으 다루어 텍스트 처리를 해야만 분석할 수 잇는 데이터이다.에를 들어, 검색 엔진이므로 키워드를 입력하면 그것을 포함하는 로그를 찾을 수 있다. 최근의 데이터부터 순서대로 검색되므로 매일 발생하는 각종 이벤트를 빠르게 찾거나 보고서 작성에 유용하다. 빅데이터를 지탱하는 기술 &lt;니시다 케이스케&gt;","link":"/2020/01/02/big-data-chapter4/"},{"title":"[빅데이터] 1장_빅데이터를 위한 새로운 패러다임","text":"1.1 이 책의 구성이론을 다루는 장과 사례를 다루는 장으로 나뉜다. 이론을 다루는 장은 빅데이터 시스템을 구축하는 방법을 다루고, 사례를 다루는 장에서는 이론을 구체적인 도구에 연관시킨다. 1.2 전통적인 데이터베이스를 사용해 확장하기간단한 웹 분석 어플리케이션을 개발한다고 하자. 고객의 웹 페이지는 페이지뷰가 발생할 때마다 애플리케이션의 웹서버에 URL 정보를 보내야한다. 웹 서버는 데이터베이스에 페이지뷰에 해당하는 row 의 값을 증가시킨다. 이제 애플리케이션에 개선되며 어떤 문제가 생기는지 살펴본다. 1.2.1 큐를 사용해 확장하기백엔드의 데이터베이스가 부하를 견디지 못해 페이지 뷰를 증가시키는 쓰기 요청을 신속히 처리하지 못해 타임 아웃이 나고 있다고 하자.웹 서버가 데이터베이스에 직접 접근하도록 하는 대신, 웹 서버와 데이터베이스 사이에 큐를 넣는다. 그래서, 페이지뷰 이벤트를 받을 때마다 이벤트는 큐에 추가된다. 그리고, 큐에서 한 번에 100개씩 이벤트를 꺼내 하나의 데이터베이스 갱신 요청으로 일괄 처리하는 작업자 프로세스를 추가한다. 1.2.2 데이터베이스를 샤딩하여 확장하기이 웹 분석 애플리케이션이 계속 인기가 높아져, 데이터베이스에 과부하가 다시 걸렸다고 하자. 기존의 작업자 프로세스로는 쓰기 요청을 감당할 수 없어 갱신을 병렬 처리 하기 위해 작업자 프로세스의 수를 늘렸보았지만 도움이 되지 않았다.그래서, 데이터베이스 서버를 여러 대 사용하고 테이블을 여러 서버에 분산시키는 수평 분할, 또는 샤딩이라고 불리는 방법을 사용한다. 즉, 각 서버는 전체 테이블의 일부를 가지는 것이다. 쓰기 부하를 여러 서버, 즉 샤드로 분산 시키게 되는 것이다.이 애플리케이션의 인기가 높어져, 데이터베이스를 더 많은 샤드로 나누었다고 하자. 샤드 개수가 변경되어서 기존의 애플리케이션 코드에도 반영을 해야하고 이것을 깜빡하면 의도하지 않은 샤드에 기록된다. 1.2.3 내결함성 문제 발생 시작어쨌든 샤드를 늘렸는데, 이제 데이터베이스 장비에서 디스크 장애가 발생하는 상황이 왔다. 디스크 장애가 발생한 장비가 다운된 동안엔 그 디스크에 저장된 데이터를 사용할 수 없다. 해결책으로는, 큐 / 작업자 시스템을 수정해서, 사용 불능 상태의 샤드로 들어오는 증가 이벤트는 별도의 대기 큐에 넣고 이를테면 5분 마다 한 번씩 큐의 쌓여 있는 이벤트를 일괄 처리한다. 데이터베이스의 자체 복제 기능을 사용해 마스터가 다운됐을 때 백업으로 사용할 수 있는 슬레이브를 각 샤드에 추가한다. 슬레이브는 쓰기가 불가능하지만, 적어도 고객이 애플리케이션 상태를 조회할 수 있도록은 한다. 1.2.4 데이터 오염 문제큐 / 작업자 코드를 수정하는 도중, 실수로 모든 URL 에 대한 페이지 뷰를 1이 아니라 2씩 증가 시키는 버그를 만들었다고 하자. 데이터가 오염된다. 1.2.5 어디서부터 잘못된 건가 ?여러분이 사용하는 데이터베이스는 스스로 데이터가 어떻게 분산되어 있는지 모른다. 이런 복잡함이 모두 데이터베이스 운영 작업과, 애플리케이션 코드 개발 작업에 더해진다.시스템이 복잡해질수록 실수할 가능성은 커진다. 인적 내결함성 (human fault-tolerance) 는 필수 사항이다. 1.2.6 빅데이터 기술이 어떻게 되움이 되는가 ?빅데이터용 데이터베이스 및 계산 시스템은 데이터 어떤 식으로 분산되어 있는지를 자체적으로 알고 있다. 그래서, 샤딩이나 복제본 생성 작업을 알아서 처리한다.또 다른 핵심 기술은, 데이터를 변경 불가 형태로 만든다는 것이다. 정상 데이터를 파괴하지 않아, 전통적인 데이터베이스보다 강력한 human fault-tolerance 을 제공한다. 1.3 NoSQL 은 만병 통치약이 아니다하둡과 같은 대용량 계산 시스템은, 대용량 일괄 처리식 계산은 병렬로 처리할 수 있지만 계산의 latency 가 오래 걸린다.카산드라 같은 NoSQL 데이터베이스는 SQL 보다 훨씬 제한된 모델을 제공해서 확작성을 얻는다. 하지만, 이러한 제한된 데이터 모델에 애플리케이션을 끼워 넣는 것은 매우 복잡할 수 있다. 그리고 가변성을 전제로 하기 때문에 인적 내결함성을 갖추지 못하고 있다.이 도구들을 현명하게 잘 결합하면 인적 내결함성을 갖추고 복잡성을 최소하해 확장성 있는 시스템을 만들 수 있다. 1.4 기본 원칙데이터 시스템은 여러 조각 정보들을 조합해서 응답을 만든다. 예를 들어, 은행 계좌 잔고는 그 계좌에서 발생한 모든 거래에 대한 정보를 바탕으로 만들어진다. 더 중요한 것은, 모든 정보의 조각들이 동등한 성격이 아니라는 것이다. 어떤 정보는 다른 정보로부터 유래된다. 은행 계좌 잔고는 거래 내력을 가지고 만들어진다.정보가 만들어진 재료가 되는 원래의 정보를 거꾸로 추적해가면 결국 다른 어떤 정보로부터도 파생되지 않은 정보에 다다른다. 이 정보를 데이터라고 한다. 데이터 시스템을 정의하면 다음과 같다. 데이터로 할 수 있는 모든 일은 현재 갖고 있는 모든 데이터를 입력으로 받는 함수로 표현할 수 있다. 1query = function(all data) 1.5 빅데이터 시스템에 요구되는 속성 견고성과 내결함성복잡성을 회피해서 시스템에 대해 쉽게 생각할 수 있도록 하는 것도 빅데이터 시스템을 견고하게 만다는 작업이다. 그리고 빅데이터 시스템의 핵심에 불변성과 재계산 체계를 구축해놓으면, 복구 매커니즘이 쉽고 간결해져 사람의 실수에 대한 회복력을 지니게 된다. 짧은 읽기 / 갱신 지연 시간시스템의 견고성을 해치지 않고 짧은 읽기 / 갱신 지연 시간을 얻을 수 있어야한다. 확장성데이터나 부하가 늘어났을 때 시스템에 자원을 더 투입하는 것만으로 원래의 성능을 유지할수 있는 능력이다. 일반성일반적인 시스템은 폭넓은 분야의 애플리케이션에 쓰일 수 있다. 유연성대규모 데이터 이전을 용이하게 만다는 것은 시스템에 유연성을 부여하는 방법 중 하나이다. ad hoc query데이터에 대해 즉석 질의를 수행하는 것은 중요하다. 최소한의 유지 보수유지보수를 최소화하기 위해, 가능하면 구현 복잡도를 낮게 만들어주는 구성 요소가 필요하다. 디버깅 가능성빅데이터 시스템은 뭔가 잘못되었을 때 디버깅하는 데 필요한 정보를 제공해야한다. 1.6 완전 증분 아키턱쳐의 문제점완전 증분 아키턱쳐의 특징은, 데이터베이스를 읽고 쓴다는 것과 새로운 데이터가 들어왔을 때 데이터베이스의 상태를 증분식으로 변경한다는 것이다. 예를 들어, 페이지뷰를 셀 때 새로운 페이지뷰가 발생할 때마다 해당 URL 의 페이지 뷰 수에 1을 더한다.이제 완전 증분 아키텍처로 인해 생기는 일반적인 복잡성을 살펴본다. 1.6.1 운영 복잡성읽기 / 쓰기를 지원하는 데이터베이는, 디스크 색인이 증분식으로 추가 및 변경되기 때문에 색인 일부가 사용되지 않은채로 남는다. 이들 미사용 영역은 공간만 차지할 뿐이고 디스크를 다 채워버리는 것을 막기 위해 회수되어야한다. 색인이 필요 없을 때 바로 회수하는 것은 너무 비용이 비싸기 때문에, 미사용 영역이 차지하는 공간은 가끔 실행되는 압밀화 과정을 통해 큰 단위로 회수된다.서버는 압밀화를 수행하는 동안 CPU 와 디스크에 상당한 부담을 주게 되어 수행중에는 장비의 성능이 극적으로 떨어진다. 만약 동시에 너무 많은 장비가 압밀화를 수행하면 그들이 담당하고 있던 부하는 클러스터에 있는 다른 장비에 의해 처리되어야하고 이는 잠재적으로 클러스터의 나머지 부분에 과부하를 유발하여 전체 클러스터에 장애가 발생할 수 있다.압밀화를 잘 관리하려면 한 번에 영향을 받는 노드가 너무 많아지지 않게 각 노드의 스케쥴링을 잡아줘야 한다. 운영 담당 직원이 처리할 수 있게 할 수 있지만, 어떤 성격의 복잡성이든 가장 좋은 대처 방법은 그 복잡성 자체를 아예 제거하는 것이다.온라인 압밀화에 신경써야하는것은 완전 증분 아키텍쳐에 내재된 복잡성이다. 1.6.2 최종적 일관성을 달성할 때 수반되는 극심한 복잡성고가용성 시스템은 장비에 장애가 발생하거나 네트워크에 부분적인 장애가 발생할 때도 질의와 갱신을 실행할수 있게 한다. 일관성이라는 키워드와 직접 경쟁한다. CAP 정리에 의하면, 네트워크가 분단된 상황에서는 같은 시스템 안에서 고가용성과 일관성을 동시에 달성할 수 없다고 한다. 그래서, 고가용성 시스템에서는 네트워크 분단이 발생하면 오래된 결과를 반환하는 경우도 있다.네트워크 분단이 해소되면, 고가용성 시스템이 언젠가는 일관성 있는 결과를 반환하도록 하려면 (== 최종적 일관성), 애플리케이션의 도움이 필요하다. 예를 들어, 데이터베이스에 숫자를 저장하고 개수를 증가 시키는 이벤트를 받을 때마다 그 숫자의 값을 증가시키는 것이다. 이 경우, 네트워크 분단이 발생하면 대량의 데이터 손실이 발생할 수 있다.그 원인은, 분산 데이터베이스는 모든 정보가 저장된 복제본을 여러 개 유지함으로써 고가용성을 얻고 있기 때문이다. 10을 저장하고 있는 두 대의 복제 서버가 있을 때 네트워크 분단이 발생했다고 해보자. 첫 번째 복제서버에서는 2가 증가했고, 두번째 서버에서는 1이 증가했다. 각각 12와 11을 저장하고 있는 이 서버들의 상태를 합쳐야할 때 어떤 값을 써야할까? 정답은 13 이지만, 12와 11을 봐서는 알 수 없다. 상태가 달라지기 전에 11을 저장하고 이있을 수도 있고 0을 저장하고 있을 수도 있다.고가용성을 갖춘 상태에서 개수를 올바르게 세려면, 개수만 저장하는 것으로 부족하다. 서로 달라지는 값을 합치는데 적합한 자료구조를 사용해야하고 네트워크 분단이 해소되었을 때 올바른 값을로 수정하는 코드를 구현해야한다. 단순한 개수를 저장하는 것인데, 이렇게 복잡하다. 1.6.3 인적 내결함성 결여증분 시스템에 데이터베이스에 저장된 상태를 지속적으로 변경한다는 것은 실수로 데이터베이스의 상태를 바꿀 수 있는 것을 의미한다. 실수는 불가피하기 때문에 언젠가 오염될 수 있다.이를 해결하기 위해, 애프리케이션이 데이터베이스를 직접 갱신하는 동기식 아키텍쳐 말고, 이벤트를 큐에 모아 두었다가 백그라운드로 데이터베이스를 갱신하는 비동기식 아키텍쳐를 사용하면 해결할 수 있다. 모든 이벤트를 저장해 놓았기 때문에 사람이 실수로 데이터베이스를 오염시켜도 이벤트 저장소를 참조해 데이터베이스를 올바른 상태로 되돌릴 수 있다. 1.7 람다 아키텍쳐람다 아키텍쳐의 핵심 아이디어는 빅데이터 시스템을 일련의 계층을로 구축하는 것이다 : 속도 계층 / 서빙 계층 / 일괄 처리 계층모든 것은 다음 식으로부터 시작한다. 1query = function(all data) 하지만, 너무 많은 양의 자원이 소모되며 불합리하게 많은 비용이 든다. 누군가의 현재 위치를 찾을 때마다 페타바이트의 데이터 집합으 읽어야된다고 생각해보자.가장 쉬운 대안은, 사전 계산하는 것이다. 질의 함수를 사전 계산한 결과를 batch view (일괄 처리 뷰) 라고 한다. 12batch view = function(all data)query = function(batch view) 모든 데이터에 대해 함수를 실행해서 일괄처리 뷰를 생성해 놓는다. 그 후 어떤 질의의 결과가 필요할 때 일괄 처리 뷰에 대해 함수를 실행한다.일괄처리 뷰를 생성할 때는 모든 데이터에 대해 함수를 실행해야하므로 그 시간이 오래 걸린다. 일괄처리 뷰 생성이 끝나면 일괄처리 뷰에 없는 데이터가 그동안 쌓였을 것이고, 질의는 몇 시간 전의 결과를 반환한다. 이 문제를 고치는 방법을 곧 설명한다. 1.7.1 일괄처리 계층일과처리 계층은 마스터 복제본 ( 거대한 양의 레코드 목록 ) 을 저장하며 그 마스터 데이터 집합에 대한 일괄처리 뷰를 사전 계산한다.일과처리 계층은은 두 가지를 할 수 있어야한다. 불변성을 지니며 증가만 하는 마스터 데이터 집합을 저장 그 데이터 집합에 대해 임의의 함수를 계산 123function runBatchLayer() : while(true) : recomputeBatchViews() 일괄처리 계층은 while(tue) 루프 내에서 실행되며 지속적으롤 일괄처리 뷰를 만들어낸다. 1.7.2 서빙 계층서빙 계층은 일괄처리 뷰를 로딩해서 무작위 읽기를 수행할 수 있도록 하는 특수한 분산 데이터베이스이다. 새로운 일괄 처리 뷰가 생기면 서빙 계층은 자동으로 일괄처리 뷰를 교체해서 더 새로운 결과를 얻을 수 있도록 한다.일괄 갱신과 무작위 읽기를 모두 지원한다. 주목할 점은, 무작위 쓰기는 지원할 필요가 없다. 데이터베이스에서 대부분의 복잡성은 무작위 쓰기에 의해 유발되므로 이 점은 아주 중요하다. 1.7.3 속도 계층속도 계층은 애플리케이션에 필요한 만큼 빠르게 새로운 데이터가 질의 함수에 반영되로록 보장한다. 일괄처리 계층은 한 번에 모든 데이터를 대상으로 하지만, 속도 계층은 최근 데이터만을 대상으로 한다. 새로운 데이터를 받을 때마다 실시간 뷰를 갱신한다.즉, 람다 아키텍쳐는 다음과 같다. 123batch view = function(all data)realtime view = function(realtime view, all data)query = function(batch view, realtime view) 속도 계층은 무작위 읽기와 무작위 쓰기를 지원하는 데이터베이스를 사용한다. 무작위 쓰기를 지원하기 때문에 다른 계층의 데이터베이스보다 복잡하다.하지만, 람다 아키텍쳐에서는 데이터가 일괄처리 계층을 거쳐 서빙 계층에 도착하면 실시간 뷰에 있던 해당 데이터의 결과는 더 이상 필요없어진다. 즉, 실시간 뷰가 필요없어지면 버릴 수 있다. 이것이 복잡성 고립이다. 그 처리 결과가 그냥 일시적으로 쓰이고 마는 계층에만 복잡성이 가해진다는 것이다.일괄 처리 계층에서는 정확한 결과를 얻는 알고리즘을 사용하고, 속도 계층에서는 근사 알고리즘 ( ex : 하이퍼로그로그 ) 을 사용하는 유연성을 얻는다. 일괄 처리 계층은 속도 계층을 무효화하므로 근사치는 정확한 값으로 고쳐지게 된다. 시스템은 최종적 정확성 이라는 속성을 지니게 된다. 빅데이터, 람다 아키텍처로 알아보는 실시간 빅데이터 구축의 핵심 원리와 기법 &lt;네이선 마츠, 제임스 워렌&gt;","link":"/2020/02/25/bigdata-chapter-01/"},{"title":"[gRPC 시작에서 운영까지] 3장_gRPC 통신 패턴","text":"gRPC 기반 애플리케이션에서 사용되는 네 가지 통신 패턴을 정리한다. Unary RPC Server Streaming RPC Client Streaming RPC Bidirectional Streaming RPC Unary RPC 위 방식이 Unary RPC 패턴을 따른 것이다.클라이언트는 orderId 로 단일 요청을 보내고, 서비스는 주문 정보가 포함된 단일 응답을 돌려준다.이 패턴을 구현해보자. Service우선, 프로토콜 버퍼를 사용해 아래와 같이 서비스를 정의한다. 1234567891011121314151617syntax = &quot;proto3&quot;;import &quot;google/protobuf/wrappers.proto&quot;;package ecommerce;service OrderManagement { rpc getOrder(google.protobuf.StringValue) returns (Order);}message Order { string id = 1; repeated string items = 2; // 한 번 이상 반복되는 필드를 나타냄. 즉, 하나의 주문 메세지는 여러 아이템이 있을 수 있음. string description = 3; float price = 4; string destination = 5;} ServergRPC 서비스 정의 프로토 파일을 사용해서 서버 스켈레톤 코드를 생성한 뒤에, 아래와 같이 getOrder 메서드의 로직을 구현할 수 있다. 1234567891011121314151617public class OrderMgtServiceImpl extends OrderManagementGrpc.OrderManagementImplBase { @Override public void getOrder(StringValue request, StreamObserver&lt;OrderManagementOuterClass.Order&gt; responseObserver) { OrderManagementOuterClass.Order order = orderMap.get(request.getValue()); if (order != null) { System.out.printf(&quot;Order Retrieved : ID - %s&quot;, order.getId()); responseObserver.onNext(order); responseObserver.onCompleted(); } else { logger.info(&quot;Order : &quot; + request.getValue() + &quot; - Not found.&quot;); responseObserver.onCompleted(); } // ToDo Handle errors // responseObserver.onError(); }} Client이제, getOrder 메서드를 원격으로 호출하는 클라이언트 로직을 구현하자.사용하는 언어에 대한 코드를 생성해 클라이언트 스텁을 만들고, 스텁을 사용해서 서비스를 호출한다. 123456789101112public class OrderMgtClient { public static void main(String[] args) { ManagedChannel channel = ManagedChannelBuilder.forAddress(&quot;localhost&quot;, 50051).usePlaintext().build(); OrderManagementGrpc.OrderManagementBlockingStub stub = OrderManagementGrpc.newBlockingStub(channel); OrderManagementGrpc.OrderManagementStub asyncStub = OrderManagementGrpc.newStub(channel); // Get Order StringValue id = StringValue.newBuilder().setValue(&quot;101&quot;).build(); OrderManagementOuterClass.Order orderResponse = stub.getOrder(id); }} Server Streaming RPC 서버가 클라이언트의 요청을 받은 후에, 일련의 응답을 다시 보낸다.모든 서버 응답을 보낸 뒤에는 서버가 서버의 상태 정보를 후행 메타데이터로 클라이언트에 전송해서 스트림의 끝을 알린다.OrderManagement 서비스가 일치하는 모든 주문을 한 번에 발송하는 것이 아니라, 주문을 발견하는 대로 보낼 수 있는 기능을 구현해보자. Service우선, 프로토콜 버퍼를 사용해 아래와 같이 서비스 정의를 해야한다. 1234567891011121314151617syntax = &quot;proto3&quot;;import &quot;google/protobuf/wrappers.proto&quot;;package ecommerce;service OrderManagement { rpc searchOrders(google.protobuf.StringValue) returns (stream Order);}message Order { string id = 1; repeated string items = 2; string description = 3; float price = 4; string destination = 5;} Server그리고 아래와 같이, searchOrders 메서드의 로직을 구현한다. 1234567891011121314151617181920public class OrderMgtServiceImpl extends OrderManagementGrpc.OrderManagementImplBase { @Override public void searchOrders(StringValue request, StreamObserver&lt;OrderManagementOuterClass.Order&gt; responseObserver) { for (Map.Entry&lt;String, OrderManagementOuterClass.Order&gt; orderEntry : orderMap.entrySet()) { OrderManagementOuterClass.Order order = orderEntry.getValue(); int itemsCount = order.getItemsCount(); for (int index = 0; index &lt; itemsCount; index++) { String item = order.getItems(index); if (item.contains(request.getValue())) { logger.info(&quot;Item found &quot; + item); responseObserver.onNext(order); // 스트림을 통해 일치하는 주문을 보냄. break; } } } responseObserver.onCompleted(); }} Client그리고 아래와 같이, searchOrders 메서드를 원격으로 호출하는 클라이언트 로직을 구현하자. 12345678910111213141516public class OrderMgtClient { public static void main(String[] args) { ManagedChannel channel = ManagedChannelBuilder.forAddress(&quot;localhost&quot;, 50051).usePlaintext().build(); OrderManagementGrpc.OrderManagementBlockingStub stub = OrderManagementGrpc.newBlockingStub(channel); OrderManagementGrpc.OrderManagementStub asyncStub = OrderManagementGrpc.newStub(channel); // Search Orders StringValue searchStr = StringValue.newBuilder().setValue(&quot;Google&quot;).build(); Iterator&lt;OrderManagementOuterClass.Order&gt; matchingOrdersItr; matchingOrdersItr = stub.searchOrders(searchStr); while (matchingOrdersItr.hasNext()) { OrderManagementOuterClass.Order matchingOrder = matchingOrdersItr.next(); } }} Client Streaming RPC 클라이언트가 하나의 요청이 아니라, 여러 메세지를 서버로 보내고 서버는 클라이언트에게 단일 응답을 보낸다.이 때, 서버는 클라이언트가 모든 메세지를 수신해서 응답을 보낼 때 까지 기다릴 필요는 없다.클라이언트가 updateOrders 메서드로 여러 주문을 업데이트 한다고 하자. Service우선, 프로토콜 버퍼를 사용해 아래와 같이 서비스 정의를 해야한다. 1234567891011121314151617syntax = &quot;proto3&quot;;import &quot;google/protobuf/wrappers.proto&quot;;package ecommerce;service OrderManagement { rpc updateOrders(stream Order) returns (google.protobuf.StringValue);}message Order { string id = 1; repeated string items = 2; string description = 3; float price = 4; string destination = 5;} Server그리고 아래와 같이, updateOrders 메서드의 로직을 구현한다. 12345678910111213141516171819202122232425262728293031public class OrderMgtServiceImpl extends OrderManagementGrpc.OrderManagementImplBase { @Override public StreamObserver&lt;OrderManagementOuterClass.Order&gt; updateOrders(StreamObserver&lt;StringValue&gt; responseObserver) { return new StreamObserver&lt;OrderManagementOuterClass.Order&gt;() { StringBuilder updatedOrderStrBuilder = new StringBuilder().append(&quot;Updated Order IDs : &quot;); @Override public void onNext(OrderManagementOuterClass.Order value) { if (value != null) { orderMap.put(value.getId(), value); updatedOrderStrBuilder.append(value.getId()).append(&quot;, &quot;); logger.info(&quot;Order ID : &quot; + value.getId() + &quot; - Updated&quot;); } } @Override public void onError(Throwable t) { logger.info(&quot;Order ID update error &quot; + t.getMessage()); } @Override public void onCompleted() { logger.info(&quot;Update orders - Completed&quot;); StringValue updatedOrders = StringValue.newBuilder().setValue(updatedOrderStrBuilder.toString()).build(); responseObserver.onNext(updatedOrders); responseObserver.onCompleted(); } }; }} Client그리고 아래와 같이, updateOrders 메서드를 원격으로 호출하는 클라이언트 로직을 구현하자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class OrderMgtClient { public static void main(String[] args) { ManagedChannel channel = ManagedChannelBuilder.forAddress( &quot;localhost&quot;, 50051).usePlaintext().build(); OrderManagementGrpc.OrderManagementBlockingStub stub = OrderManagementGrpc.newBlockingStub(channel); OrderManagementGrpc.OrderManagementStub asyncStub = OrderManagementGrpc.newStub(channel); // Update Orders invokeOrderUpdate(asyncStub); } private static void invokeOrderUpdate(OrderManagementGrpc.OrderManagementStub asyncStub) { OrderManagementOuterClass.Order updOrder1 = OrderManagementOuterClass.Order.newBuilder() .setId(&quot;102&quot;) .addItems(&quot;Google Pixel 3A&quot;).addItems(&quot;Google Pixel Book&quot;) .setDestination(&quot;Mountain View, CA&quot;) .setPrice(1100) .build(); OrderManagementOuterClass.Order updOrder2 = OrderManagementOuterClass.Order.newBuilder() .setId(&quot;103&quot;) .addItems(&quot;Apple Watch S4&quot;).addItems(&quot;Mac Book Pro&quot;).addItems(&quot;iPad Pro&quot;) .setDestination(&quot;San Jose, CA&quot;) .setPrice(2800) .build(); OrderManagementOuterClass.Order updOrder3 = OrderManagementOuterClass.Order.newBuilder() .setId(&quot;104&quot;) .addItems(&quot;Google Home Mini&quot;).addItems(&quot;Google Nest Hub&quot;).addItems(&quot;iPad Mini&quot;) .setDestination(&quot;Mountain View, CA&quot;) .setPrice(2200) .build(); final CountDownLatch finishLatch = new CountDownLatch(1); StreamObserver&lt;StringValue&gt; updateOrderResponseObserver = new StreamObserver&lt;StringValue&gt;() { @Override public void onNext(StringValue value) { logger.info(&quot;Update Orders Res : &quot; + value.getValue()); } @Override public void onError(Throwable t) { } @Override public void onCompleted() { logger.info(&quot;Update orders response completed!&quot;); finishLatch.countDown(); } }; StreamObserver&lt;OrderManagementOuterClass.Order&gt; updateOrderRequestObserver = asyncStub.updateOrders(updateOrderResponseObserver); updateOrderRequestObserver.onNext(updOrder1); updateOrderRequestObserver.onNext(updOrder2); updateOrderRequestObserver.onNext(updOrder3); updateOrderRequestObserver.onNext(updOrder3); if (finishLatch.getCount() == 0) { logger.warning(&quot;RPC completed or errored before we finished sending.&quot;); return; } updateOrderRequestObserver.onCompleted(); // Receiving happens asynchronously try { if (!finishLatch.await(10, TimeUnit.SECONDS)) { logger.warning(&quot;FAILED : Process orders cannot finish within 10 seconds&quot;); } } catch (InterruptedException e) { e.printStackTrace(); } }} BidirectionalStreaming RPC 클라이언트는 메세지 스트림으로 서버에 요청하고, 서버는 메세지 스트림으로 응답한다.클라이언트는 연속된 주문 스트림을 전송하고, 배송 위치를 기준으로 주문들을 결합하여 발송으로 처리하는 주문 처리 기능을 구현하자. Service우선, 프로토콜 버퍼를 사용해 아래와 같이 서비스 정의를 해야한다. 1234567891011121314151617181920212223syntax = &quot;proto3&quot;;import &quot;google/protobuf/wrappers.proto&quot;;package ecommerce;service OrderManagement { rpc processOrders(stream google.protobuf.StringValue) returns (stream CombinedShipment);}message Order { string id = 1; repeated string items = 2; string description = 3; float price = 4; string destination = 5;}message CombinedShipment { string id = 1; string status = 2; repeated Order ordersList = 3;} Server그리고 아래와 같이, processOrders 메서드의 로직을 구현한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class OrderMgtServiceImpl extends OrderManagementGrpc.OrderManagementImplBase { // Bi-di Streaming @Override public StreamObserver&lt;StringValue&gt; processOrders(StreamObserver&lt;OrderManagementOuterClass.CombinedShipment&gt; responseObserver) { return new StreamObserver&lt;StringValue&gt;() { int batchMarker = 0; @Override public void onNext(StringValue value) { logger.info(&quot;Order Proc : ID - &quot; + value.getValue()); OrderManagementOuterClass.Order currentOrder = orderMap.get(value.getValue()); if (currentOrder == null) { logger.info(&quot;No order found. ID - &quot; + value.getValue()); return; } // Processing an order and increment batch marker to batchMarker++; String orderDestination = currentOrder.getDestination(); OrderManagementOuterClass.CombinedShipment existingShipment = combinedShipmentMap.get(orderDestination); if (existingShipment != null) { existingShipment = OrderManagementOuterClass.CombinedShipment.newBuilder(existingShipment).addOrdersList(currentOrder).build(); combinedShipmentMap.put(orderDestination, existingShipment); } else { OrderManagementOuterClass.CombinedShipment shipment = OrderManagementOuterClass.CombinedShipment.newBuilder().build(); shipment = shipment.newBuilderForType() .addOrdersList(currentOrder) .setId(&quot;CMB-&quot; + new Random().nextInt(1000)+ &quot;:&quot; + currentOrder.getDestination()) .setStatus(&quot;Processed!&quot;) .build(); combinedShipmentMap.put(currentOrder.getDestination(), shipment); } if (batchMarker == BATCH_SIZE) { // Order batch completed. Flush all existing shipments. for (Map.Entry&lt;String, OrderManagementOuterClass.CombinedShipment&gt; entry : combinedShipmentMap.entrySet()) { responseObserver.onNext(entry.getValue()); } // Reset batch marker batchMarker = 0; combinedShipmentMap.clear(); } } @Override public void onError(Throwable t) { } @Override public void onCompleted() { for (Map.Entry&lt;String, OrderManagementOuterClass.CombinedShipment&gt; entry : combinedShipmentMap.entrySet()) { responseObserver.onNext(entry.getValue()); } responseObserver.onCompleted(); } }; }} Client그리고 아래와 같이, updateOrders 메서드를 원격으로 호출하는 클라이언트 로직을 구현하자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class OrderMgtClient { public static void main(String[] args) { ManagedChannel channel = ManagedChannelBuilder.forAddress( &quot;localhost&quot;, 50051).usePlaintext().build(); OrderManagementGrpc.OrderManagementBlockingStub stub = OrderManagementGrpc.newBlockingStub(channel); OrderManagementGrpc.OrderManagementStub asyncStub = OrderManagementGrpc.newStub(channel); invokeOrderProcess(asyncStub); } private static void invokeOrderProcess(OrderManagementGrpc.OrderManagementStub asyncStub) { final CountDownLatch finishLatch = new CountDownLatch(1); StreamObserver&lt;OrderManagementOuterClass.CombinedShipment&gt; orderProcessResponseObserver = new StreamObserver&lt;OrderManagementOuterClass.CombinedShipment&gt;() { @Override public void onNext(OrderManagementOuterClass.CombinedShipment value) { logger.info(&quot;Combined Shipment : &quot; + value.getId() + &quot; : &quot; + value.getOrdersListList()); } @Override public void onError(Throwable t) { } @Override public void onCompleted() { logger.info(&quot;Order Processing completed!&quot;); finishLatch.countDown(); } }; StreamObserver&lt;StringValue&gt; orderProcessRequestObserver = asyncStub.processOrders(orderProcessResponseObserver); orderProcessRequestObserver.onNext(StringValue.newBuilder().setValue(&quot;102&quot;).build()); orderProcessRequestObserver.onNext(StringValue.newBuilder().setValue(&quot;103&quot;).build()); orderProcessRequestObserver.onNext(StringValue.newBuilder().setValue(&quot;104&quot;).build()); orderProcessRequestObserver.onNext(StringValue.newBuilder().setValue(&quot;101&quot;).build()); if (finishLatch.getCount() == 0) { logger.warning(&quot;RPC completed or errored before we finished sending.&quot;); return; } orderProcessRequestObserver.onCompleted(); try { if (!finishLatch.await(120, TimeUnit.SECONDS)) { logger.warning(&quot;FAILED : Process orders cannot finish within 60 seconds&quot;); } } catch (InterruptedException e) { e.printStackTrace(); } }} gRPC 시작에서 운영까지 &lt;카순 인드라시리, 다네쉬 쿠루푸&gt;","link":"/2020/12/26/grpc-patterns/"}],"tags":[],"categories":[{"name":"Algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"OS","slug":"os","link":"/categories/os/"},{"name":"JPA","slug":"jpa","link":"/categories/jpa/"},{"name":"OOP","slug":"oop","link":"/categories/oop/"},{"name":"Kafka","slug":"kafka","link":"/categories/kafka/"},{"name":"Big Data","slug":"big-data","link":"/categories/big-data/"},{"name":"TDD","slug":"tdd","link":"/categories/tdd/"},{"name":"Spring","slug":"spring","link":"/categories/spring/"},{"name":"Java","slug":"java","link":"/categories/java/"},{"name":"Git","slug":"git","link":"/categories/git/"},{"name":"Test Code","slug":"test-code","link":"/categories/test-code/"},{"name":"Redis","slug":"redis","link":"/categories/redis/"},{"name":"Container","slug":"container","link":"/categories/container/"},{"name":"gRPC","slug":"grpc","link":"/categories/grpc/"},{"name":"OAuth","slug":"oauth","link":"/categories/oauth/"},{"name":"Kotlin","slug":"kotlin","link":"/categories/kotlin/"},{"name":"GraphQL","slug":"graphql","link":"/categories/graphql/"},{"name":"Reactor","slug":"reactor","link":"/categories/reactor/"}]}