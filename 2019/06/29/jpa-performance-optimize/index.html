<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[자바 ORM 표준 JPA 프로그래밍] 15장_고급 주제와 성능 최적화 - Always Learning</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Always Learning"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Always Learning"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="JPA 를 사용하며 주의할 점과, 성능 최적화 내용을 정리한다.  트랜잭션 롤백트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다. 다음 경우를 보자.  엔티티를 조회해서 수정하는 중에 문제가 발생했다. 트랜잭션이 롤백된다. 데이터베이스의 데이터는 원래대로 복구된다. 수정된 객체는 영속성 컨텍스트에 그대로 남아있다.  그럼 어떻게 해야할까 ?"><meta property="og:type" content="blog"><meta property="og:title" content="[자바 ORM 표준 JPA 프로그래밍] 15장_고급 주제와 성능 최적화"><meta property="og:url" content="https://junhee-ko.github.io/2019/06/29/jpa-performance-optimize/"><meta property="og:site_name" content="Always Learning"><meta property="og:description" content="JPA 를 사용하며 주의할 점과, 성능 최적화 내용을 정리한다.  트랜잭션 롤백트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다. 다음 경우를 보자.  엔티티를 조회해서 수정하는 중에 문제가 발생했다. 트랜잭션이 롤백된다. 데이터베이스의 데이터는 원래대로 복구된다. 수정된 객체는 영속성 컨텍스트에 그대로 남아있다.  그럼 어떻게 해야할까 ?"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://junhee-ko.github.io/img/og_image.png"><meta property="article:published_time" content="2019-06-28T15:00:00.000Z"><meta property="article:modified_time" content="2021-07-17T07:08:50.865Z"><meta property="article:author" content="junhee.ko"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://junhee-ko.github.io/2019/06/29/jpa-performance-optimize/"},"headline":"[자바 ORM 표준 JPA 프로그래밍] 15장_고급 주제와 성능 최적화","image":["https://junhee-ko.github.io/img/og_image.png"],"datePublished":"2019-06-28T15:00:00.000Z","dateModified":"2021-07-17T07:08:50.865Z","author":{"@type":"Person","name":"junhee.ko"},"publisher":{"@type":"Organization","name":"Always Learning","logo":{"@type":"ImageObject","url":"https://junhee-ko.github.io/img/logo.svg"}},"description":"JPA 를 사용하며 주의할 점과, 성능 최적화 내용을 정리한다.  트랜잭션 롤백트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다. 다음 경우를 보자.  엔티티를 조회해서 수정하는 중에 문제가 발생했다. 트랜잭션이 롤백된다. 데이터베이스의 데이터는 원래대로 복구된다. 수정된 객체는 영속성 컨텍스트에 그대로 남아있다.  그럼 어떻게 해야할까 ?"}</script><link rel="canonical" href="https://junhee-ko.github.io/2019/06/29/jpa-performance-optimize/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Always Learning" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-28T15:00:00.000Z" title="6/29/2019, 12:00:00 AM">2019-06-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-17T07:08:50.865Z" title="7/17/2021, 4:08:50 PM">2021-07-17</time></span><span class="level-item"><a class="link-muted" href="/categories/jpa/">JPA</a></span></div></div><h1 class="title is-3 is-size-4-mobile">[자바 ORM 표준 JPA 프로그래밍] 15장_고급 주제와 성능 최적화</h1><div class="content"><p>JPA 를 사용하며 주의할 점과, 성능 최적화 내용을 정리한다. </p>
<h2 id="트랜잭션-롤백"><a href="#트랜잭션-롤백" class="headerlink" title="트랜잭션 롤백"></a>트랜잭션 롤백</h2><p>트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다. 다음 경우를 보자.</p>
<ol>
<li>엔티티를 조회해서 수정하는 중에 문제가 발생했다.</li>
<li>트랜잭션이 롤백된다.</li>
<li>데이터베이스의 데이터는 원래대로 복구된다.</li>
<li>수정된 객체는 영속성 컨텍스트에 그대로 남아있다.</li>
</ol>
<p>그럼 어떻게 해야할까 ? </p>
<ol>
<li>영속성 컨텍스트를 새로 생성해서 사용하거나</li>
<li>EntityManager.clear() 로 영속성 컨텍스트를 초기화해야한다.</li>
</ol>
<p>스프링에서는,</p>
<ol>
<li>트랜잭션당 영속성 컨텍스트의 경우 : 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료</li>
<li>OSIV 인 경우 : 트랜잭션을 롤백하면서 영속성 컨텍스트를 초기화</li>
</ol>
<h2 id="엔티티-비교"><a href="#엔티티-비교" class="headerlink" title="엔티티 비교"></a>엔티티 비교</h2><p>영속성 컨텍스트가 같을 때는, 다음 세 조건을 만족한다.</p>
<ol>
<li>identical : == 비교가 같음</li>
<li>equivalent : equals() 비교가 같음</li>
<li>DB equivalent : @Id 인 DB 식별자가 같음</li>
</ol>
<p>영속성 컨텍스트가 다를 때는, identical 비교에 실패한다.</p>
<h2 id="N-1-문제"><a href="#N-1-문제" class="headerlink" title="N+1 문제"></a>N+1 문제</h2><p>코드보 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="meta">@OneToMany(mappedBy = &quot;member&quot;, fetch = FetchType.EAGER)</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Order&gt; orders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;ORDERS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="keyword">private</span> Member member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같은 경우에, Member 하나를 다음 처럼 조회하면 즉시 로딩으로 설정한 주문 정보도 같이 조회한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em.find(Member.class, id);</span><br></pre></td></tr></table></figure>

<p>실행되는 SQL 은 다음과 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> M.<span class="operator">*</span>, O.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">MEMBER</span> M</span><br><span class="line"><span class="keyword">OUTER</span> <span class="keyword">JOIN</span> ORDERS O <span class="keyword">ON</span> M.ID<span class="operator">=</span>O.MEMBER_ID</span><br></pre></td></tr></table></figure>

<p>여기까지는 좋다. 문제는, 다음처럼, JPQL 을 사용할 때다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em.createQuery(<span class="string">&quot;select m from Member m&quot;</span>, Member.class).getResultList();</span><br></pre></td></tr></table></figure>

<p>실행되는 SQL 은 다음과 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">MEMBER</span></span><br></pre></td></tr></table></figure>

<p>회원 엔티티와 연관된 주문 컬렉션이 즉시 로딩으로 설정되어 있다. 그래서, 즉시 로딩하려고 다음 SQL 을 추가로 실행한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ORDERS <span class="keyword">WHERE</span> MEMBER_ID <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>조회된 회원이 100명이면, 위와 같은 쿼리가 100번 추가적으로 실행되는 것이다.</p>
<h3 id="지연-로딩과-N-1"><a href="#지연-로딩과-N-1" class="headerlink" title="지연 로딩과 N+1"></a>지연 로딩과 N+1</h3><p>결론부터 말하면, 지연 로딩의 경우에도 N+1 문제는 동일하게 발생한다.</p>
<p>지연로딩으로 설정하고 JPQL 로 회원들을 조회해보자. 지연 로딩이므로 회원들만 조회되기 때문에, N+1 문제는 여기서 발생하지 않는다.<br>하지만 다음 처럼, 회원이 100명이면 100명의 주문도 100번 조회된다. 이것이 문제다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Member m : members)&#123;</span><br><span class="line">  m.getOrders().size();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음 처럼,</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ORDERS <span class="keyword">WHERE</span> MEMBER_ID <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ORDERS <span class="keyword">WHERE</span> MEMBER_ID <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ORDERS <span class="keyword">WHERE</span> MEMBER_ID <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="Fetch-Join"><a href="#Fetch-Join" class="headerlink" title="Fetch Join"></a>Fetch Join</h3><p>N+1 문제를 해결할 수 있는 간단한 방법이다. fetch join 을 사용하면, 연관된 엔티티를 같이 조회한다.</p>
<p>fetch join 을 사용하는 JPQL 은 다음과 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectm <span class="keyword">from</span> <span class="keyword">Member</span> m <span class="keyword">join</span> <span class="keyword">fetch</span> m.orders</span><br></pre></td></tr></table></figure>

<p>실행되는 SQL 은 다음과 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> M.<span class="operator">*</span>, O.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">MEMBER</span> M</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> ORDERS O <span class="keyword">ON</span> M.ID<span class="operator">=</span>O.MEMBER_ID</span><br></pre></td></tr></table></figure>

<h2 id="읽기-전용-쿼리-성능-최적화"><a href="#읽기-전용-쿼리-성능-최적화" class="headerlink" title="읽기 전용 쿼리 성능 최적화"></a>읽기 전용 쿼리 성능 최적화</h2><p>영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관해서, 더 많은 메모리를 사용한다.<br>데이터를 단순히 조회만 하는 읽기 전용 쿼리의 경우에, 이와 같은 불필요한 메모리 사용이 필요없다.</p>
<h3 id="스칼라-타입으로-조회"><a href="#스칼라-타입으로-조회" class="headerlink" title="스칼라 타입으로 조회"></a>스칼라 타입으로 조회</h3><p>스칼라 타입으로 모든 타입 조회하면, 영속성 컨텍스트가 결과를 관리하지 않는다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> o.id, o.name, o.price <span class="keyword">from</span> <span class="keyword">Order</span> o</span><br></pre></td></tr></table></figure>

<h3 id="읽기-전용-쿼리-힌트-사용"><a href="#읽기-전용-쿼리-힌트-사용" class="headerlink" title="읽기 전용 쿼리 힌트 사용"></a>읽기 전용 쿼리 힌트 사용</h3><p>하이버네이트 전용 힌트인 org.hibernate.readOnly 를 사용하면, 영속성 컨텍스트는 스냅샷을 보관하지 않는다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypedQuery&lt;Order&gt; query = em.createQuery(<span class="string">&quot;select o from Order o&quot;</span>, Order.class);</span><br><span class="line">query.setHint(<span class="string">&quot;org.hibernate.readOnly&quot;</span>, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="읽기-전용-트랜잭션-사용"><a href="#읽기-전용-트랜잭션-사용" class="headerlink" title="읽기 전용 트랜잭션 사용"></a>읽기 전용 트랜잭션 사용</h3><p>다음 처럼 사용하면, 스프링 프레임워크가 하이버네이트 세션 (JPA Entity Manager 의 구현체) 의 플러쉬 모드를 MANUAL 로 설정한다.<br>그래서, 강제로 플러쉬를 호출하지 않는 한 플러쉬가 일어나지 않는다. 트랜잭션을 커밋해도 영속성 컨텍스트를 플러쉬 하지 않아서, 스냅샷 비교와 같은 무거운 로직이 수행되지 않는다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure>

<h3 id="트랜잭션-밖에서-읽기"><a href="#트랜잭션-밖에서-읽기" class="headerlink" title="트랜잭션 밖에서 읽기"></a>트랜잭션 밖에서 읽기</h3><p>트랜잭션을 사용하지 않아서, 플러쉬가 일어나지 않아 조회 성능이 향상된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br></pre></td></tr></table></figure>

<h2 id="배치-처리"><a href="#배치-처리" class="headerlink" title="배치 처리"></a>배치 처리</h2><p>수백만 건의 데이터를 배치 처리할 때, 엔티티를 계속 조회하면 영속성 컨텍스트에 많은 엔티티가 쌓인다.<br>그러면, 메모리 부족 오류가 발생할 것이다. 그래서, 적절한 단위로 영속성 컨텍스트를 초기화해아한다.</p>
<h3 id="등록-배치"><a href="#등록-배치" class="headerlink" title="등록 배치"></a>등록 배치</h3><p>100만건의 엔티티를 DB 에 저장한다고 해보자.<br>엔티티 100 건을 저장할 때마다 em.flush() 를 호출하고, em.clear() 할 수 있다.</p>
<h3 id="수정-배치"><a href="#수정-배치" class="headerlink" title="수정 배치"></a>수정 배치</h3><p>100만건의 데이터를 조회해서 수정한다고 해보자. 한 번에 메모리에 올려둘 수 없어서,</p>
<ol>
<li><p>paging<br>paging 처리 방법을 이용할 수 있다. 즉, 한 번에 100 건씩 페이징 쿼리로 조회하면서 엔티티를 수정하고 영속성 컨텍스트를 flush 하고 clear 한다.</p>
</li>
<li><p>cursor<br>cursor 를 이용할 수 있다. 하이버네이트는 scroll 이라는 이름으로 JDBC cursor 를 지원한다.</p>
</li>
</ol>
<h2 id="트랜잭션을-지원하는-쓰기-지연"><a href="#트랜잭션을-지원하는-쓰기-지연" class="headerlink" title="트랜잭션을 지원하는 쓰기 지연"></a>트랜잭션을 지원하는 쓰기 지연</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span>(member1); <span class="operator">/</span><span class="operator">/</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span>...</span><br><span class="line"><span class="keyword">insert</span>(member2); <span class="operator">/</span><span class="operator">/</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span>...</span><br><span class="line"><span class="keyword">insert</span>(member3); <span class="operator">/</span><span class="operator">/</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span>...</span><br><span class="line"><span class="keyword">insert</span>(member4); <span class="operator">/</span><span class="operator">/</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span>...</span><br><span class="line"><span class="keyword">insert</span>(member5); <span class="operator">/</span><span class="operator">/</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span>...</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>();</span><br></pre></td></tr></table></figure>

<p>네트워크 호출은 비용이 많이 드는 작업이다.<br>위의 경우에, SQL 을 직접 다루면 한 번의 커밋과 다섯 번의 insert SQL 로, 총 여섯 번의 데이터베이스 통신을 한다.<br>최적화 화려면 어떻게 해야할까 ? insert SQL 을 모아서 한 번에 데이터베이스에 보내면 된다.<br>JPA 는 flush 기능으로 이것이 가능하다.</p>
<h3 id="SQL-Batch"><a href="#SQL-Batch" class="headerlink" title="SQL Batch"></a>SQL Batch</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">em.persist(<span class="keyword">new</span> <span class="keyword">Member</span>()); <span class="operator">/</span><span class="operator">/</span> <span class="number">1</span></span><br><span class="line">em.persist(<span class="keyword">new</span> <span class="keyword">Member</span>()); <span class="operator">/</span><span class="operator">/</span> <span class="number">2</span></span><br><span class="line">em.persist(<span class="keyword">new</span> <span class="keyword">Member</span>()); <span class="operator">/</span><span class="operator">/</span> <span class="number">3</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Child());  <span class="operator">/</span><span class="operator">/</span> <span class="number">4</span></span><br><span class="line">em.persist(<span class="keyword">new</span> <span class="keyword">Member</span>()); <span class="operator">/</span><span class="operator">/</span> <span class="number">5</span></span><br><span class="line">em.persist(<span class="keyword">new</span> <span class="keyword">Member</span>()); <span class="operator">/</span><span class="operator">/</span> <span class="number">6</span></span><br><span class="line">em.persist(<span class="keyword">new</span> <span class="keyword">Member</span>()); <span class="operator">/</span><span class="operator">/</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>하이버네이트에서는, hibernate.jdbc.batch_size 속성의 값에 50 을 주면, 최대 50 건씩 모아서 SQL 배치를 실행한다. 그런데 주의할 점은, 같은 SQL 일 때만 유효하다.<br>예를 들어 위의 경우에, 1-3 을 모아서 SQL 배치 실행, 4 를 실행, 5-7 을 모아서 SQL 실행한다.</p>
<h3 id="식별자-생성-전략-IDENTITY"><a href="#식별자-생성-전략-IDENTITY" class="headerlink" title="식별자 생성 전략 IDENTITY"></a>식별자 생성 전략 IDENTITY</h3><p>엔티티의 식별자 생성 전략이 IDENTITY 이면, 쓰기 지연을 활용한 성능 최적화를 할 수 없다.<br>왜냐하면, 엔티티가 영속 상태가 되려면 식별자가 필요한데, 식별자를 구하려면 데이터베이스에 저장해야 구할 수 있어서 em.persist() 를 호출하면 바로 insert SQL 이 데이터베이스에 전달된다.</p>
<h2 id="DB-table-row-lock-time-최소화"><a href="#DB-table-row-lock-time-최소화" class="headerlink" title="DB table row lock time 최소화"></a>DB table row lock time 최소화</h2><p>트랜잭션을 지원하는 쓰기 지연의 본질적인 장점은, DB table row lock time 최소화이다.<br>영속성 컨텍스를 flush 하기 전까지는 데이터베이스에 로우에 락을 걸지 않기 떄문이다.<br>다음 로직을 보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update(<span class="keyword">member</span>); <span class="operator">/</span><span class="operator">/</span> UPDATE <span class="keyword">SQL</span> </span><br><span class="line">logicA();</span><br><span class="line">logicB();</span><br><span class="line"><span class="keyword">commit</span>();</span><br></pre></td></tr></table></figure>

<p>JPA 를 사용하지 않고 SQL 을 직접 다루면, update(member); 를 호출할 때 UPDATE SQL 이 실행되면서 DB table row 에 lock 을 건다.<br>이 lock 은 commit 을 호출될 때까지 유지된다. 그러면, 현재 수정 중인 데이터를 수정하려는 다른 트랜잭션은 lock 이 풀릴 때까지 기다려야한다.</p>
<p>JPA 는 commit() 에서 UPDATE SQL 을 실행하고 바로 트랜잭션을 커밋한다. 즉, 데이터베이스 락에 걸리는 시간을 최소화한다.<br>데이터베이스 락에 걸리는 시간을 최소화하면 뭐가 좋을까? 동시에 더 많은 트랜잭션을 처리할 수 있다.</p>
<hr>
<p>자바 ORM 표준 프로그래밍 &lt;김영한&gt;</p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/06/30/jpa-transaction-lock/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">[자바 ORM 표준 JPA 프로그래밍] 16장_트랜잭션과 락,2차 캐시</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/06/23/spark-intro/"><span class="level-item">[스파크2 프로그래밍] 1장_스파크 소개</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://junhee-ko.github.io/2019/06/29/jpa-performance-optimize/';
            this.page.identifier = '2019/06/29/jpa-performance-optimize/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'junhee-ko' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><p class="title is-size-4 is-block" style="line-height:inherit;">Junhee Ko</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">321</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/junhee-ko" target="_blank" rel="noopener">Follow</a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-23T15:00:00.000Z">2021-08-24</time></p><p class="title"><a href="/2021/08/24/spring-web-flux-reactive/">Spring Web Flux : Reactive</a></p><p class="categories"><a href="/categories/spring/">Spring</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-22T15:00:00.000Z">2021-08-23</time></p><p class="title"><a href="/2021/08/23/spring-web-flux-mvc/">Spring Web Flux : @MVC</a></p><p class="categories"><a href="/categories/spring/">Spring</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-21T15:00:00.000Z">2021-08-22</time></p><p class="title"><a href="/2021/08/22/spring-web-flux-functional/">Spring Web Flux : Functional</a></p><p class="categories"><a href="/categories/spring/">Spring</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-21T15:00:00.000Z">2021-08-22</time></p><p class="title"><a href="/2021/08/22/spring-web-flux-intro/">Spring Web Flux : 소개</a></p><p class="categories"><a href="/categories/spring/">Spring</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-14T15:00:00.000Z">2021-08-15</time></p><p class="title"><a href="/2021/08/15/kotlin-lamda/">람다</a></p><p class="categories"><a href="/categories/kotlin/">Kotlin</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">180</span></span></a></li><li><a class="level is-mobile" href="/categories/big-data/"><span class="level-start"><span class="level-item">Big Data</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/container/"><span class="level-start"><span class="level-item">Container</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/jpa/"><span class="level-start"><span class="level-item">JPA</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/oauth/"><span class="level-start"><span class="level-item">OAuth</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/oop/"><span class="level-start"><span class="level-item">OOP</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/os/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/tdd/"><span class="level-start"><span class="level-item">TDD</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/categories/test-code/"><span class="level-start"><span class="level-item">Test Code</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/grpc/"><span class="level-start"><span class="level-item">gRPC</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Always Learning" height="28"></a><p class="is-size-7"><span>&copy; 2021 junhee.ko</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>