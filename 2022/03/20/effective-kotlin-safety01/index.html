<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Effective Kotlin - Safety 1 - Always Learning</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Always Learning"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Always Learning"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="코틀린을 안전하게 사용하기 위한 방법을 정리한다.  가변성을 제한하라 변수의 스코프를 최소화해라 최대한 플랫폼 타입을 사용하지 마라 inferred 타입으로 리턴하지 마라 예외를 활용해 코드에 제한을 걸어라  가변성을 제한하라읽고 쓸 수 있는 프로퍼티인 var 를 사용하거나, mutable 객체를 사용하면 상태를 가질 수 있다.다음 예를 보자. 123456"><meta property="og:type" content="blog"><meta property="og:title" content="Effective Kotlin - Safety 1"><meta property="og:url" content="https://junhee-ko.github.io/2022/03/20/effective-kotlin-safety01/"><meta property="og:site_name" content="Always Learning"><meta property="og:description" content="코틀린을 안전하게 사용하기 위한 방법을 정리한다.  가변성을 제한하라 변수의 스코프를 최소화해라 최대한 플랫폼 타입을 사용하지 마라 inferred 타입으로 리턴하지 마라 예외를 활용해 코드에 제한을 걸어라  가변성을 제한하라읽고 쓸 수 있는 프로퍼티인 var 를 사용하거나, mutable 객체를 사용하면 상태를 가질 수 있다.다음 예를 보자. 123456"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://junhee-ko.github.io/img/og_image.png"><meta property="article:published_time" content="2022-03-19T15:00:00.000Z"><meta property="article:modified_time" content="2022-03-23T14:17:28.645Z"><meta property="article:author" content="junhee.ko"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://junhee-ko.github.io/2022/03/20/effective-kotlin-safety01/"},"headline":"Effective Kotlin - Safety 1","image":["https://junhee-ko.github.io/img/og_image.png"],"datePublished":"2022-03-19T15:00:00.000Z","dateModified":"2022-03-23T14:17:28.645Z","author":{"@type":"Person","name":"junhee.ko"},"publisher":{"@type":"Organization","name":"Always Learning","logo":{"@type":"ImageObject","url":"https://junhee-ko.github.io/img/logo.svg"}},"description":"코틀린을 안전하게 사용하기 위한 방법을 정리한다.  가변성을 제한하라 변수의 스코프를 최소화해라 최대한 플랫폼 타입을 사용하지 마라 inferred 타입으로 리턴하지 마라 예외를 활용해 코드에 제한을 걸어라  가변성을 제한하라읽고 쓸 수 있는 프로퍼티인 var 를 사용하거나, mutable 객체를 사용하면 상태를 가질 수 있다.다음 예를 보자. 123456"}</script><link rel="canonical" href="https://junhee-ko.github.io/2022/03/20/effective-kotlin-safety01/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Always Learning" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-19T15:00:00.000Z" title="3/20/2022, 12:00:00 AM">2022-03-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-03-23T14:17:28.645Z" title="3/23/2022, 11:17:28 PM">2022-03-23</time></span><span class="level-item"><a class="link-muted" href="/categories/kotlin/">Kotlin</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Effective Kotlin - Safety 1</h1><div class="content"><p>코틀린을 안전하게 사용하기 위한 방법을 정리한다.</p>
<ul>
<li>가변성을 제한하라</li>
<li>변수의 스코프를 최소화해라</li>
<li>최대한 플랫폼 타입을 사용하지 마라</li>
<li>inferred 타입으로 리턴하지 마라</li>
<li>예외를 활용해 코드에 제한을 걸어라</li>
</ul>
<h2 id="가변성을-제한하라"><a href="#가변성을-제한하라" class="headerlink" title="가변성을 제한하라"></a>가변성을 제한하라</h2><p>읽고 쓸 수 있는 프로퍼티인 var 를 사용하거나, mutable 객체를 사용하면 상태를 가질 수 있다.<br>다음 예를 보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsufficientFunds</span> : <span class="type">Exception</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> balance = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deposit</span><span class="params">(amount: <span class="type">Double</span>)</span></span> &#123;</span><br><span class="line">      balance += amount</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Throws(InsufficientFunds::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withdraw</span><span class="params">(amount: <span class="type">Double</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (balance &lt; amount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> InsufficientFunds()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      balance -= amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `BankAccount 에는 계좌에 돈이 얼마 있는지 나타내는 상태가 있다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> account = BankAccount()</span><br><span class="line">    assertEquals(<span class="number">0.0</span>, account.balance)</span><br><span class="line"></span><br><span class="line">    account.deposit(<span class="number">100.0</span>)</span><br><span class="line">    assertEquals(<span class="number">100.0</span>, account.balance)</span><br><span class="line"></span><br><span class="line">    account.withdraw(<span class="number">50.0</span>)</span><br><span class="line">    assertEquals(<span class="number">50.0</span>, account.balance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>시간의 변화에 따라, 변하는 요소를 표현하는 것은 유용하다. 하지만,</p>
<ol>
<li>프로그램을 이해하기 어렵고 디버깅이 어렵다.</li>
<li>시점에 따라 값이 달라져서, 코드의 실행을 예측하기 어렵다.</li>
<li>멀티 스레드 프로그램이면, 적절한 동기화가 필요하다.</li>
<li>모든 상태를 테스트해야해서, 더 많은 조합을 테스트해야한다.</li>
<li>상태가 변경되면, 다른 부분에 알려야하는 경우가 있다. (ex) 리스트에 요소 추가되면, 전체 다시 정렬</li>
</ol>
<p>코틀린에서, 가변성을 제한할 수 있는 방법에는 다음이 있다.</p>
<ol>
<li>읽기 전용 프로퍼티 val</li>
<li>가변 컬렉션과 읽기 전용 컬렉션 구분</li>
<li>데이터 클래스의 copy</li>
</ol>
<h3 id="읽기-전용-프로퍼티-val"><a href="#읽기-전용-프로퍼티-val" class="headerlink" title="읽기 전용 프로퍼티 val"></a>읽기 전용 프로퍼티 val</h3><p>val 로 선언된 프로퍼티는 일반적인 방법으로는 변하지 않는다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line">a = <span class="number">20</span> <span class="comment">// Val cannot be reassigned</span></span><br></pre></td></tr></table></figure>

<p>하지만, 읽기 전용 프로퍼티가 완전히 변경 불가능한 것은 아니다.<br>아래 예를 기준으로, list = mutableListOf(1, 2, 3, 4, 5) 와 같이 재할당하는 것이 불가능한 것이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">list.add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">assertEquals(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), list) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>읽기 전용 프로퍼티는 다른 프로퍼티를 활용하는 사용자 정의 게터로도 정의 가능하다.<br>아래 예를 기준으로, var 프로퍼티가 변할 때 값이 변할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">&quot;junhee&quot;</span></span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&quot;ko&quot;</span></span><br><span class="line"><span class="keyword">val</span> fullName</span><br><span class="line">    <span class="keyword">get</span>() = <span class="string">&quot;<span class="variable">$firstName</span> <span class="variable">$lastName</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `읽기 전용 프로퍼티는 다른 프로퍼티를 활용하는 사용자 정의 게터로도 정의 가능`<span class="params">()</span></span> &#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;junhee ko&quot;</span>, fullName)</span><br><span class="line"></span><br><span class="line">    firstName = <span class="string">&quot;updated junhee&quot;</span></span><br><span class="line">    assertEquals(<span class="string">&quot;updated junhee ko&quot;</span>, fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>값을 추출할 때마다 사용자 정의 게터가 호출되서 아래 코드처럼 사용할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(from: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Calculating <span class="variable">$from</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fizz = calculate(<span class="string">&quot;fizz&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> buzz</span><br><span class="line">    <span class="keyword">get</span>() = calculate(<span class="string">&quot;buzz&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `값을 호출할 때마다 사용자 정의 게터 호출`<span class="params">()</span></span> &#123;</span><br><span class="line">    assertEquals(<span class="number">42</span>, fizz)</span><br><span class="line">    assertEquals(<span class="number">42</span>, buzz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>val 은 스마트 캐스트 활용이 가능하다.<br>아래에서, full1 은 값을 사용하는 시점의 first 에 따라서 다른 결과가 나올 수 있어서 스마트 캐스트를 할 수 없다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> first: String? = <span class="string">&quot;lets&quot;</span></span><br><span class="line"><span class="keyword">val</span> second: String? = <span class="string">&quot;go&quot;</span></span><br><span class="line"><span class="keyword">val</span> full1: String?</span><br><span class="line">    <span class="keyword">get</span>() = first?.let &#123; <span class="string">&quot;<span class="variable">$it</span> <span class="variable">$second</span>&quot;</span> &#125;</span><br><span class="line"><span class="keyword">val</span> full2: String? = first?.let &#123; <span class="string">&quot;<span class="variable">$it</span> <span class="variable">$second</span>&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `<span class="keyword">val</span> 은 스마트 캐스트 활용 가능`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (full1 != <span class="literal">null</span>)&#123;</span><br><span class="line">        println(full1.length) <span class="comment">// Smart cast to &#x27;String&#x27; is impossible, because &#x27;full1&#x27; is a property that has open or custom getter</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (full2 != <span class="literal">null</span>) &#123;</span><br><span class="line">      println(full2.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="가변-컬렉션과-읽기-전용-컬렉션-구분"><a href="#가변-컬렉션과-읽기-전용-컬렉션-구분" class="headerlink" title="가변 컬렉션과 읽기 전용 컬렉션 구분"></a>가변 컬렉션과 읽기 전용 컬렉션 구분</h3><p>코틀린은, 읽고 쓸 수 있는 프로퍼티와 읽기 전용 프로퍼티로 구분되듯이<br>읽고 쓸 수 있는 컬렉션과 읽기 전용 컬레션으로 구분된다.</p>
<h3 id="데이터-클래스의-copy"><a href="#데이터-클래스의-copy" class="headerlink" title="데이터 클래스의 copy"></a>데이터 클래스의 copy</h3><p>immutable 객체를 사용하면 다음과 같은 장점이 있다.</p>
<ol>
<li>한 번 정의된 상태를 유지해서, 코드 이해가 쉽다.</li>
<li>공유할 때 충돌이 나지 않아서, 병렬 처리를 안전하게 할 수 있다.</li>
<li>immutable 객체에 대한 참조가 변경되지 않아서, 쉽게 캐쉬가 가능하다.</li>
<li>객체를 복사할 때 깊은 복사를 따로 하지 않아도 된다.</li>
<li>실행을 더 쉽게 에측할 수 있다.</li>
<li>set or map 의 키로 사용할 수 있다.</li>
</ol>
<p>immutable 객체는 변경할 수 없기 때문에, 자신의 일부를 수정하고자 하면 새로운 객체를 만들어야한다.<br>Int 는 내부적으로 plus 와 minus 메서드로 자신을 수정한 새로운 Int 를 리턴한다.<br>직접 만드는 immutable 객체도 마찬가지로 동작해야한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> surname: String</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withSurname</span><span class="params">(surname: <span class="type">String</span>)</span></span> = User(name, surname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `자신을 수정한 새로운 객체를 만든다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user = User(<span class="string">&quot;junhee&quot;</span>, <span class="string">&quot;ko&quot;</span>)</span><br><span class="line">    user = user.withSurname(<span class="string">&quot;kooo&quot;</span>)</span><br><span class="line">    assertEquals(<span class="string">&quot;kooo&quot;</span>, user.surname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>모든 프로퍼티를 대상으로, withSurname 같은 함수를 하나하나 만드는 것은 귀찮다.<br>그래서 data 한정자를 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> surname: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `<span class="keyword">data</span> <span class="keyword">class</span>`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user = User2(<span class="string">&quot;junhee&quot;</span>, <span class="string">&quot;ko&quot;</span>)</span><br><span class="line">    user = user.copy(surname = <span class="string">&quot;kooo&quot;</span>)</span><br><span class="line">    assertEquals(<span class="string">&quot;kooo&quot;</span>, user.surname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="변경의-스코프를-최소화해라"><a href="#변경의-스코프를-최소화해라" class="headerlink" title="변경의 스코프를 최소화해라"></a>변경의 스코프를 최소화해라</h2><ol>
<li>프로퍼티보다 지역 변수를 사용해라.</li>
<li>최대한 좁은 스코프를 갖는 변수를 사용해라. ex) 반복문 내부에서만 사용되는 변수</li>
</ol>
<p>스코프를 좁게 만들면 좋은 이유는,</p>
<ol>
<li>프로그램 추적 및 관리가 쉽다.</li>
<li>변수의 스코프가 넓으면, 다른 개발자에 의해 변수가 잘못 사용될 수 있다.</li>
</ol>
<h2 id="최대한-플랫폼-타입을-사용하지-마라"><a href="#최대한-플랫폼-타입을-사용하지-마라" class="headerlink" title="최대한 플랫폼 타입을 사용하지 마라"></a>최대한 플랫폼 타입을 사용하지 마라</h2><p>자바에서 String 타입을 리턴하는 메서드가 있다고 하자.<br>@Nullable 이 붙어 있다면, nullable 로 추정하고 String? 으로 변경된다.<br>@NotNull 이 붙어 있다면, String 으로 변경된다.</p>
<p>만약, 자바에서 List<User> 를 리턴하고 아무런 annotation 이 붙어 있지 않다고 하자.<br>코틀린이 디폴트로 모든 타입을 nullable 로 다룬다면, 리스트 자체와 리스트 내부에 있는 것들도 널인지 확인해야한다.</p>
<p>이처럼, 널 확인이 복잡하기 때문에 다른 언어에서 넘어온 타입은 platform type 으로 다룬다.<br>타입 이름 뒤에 ! 를 붙여서 표기한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> repo = UserRepo()</span><br><span class="line"><span class="keyword">val</span> user1 = repo.user <span class="comment">// type: User!</span></span><br><span class="line"><span class="keyword">val</span> user2: User = repo.user</span><br><span class="line"><span class="keyword">val</span> user3: User? = repo.user</span><br></pre></td></tr></table></figure>

<p>문제는 null 이 아니라고 생각되는 것이 null 일 가능성이 있어서 위험하다는 것이다.<br>그래서,</p>
<ol>
<li>함수가 당장 널을 리턴하지 않아도 미래에 변경될 수 있다는 것을 염두해두거나,</li>
<li>자바를 직접 조작할 수 있으면, @Nullable 이나 @NotNull 을 붙여셔 사용해야한다.</li>
<li>플랫폼 타입이 다른 곳에서 사용되는 것은 항상 위험을 내포하므로, 가능하면 제거해라.</li>
</ol>
<p>플랫폼 타입을 사용할 때, 발생할 수 있는 문제를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">statedType</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> value: String = JavaClass().value <span class="comment">// NPE</span></span><br><span class="line">    println(value.length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">platformType</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> value = JavaClass().value</span><br><span class="line">  println(value.length) <span class="comment">// NPE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>statedType 과 platformType 모두 NPE 가 발생하지만, 발생 위치가 다르다.</p>
<ul>
<li>statedType() 은 자바에서 값을 가져올 때 발생하고</li>
<li>platformType() 은 값을 활용할 때 발생한다.</li>
</ul>
<p>statedType() 에서는 널이 아니라고 예상했지만, 널이 나온다는 것을 쉽게 알 수 있고 수정할 수 있다.<br>플랫폼 타입으로 지정된 변수는 nullable 일 수도 있고 아닐 수도 있다.<br>한 두 번 안전하게 사용해도 나중에는 NPE 를 발생시킬 수 있고, 타입 검사기가 검출도 못한다.<br>이처럼, 플랫폼 타입은 더 많은 위험 가능성을 가지고 있다.</p>
<h2 id="inferred-타입으로-리턴하지-마라"><a href="#inferred-타입으로-리턴하지-마라" class="headerlink" title="inferred 타입으로 리턴하지 마라"></a>inferred 타입으로 리턴하지 마라</h2><p>리턴 타입은 외부에서 확인할 수 있도록 명시적으로 지정하자.<br>inferred 타입으로 리턴할 경우 발생할 수 있는 문제를 예로 보자.</p>
<p>자동차를 생상하는 CarFactory 가 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: Car</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>대부분의 공장에서 디폴트로 레이를 생성한다고 하자.<br>그래서, DEFAULT_CAR 는 Car 타입으로 명시하고, produce 의 리턴 타입을 제거하자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> DEFAULT_CAR: Car = Ray()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: DEFAUT_CAR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그런데 이후에, 다른 개발자가 DEFAULT_CAR 는 타입 추론으로 Car 타입으로 지정될 것이므로 다음과 같이 수정했다고 하자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> DEFAULT_CAR = Ray()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: DEFAUT_CAR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제, CarFactory 에서는 Ray 이외의 자동차 생산을 할 수 없다.</p>
<h2 id="예외를-활용해-코드에-제한을-걸어라"><a href="#예외를-활용해-코드에-제한을-걸어라" class="headerlink" title="예외를 활용해 코드에 제한을 걸어라"></a>예외를 활용해 코드에 제한을 걸어라</h2><p>확실하게 어떤 형태로 동작해야하는 코드가 있으면, 예외를 활용해 제한을 걸어라.<br>다음 방법들이 있다.</p>
<ol>
<li>require 블록: argument 제한</li>
<li>check 블록: 상태와 관련된 동작 제한</li>
<li>assert 블록: 어떤 것이 true 인지 확인 (테스트 모드에서 동작)</li>
<li>elvis 연산자: return 또는 throw 와 함께 활용</li>
</ol>
<h3 id="Argument"><a href="#Argument" class="headerlink" title="Argument"></a>Argument</h3><p>require 함수는 제한을 확인하고, 만족하지 못하면 IllegalArgumentException 을 발생시킨다.<br>일반적으로 함수 가장 앞부분에 위치해서, 코드를 읽을 때 쉽게 확인 가능하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">factorial</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">    require(n &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="상태"><a href="#상태" class="headerlink" title="상태"></a>상태</h3><p>check 함수는 상태와 관련된 제한을 걸 때 사용한다.<br>지정된 상태가 아니라면, IllegalStateException 을 발생시킨다.<br>일반적으로 require 블록 뒤에 위치시킨디.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: UserInfo &#123;</span><br><span class="line">    checkNotNull(token)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Assert-계열-함수-사용"><a href="#Assert-계열-함수-사용" class="headerlink" title="Assert 계열 함수 사용"></a>Assert 계열 함수 사용</h3><p>스스로 구현한 내용을 확인할 때 assert 계역 함수를 사용할 수 있다.<br>단위 테스트로 구현의 정확성을 확인할 수 있지만, 함수 내부에서 직접 확인해볼 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">(num: <span class="type">Int</span> = <span class="number">1</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    assert(ret.size == num)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트할 때만 활성화되므로, 오류가 발생해도 사용자는 알 수 없다.<br>그래서, 심각한 오류라면 check 를 사용하는 것이 좋다.<br>그리고, assert 를 활용하더라도 여전히 단위 테스트는 작성해야한다.<br>assert 는 양념처럼 사용해라.</p>
<h3 id="nullability-와-스마트-캐스팅"><a href="#nullability-와-스마트-캐스팅" class="headerlink" title="nullability 와 스마트 캐스팅"></a>nullability 와 스마트 캐스팅</h3><p>require 과 check 블록으로 어떤 조건을 확인해서 true 이면, 해당 조건은 이후로도 true 로 가정한다.<br>이를 활용해서 타입 비교를 하면, 스마트 캐스트가 작동한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">changeDress</span><span class="params">(person: <span class="type">Person</span>)</span></span>&#123;</span><br><span class="line">    require(person.outfit <span class="keyword">is</span> Dress)</span><br><span class="line">    <span class="keyword">val</span> dress: Dress = person.outfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>어떤 대상이 null 인지 확인할 때도 유용하다.<br>requireNotNull, checkNotNull 함수를 사용해도 좋다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(person: <span class="type">Person</span>, text: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    require(person.email != <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">val</span> email: String = person.email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return 과 throw 를 활용한 Elvis 연산자는 nullable 을 확인할 때 많이 사용된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(person: <span class="type">Person</span>, text: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> email: String = person.email ?: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run 함수를 조합해서 사용할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(person: <span class="type">Person</span>, text: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> email: String = person.email ?: run &#123;</span><br><span class="line">      log(<span class="string">&quot;Email not send, no email address&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>이펙티브 코틀린 &lt;마르친 모스칼라&gt;</p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/03/23/effective-kotlin-safety02/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Effective Kotlin - Safety 2</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/02/27/spring-kakfa-test/"><span class="level-item">Spring Kafka Test</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://junhee-ko.github.io/2022/03/20/effective-kotlin-safety01/';
            this.page.identifier = '2022/03/20/effective-kotlin-safety01/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'junhee-ko' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><p class="title is-size-4 is-block" style="line-height:inherit;">Junhee Ko</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">334</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/junhee-ko" target="_blank" rel="noopener">Follow</a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-08T15:00:00.000Z">2022-04-09</time></p><p class="title"><a href="/2022/04/09/bean-validation/">Bean Validation</a></p><p class="categories"><a href="/categories/spring/">Spring</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-29T15:00:00.000Z">2022-03-30</time></p><p class="title"><a href="/2022/03/30/effective-kotlin-readability02/">Effective Kotlin - Readability 2</a></p><p class="categories"><a href="/categories/kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-26T15:00:00.000Z">2022-03-27</time></p><p class="title"><a href="/2022/03/27/effective-kotlin-readability01/">Effective Kotlin - Readability 1</a></p><p class="categories"><a href="/categories/kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-22T15:00:00.000Z">2022-03-23</time></p><p class="title"><a href="/2022/03/23/effective-kotlin-safety02/">Effective Kotlin - Safety 2</a></p><p class="categories"><a href="/categories/kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-19T15:00:00.000Z">2022-03-20</time></p><p class="title"><a href="/2022/03/20/effective-kotlin-safety01/">Effective Kotlin - Safety 1</a></p><p class="categories"><a href="/categories/kotlin/">Kotlin</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">180</span></span></a></li><li><a class="level is-mobile" href="/categories/big-data/"><span class="level-start"><span class="level-item">Big Data</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/container/"><span class="level-start"><span class="level-item">Container</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/graphql/"><span class="level-start"><span class="level-item">GraphQL</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/jpa/"><span class="level-start"><span class="level-item">JPA</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/oauth/"><span class="level-start"><span class="level-item">OAuth</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/oop/"><span class="level-start"><span class="level-item">OOP</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/os/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/reactor/"><span class="level-start"><span class="level-item">Reactor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/tdd/"><span class="level-start"><span class="level-item">TDD</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/categories/test-code/"><span class="level-start"><span class="level-item">Test Code</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/grpc/"><span class="level-start"><span class="level-item">gRPC</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Always Learning" height="28"></a><p class="is-size-7"><span>&copy; 2022 junhee.ko</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>